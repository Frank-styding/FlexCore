--- PROJECT EXPORT ---
Root: C:\Users\ASUS\documents\projects\FlexCore


============================================================
FILE_PATH: components.json
============================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/app/globals.css",
    "baseColor": "zinc",
    "cssVariables": true,
    "prefix": ""
  },
  "iconLibrary": "lucide",
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "registries": {}
}


============================================================
FILE_PATH: next-env.d.ts
============================================================
/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/dev/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


============================================================
FILE_PATH: next.config.ts
============================================================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {};

export default nextConfig;


============================================================
FILE_PATH: package.json
============================================================
{
  "name": "flex-core",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@dnd-kit/core": "^6.3.1",
    "@dnd-kit/modifiers": "^9.0.0",
    "@dnd-kit/sortable": "^10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "@hookform/resolvers": "^5.2.2",
    "@monaco-editor/react": "^4.7.0",
    "@radix-ui/react-checkbox": "^1.3.3",
    "@radix-ui/react-context-menu": "^2.2.16",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.16",
    "@radix-ui/react-label": "^2.1.8",
    "@radix-ui/react-popover": "^1.1.15",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-separator": "^1.1.8",
    "@radix-ui/react-slot": "^1.2.4",
    "@radix-ui/react-switch": "^1.2.6",
    "@radix-ui/react-tabs": "^1.1.13",
    "@radix-ui/react-tooltip": "^1.2.8",
    "@reduxjs/toolkit": "^2.11.2",
    "@supabase/ssr": "^0.8.0",
    "@supabase/supabase-js": "^2.89.0",
    "@tanstack/react-table": "^8.21.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "lucide-react": "^0.562.0",
    "next": "16.1.0",
    "next-themes": "^0.4.6",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "react-hook-form": "^7.69.0",
    "react-redux": "^9.2.0",
    "redux-persist": "^6.0.0",
    "sonner": "^2.0.7",
    "sql.js": "^1.13.0",
    "tailwind-merge": "^3.4.0",
    "uuid": "^13.0.0",
    "zod": "^4.2.1",
    "zustand": "^5.0.9"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "autoprefixer": "^10.4.23",
    "eslint": "^9",
    "eslint-config-next": "16.1.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.18",
    "tw-animate-css": "^1.4.0",
    "typescript": "^5"
  }
}


============================================================
FILE_PATH: tsconfig.json
============================================================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noImplicitAny": false,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}


============================================================
FILE_PATH: src\middleware.ts
============================================================
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";
import { createClient } from "./lib/supabase/server";

const publicRoutes = ["/login", "/auth", "/api/webhooks", "/view"];
const authRoutes = ["/login", "/register"];

export async function middleware(request: NextRequest) {
  const response = NextResponse.next({
    request: { headers: request.headers },
  });

  const supabase = await createClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();

  const url = request.nextUrl.clone();
  const path = url.pathname;

  if (!user) {
    const isPublic = publicRoutes.some((route) => path.startsWith(route));

    if (!isPublic) {
      if (path.startsWith("/api")) {
        return NextResponse.json({ message: "Unauthorized" }, { status: 401 });
      }

      url.pathname = "/login";

      return NextResponse.redirect(url);
    }
  }

  if (user) {
    const isAuthRoute = authRoutes.some((route) => path.startsWith(route));
    if (isAuthRoute || path === "/") {
      url.pathname = "/dashboard";
      return NextResponse.redirect(url);
    }
  }

  return response;
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};


============================================================
FILE_PATH: src\app\globals.css
============================================================
@import "tailwindcss";
@import "tw-animate-css";
@custom-variant dark (&:is(.dark *));
/*
Source - https://stackoverflow.com/a
Posted by rozsazoltan, modified by community. See post 'Timeline' for change history
Retrieved 2025-12-25, License - CC BY-SA 4.0
*/

/* --- GRID SYSTEM (Cols, Rows, Spans) --- */
@source inline('{,sm:,md:,lg:,xl:,2xl:}{,hover:}{grid-cols,col-span,grid-rows,row-span,col,row}-{1,2,3,4,5,6,7,8,9,10,11,12}');

/* --- GAP (Spacing) --- */
@source inline('{,sm:,md:,lg:,xl:,2xl:}{,hover:}{gap,gap-x,gap-y}-{0,0.5,1,1.5,2,2.5,3,3.5,4,5,6,7,8,9,10,11,12,14,16,20,24,28,32,36,40,44,48,52,56,60,64,72,80,96}');

/* --- MARGINS (m, mx, my, mt, mb, ml, mr) --- */
@source inline('{,sm:,md:,lg:,xl:,2xl:}{,hover:}{m,mx,my,mt,mb,ml,mr,px,py,pl,pr,pt,pb,p}-{auto,0,0.5,1,1.5,2,2.5,3,3.5,4,5,6,7,8,9,10,11,12,14,16,20,24,28,32,36,40,44,48,52,56,60,64,72,80,96}');

/* --- SIZING: Width, Height, Size (Numeric + Keywords) --- */
/* AHORA INCLUYE 'size' (ancho + alto a la vez) */
@source inline('{,sm:,md:,lg:,xl:,2xl:}{,hover:}{w,h,size}-{auto,px,full,screen,min,max,fit,0,0.5,1,1.5,2,2.5,3,3.5,4,5,6,7,8,9,10,11,12,14,16,20,24,28,32,36,40,44,48,52,56,60,64,72,80,96}');

/* --- SIZING: Width, Height, Size (Fractions) --- */
@source inline('{,sm:,md:,lg:,xl:,2xl:}{,hover:}{w,h,size}-{1/2,1/3,2/3,1/4,2/4,3/4,1/5,2/5,3/5,4/5,1/6,2/6,3/6,4/6,5/6,1/12,2/12,3/12,4/12,5/12,6/12,7/12,8/12,9/12,10/12,11/12}');

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --radius-2xl: calc(var(--radius) + 8px);
  --radius-3xl: calc(var(--radius) + 12px);
  --radius-4xl: calc(var(--radius) + 16px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.141 0.005 285.823);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.141 0.005 285.823);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.141 0.005 285.823);
  --primary: oklch(0.21 0.006 285.885);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.967 0.001 286.375);
  --secondary-foreground: oklch(0.21 0.006 285.885);
  --muted: oklch(0.967 0.001 286.375);
  --muted-foreground: oklch(0.552 0.016 285.938);
  --accent: oklch(0.967 0.001 286.375);
  --accent-foreground: oklch(0.21 0.006 285.885);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.92 0.004 286.32);
  --input: oklch(0.92 0.004 286.32);
  --ring: oklch(0.705 0.015 286.067);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.141 0.005 285.823);
  --sidebar-primary: oklch(0.21 0.006 285.885);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.967 0.001 286.375);
  --sidebar-accent-foreground: oklch(0.21 0.006 285.885);
  --sidebar-border: oklch(0.92 0.004 286.32);
  --sidebar-ring: oklch(0.705 0.015 286.067);
}

.dark {
  --background: oklch(0.141 0.005 285.823);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.21 0.006 285.885);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.21 0.006 285.885);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.92 0.004 286.32);
  --primary-foreground: oklch(0.21 0.006 285.885);
  --secondary: oklch(0.274 0.006 286.033);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.274 0.006 286.033);
  --muted-foreground: oklch(0.705 0.015 286.067);
  --accent: oklch(0.274 0.006 286.033);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.552 0.016 285.938);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.21 0.006 285.885);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.274 0.006 286.033);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.552 0.016 285.938);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}


============================================================
FILE_PATH: src\app\layout.tsx
============================================================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import Providers from "@/providers";
import { Toaster } from "sonner";
const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <Providers>{children}</Providers>
        <Toaster richColors position="top-center" />
      </body>
    </html>
  );
}


============================================================
FILE_PATH: src\app\not-found.tsx
============================================================
"use client";
import { FileQuestion } from "lucide-react";

export default function NotFound() {
  return (
    <div className="flex h-screen w-full flex-col items-center justify-center bg-background px-4 text-center">
      <div className="flex h-20 w-20 items-center justify-center rounded-full bg-muted shadow-sm animate-in zoom-in duration-300">
        <FileQuestion className="h-10 w-10 text-primary" />
      </div>

      <h1 className="mt-6 text-5xl font-extrabold tracking-tight text-foreground sm:text-7xl">
        404
      </h1>

      <h2 className="mt-4 text-2xl font-semibold tracking-tight text-foreground">
        Página no encontrada
      </h2>

      <p className="mt-2 max-w-md text-muted-foreground">
        Lo sentimos, no pudimos encontrar la página que estás buscando. Verifica
        la URL o regresa al inicio.
      </p>

      <p className="mt-12 text-sm text-muted-foreground">
        Código de error: 404
      </p>
    </div>
  );
}


============================================================
FILE_PATH: src\app\(auth)\callback\route.ts
============================================================
import { NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";

export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url);
  const code = searchParams.get("code");
  const next = searchParams.get("next") ?? "/dashboard";

  if (code) {
    const supabase = await createClient();
    const { error } = await supabase.auth.exchangeCodeForSession(code);
    if (!error) {
      return NextResponse.redirect(`${origin}${next}`);
    }
  }
  return NextResponse.redirect(`${origin}/auth/auth-code-error`);
}


============================================================
FILE_PATH: src\app\(auth)\login\page.tsx
============================================================
"use client";
import { Card, CardContent, CardFooter } from "@/components/ui/card";
import {
  AuthButtons,
  AuthHeader,
  LoginForm,
  useAuthForm,
} from "@/features/auth";

export default function LoginPage() {
  const state = useAuthForm();

  return (
    <div className="flex items-center justify-center min-h-screen p-4">
      <Card className="w-full max-w-md shadow-lg">
        <AuthHeader isSignUp={state.isSignUp} />
        <CardContent className="space-y-4">
          <LoginForm {...state} />
        </CardContent>
        <CardFooter className="justify-center">
          <AuthButtons
            isSignUp={state.isSignUp}
            setIsSignUp={state.setIsSignUp}
          />
        </CardFooter>
      </Card>
    </div>
  );
}


============================================================
FILE_PATH: src\app\dashboard\page.tsx
============================================================
"use client";
import {
  DashboardGrid,
  GalleryHeader,
  GalleryModals,
  GallerySearchBar,
} from "@/features/dashboard";
import { useDashboardGallery } from "@/features/dashboard/hook/useDashboardGallery";

export default function DashboardGallery() {
  const {
    results,
    query,
    onChange,
    onClick,
    onAdd,
    onDelete,
    onConfirmDelete,
    onConfirm,
    onEdit,
    addFormId,
    editFormId,
    confirmId,
    loadingModalId,
    onConfirmEdit,
    onSignOut,
  } = useDashboardGallery();

  return (
    <div className="p-8 flex flex-col min-h-screen">
      <GalleryHeader onSignOut={onSignOut} />
      <div className="w-full flex-1">
        <GallerySearchBar query={query} onChange={onChange} onAdd={onAdd} />
        <DashboardGrid
          dashboards={results}
          onClick={onClick}
          onEdit={onEdit}
          onDelete={onDelete}
        />
        <GalleryModals
          addFormId={addFormId}
          editFormId={editFormId}
          confirmId={confirmId}
          loadingModalId={loadingModalId}
          onConfirm={onConfirm}
          onConfirmEdit={onConfirmEdit}
          onConfirmDelete={onConfirmDelete}
        />
      </div>
    </div>
  );
}


============================================================
FILE_PATH: src\app\dashboard\[dashboardId]\layout.tsx
============================================================
"use client";
import { ReactNode } from "react";
import { SidebarProvider } from "@/components/ui/sidebar";
import { DashboardSidebar } from "@/features/dashboard/components/sidebar";
import { DashboardHeader } from "@/features/dashboard/components/DashboardHeader";
import { useDashboard } from "@/features/dashboard/hook/useDashboard";
import { LoadingIndicator } from "@/features/dashboard/components/LoadingIndicator";

export default function DashboardLayout({ children }: { children: ReactNode }) {
  const {
    currentPage,
    loadingId,
    handlePublicToggle,
    handleOpenView,
    handleOpenSettings,
  } = useDashboard();
  return (
    <SidebarProvider>
      <DashboardSidebar />
      <main className="grid h-screen w-full min-w-0 grid-rows-[60px_1fr] overflow-hidden transition-[width] duration-300 ease-linear">
        <DashboardHeader
          currentPage={currentPage}
          onPublicToggle={handlePublicToggle}
          onOpenView={handleOpenView}
          onSettings={handleOpenSettings}
        />
        <div className="w-full overflow-auto bg-background">{children}</div>
      </main>
      <LoadingIndicator loadingId={loadingId} />
    </SidebarProvider>
  );
}


============================================================
FILE_PATH: src\app\dashboard\[dashboardId]\page.tsx
============================================================
export default function Dashboard() {
  return <div></div>;
}


============================================================
FILE_PATH: src\app\dashboard\[dashboardId]\page\[pageId]\page.tsx
============================================================
"use client";

import { Loader2, Settings } from "lucide-react";
import { Button } from "@/components/ui/button";
import { usePageViewer } from "@/features/page/hooks/usePageViewer";
import { DynamicComponent } from "@/features/engine";
import { ComponentEditorModal } from "@/features/editor/components/modals/CreateComponentModal";
import { cn } from "@/lib/utils"; // Asumiendo que usas shadcn/ui

export default function Page() {
  const {
    engine,
    componentStruct,
    page,
    handleConfigure,
    handleOnCloseEditor,
    isLoading,
    isEditing,
    handleOnOpenEditor,
    onSave,
  } = usePageViewer();

  return (
    <>
      {/* 1. Agregamos 'min-h' para asegurar que nunca colapse a 0px si está vacío.
         2. Usamos flex-1 si esto está dentro de un layout flex.
      */}
      <div className="w-full h-full min-h-[300px] relative flex flex-col">
        {/* LOADER: Renderizado condicionalmente como OVERLAY (encima de todo) */}
        {isLoading && (
          <div className="absolute inset-0 z-50 flex flex-col items-center justify-center gap-2 bg-background/80 backdrop-blur-sm animate-in fade-in duration-200">
            <Loader2 className="h-10 w-10 animate-spin text-primary" />
            <p className="text-sm text-muted-foreground">
              Procesando cambios...
            </p>
          </div>
        )}

        {!isEditing && (
          <div
            className={cn(
              "flex-1 w-full h-full transition-opacity duration-200",
              isLoading ? "opacity-50 pointer-events-none" : "opacity-100"
            )}
          >
            {componentStruct ? (
              <DynamicComponent data={componentStruct} engine={engine} />
            ) : (
              // Estado vacío / Configuración
              <div className="w-full h-full min-h-[50vh] flex justify-center items-center">
                <Button
                  onClick={handleConfigure}
                  variant="outline"
                  className="w-40 h-40 flex flex-col gap-2 text-lg"
                >
                  <Settings className="size-8 mb-2" />
                  Configurar Página
                  <span className="text-xs text-muted-foreground font-normal">
                    {page?.name || "Sin título"}
                  </span>
                </Button>
              </div>
            )}
          </div>
        )}
      </div>

      <ComponentEditorModal
        id={"213123123_editor_modal"}
        onClose={handleOnCloseEditor}
        onOpen={handleOnOpenEditor}
        onSave={onSave}
      />
    </>
  );
}


============================================================
FILE_PATH: src\app\view\[pageId]\page.tsx
============================================================
"use client";
import { notFound } from "next/navigation";
import { Loader2 } from "lucide-react";
import { usePublicPageViewer } from "./usePublicPageViewer";
import { DynamicComponent } from "@/features/engine/components/DynamicComponent";

export default function PublicPageView() {
  const { componentStruct, isLoading, isAccessDenied, engine } =
    usePublicPageViewer();

  if (isAccessDenied) {
    notFound();
  }

  if (isLoading) {
    return (
      <div className="flex h-screen w-full items-center justify-center bg-background">
        <Loader2 className="h-10 w-10 animate-spin text-primary" />
      </div>
    );
  }

  return (
    <div className="w-full h-screen bg-background flex flex-col overflow-hidden">
      {componentStruct ? (
        <div className="w-full flex-1 relative overflow-auto">
          <DynamicComponent data={componentStruct} engine={engine} />
        </div>
      ) : (
        <div className="flex h-full items-center justify-center text-muted-foreground">
          La página no generó contenido.
        </div>
      )}
    </div>
  );
}


============================================================
FILE_PATH: src\app\view\[pageId]\usePublicPageViewer.ts
============================================================
/* eslint-disable react-hooks/set-state-in-effect */
// hooks/usePublicPageViewer.ts
import { useState, useEffect, useRef } from "react";
import { useParams } from "next/navigation";
import { IComponent } from "@/features/engine/modules/types/component.type";
import { useEngine } from "@/features/engine";
import { IEngine } from "@/features/engine/modules";
import { usePageStore } from "@/features/page/store/usePageStore";

export const usePublicPageViewer = () => {
  const params = useParams();
  const pageId = params.pageId as string;
  const [componentStruct, setComponentStruct] = useState<IComponent | null>(
    null
  );

  const [isLoading, setIsLoading] = useState(true);
  const [isAccessDenied, setIsAccessDenied] = useState(false);
  const { createEngine, runScript, connect } = useEngine();
  const [engine, setEngine] = useState<IEngine | null>(null);
  const { fetchPublicPage } = usePageStore(pageId);

  useEffect(() => {
    setEngine(createEngine());
  }, []);

  useEffect(() => {
    let isMounted = true;

    const loadPublicPage = async () => {
      setIsAccessDenied(false);
      setComponentStruct(null);

      if (!pageId) return;

      try {
        setIsLoading(true);

        const data = await fetchPublicPage(pageId);

        /*         if (actionResult.meta.requestStatus === "rejected") {
          throw new Error("Error técnico al obtener la página");
        } */

        if (!data) {
          if (isMounted) setIsAccessDenied(true);
          return;
        }

        const { js_script, sql_script, dashboard_config } = data;

        // 2. Conectar a la Base de Datos del Cliente
        if (dashboard_config && dashboard_config.type) {
          // Pasamos false para no intentar guardar en Redux del Dashboard inexistente
          await connect(dashboard_config, false);
        }

        // 3. Ejecutar el Script
        if (js_script && engine) {
          const { result } = await runScript(
            js_script,
            sql_script || "",
            engine
          );

          if (isMounted) {
            setComponentStruct(result);
          }
        }
      } catch (error) {
        // Solo logueamos errores reales de ejecución, no bloqueos de acceso
        console.error("Error ejecutando página pública:", error);
      } finally {
        if (isMounted) setIsLoading(false);
      }
    };

    loadPublicPage();

    return () => {
      isMounted = false;
    };
    // IMPORTANTE: Agregamos las dependencias correctas para que recargue si cambia el ID
  }, [engine]);

  return {
    componentStruct,
    isLoading,
    isAccessDenied,
    engine,
  };
};


============================================================
FILE_PATH: src\components\shared\DynamicForm.tsx
============================================================
"use client";

import {
  ControllerRenderProps,
  useForm,
  UseFormSetError,
} from "react-hook-form";
import { z } from "zod";
import { zodResolver } from "@hookform/resolvers/zod";
import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";

import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { memo, useEffect, useState } from "react";
import { IconPicker } from "./IconPicker";

export type FieldConfig = {
  name: string;
  label: string;
  type: "text" | "number" | "email" | "select" | "date" | "icon";
  placeholder?: string;
  options?: { label: string; value: string }[]; // Solo para selects
  className?: string; // Para controlar el ancho (col-span-1, etc.)
};

export interface DynamicFormProps {
  schema: z.ZodType<any, any>; // El esquema de validación Zod
  defaultValues?: any; // Los datos iniciales
  fields?: FieldConfig[]; // La lista de campos a dibujar
  type?: "new" | "update";
  confirmName?: string;
  submitLabel?: string;
  onSubmit?: (data: any, setError: UseFormSetError<any>) => void;
  className?: string;
  hideWhenEmpty?: boolean;
}

const FormDynamicInput = memo(
  ({
    field,
    fieldConfig,
  }: {
    field: ControllerRenderProps<any, string>;
    fieldConfig: FieldConfig;
  }) => {
    switch (fieldConfig.type) {
      case "icon":
        return (
          <IconPicker
            value={field.value}
            onChange={field.onChange}
            placeholder={fieldConfig.placeholder}
          />
        );
      case "select":
        return (
          <Select onValueChange={field.onChange} value={field.value ?? ""}>
            <FormControl>
              <SelectTrigger>
                <SelectValue placeholder={fieldConfig.placeholder} />
              </SelectTrigger>
            </FormControl>
            <SelectContent>
              {fieldConfig.options?.map((opt) => (
                <SelectItem key={opt.value} value={opt.value}>
                  {opt.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        );
      default:
        return (
          <Input
            {...field}
            value={field.value ?? ""}
            type={fieldConfig.type}
            placeholder={fieldConfig.placeholder}
            onChange={(e) => {
              const val =
                fieldConfig.type === "number"
                  ? e.target.value == ""
                    ? ""
                    : Number(e.target.value)
                  : e.target.value;
              field.onChange(val);
            }}
          />
        );
    }
  }
);

FormDynamicInput.displayName = "FormDynamicInput";

export function DynamicForm({
  schema,
  defaultValues = {},
  fields = [],
  onSubmit,
  submitLabel,
  confirmName,
  className,
  hideWhenEmpty,
}: DynamicFormProps) {
  const [show, setShow] = useState(false);

  const form = useForm({
    resolver: schema ? zodResolver(schema) : undefined,
    defaultValues: defaultValues,
    mode: "onChange",
  });

  const defaultValuesJson = JSON.stringify(defaultValues);

  useEffect(() => {
    if (defaultValues) {
      form.reset(defaultValues);
    }
  }, [defaultValuesJson, form]);

  const handleOnChange = () => {
    setShow(JSON.stringify(form.getValues()) != JSON.stringify(defaultValues));
  };

  const handleReset = (e: React.MouseEvent<HTMLButtonElement>) => {
    e.preventDefault();
    form.reset(defaultValues);
    setShow(false);
  };
  const handleSubmitWrapper = (data: any) => {
    if (onSubmit) {
      onSubmit(data, form.setError);
    }
  };
  return (
    <Form {...form}>
      <form
        onSubmit={form.handleSubmit(handleSubmitWrapper)}
        onChange={handleOnChange}
        className="space-y-6"
      >
        {/* GRID DINÁMICO */}
        <div className={`grid grid-cols-1 ${className} gap-4`}>
          {fields.map((fieldConfig) => (
            <FormField
              key={fieldConfig.name}
              control={form.control}
              name={fieldConfig.name}
              render={({ field }) => (
                <FormItem className={fieldConfig.className || "col-span-1"}>
                  <FormLabel>{fieldConfig.label}</FormLabel>
                  <FormControl>
                    <FormDynamicInput field={field} fieldConfig={fieldConfig} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          ))}
        </div>
        {(show || !hideWhenEmpty) && (
          <div className="flex w-full gap-4">
            <Button
              type="button"
              variant="outline"
              className=" md:w-auto"
              onClick={handleReset}
            >
              Cancelar
            </Button>
            <Button type="submit" className=" md:w-auto">
              {submitLabel} {confirmName}
            </Button>
          </div>
        )}
      </form>
    </Form>
  );
}


============================================================
FILE_PATH: src\components\shared\IconPicker.tsx
============================================================
import { Check, ChevronsUpDown } from "lucide-react";
import { icons } from "lucide-react"; // Importamos todos los iconos
import { cn } from "@/lib/utils";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command";

import { useState } from "react";
import { Button } from "../ui/button";

export const IconPicker = ({
  value,
  onChange,
  placeholder = "Seleccionar icono...",
}: {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
}) => {
  const [open, setOpen] = useState(false);
  const iconList = Object.keys(icons) as (keyof typeof icons)[];
  const SelectedIcon = value ? icons[value as keyof typeof icons] : null;
  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          role="combobox"
          aria-expanded={open}
          className="w-full justify-between"
        >
          {value ? (
            <div className="flex items-center gap-2">
              {SelectedIcon && <SelectedIcon className="h-4 w-4" />}
              <span>{value}</span>
            </div>
          ) : (
            <span className="text-muted-foreground">{placeholder}</span>
          )}
          <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-50 p-0" align="start">
        <Command>
          <CommandInput placeholder="Buscar icono..." />
          <CommandList>
            <CommandEmpty>No se encontró el icono.</CommandEmpty>
            <CommandGroup>
              {iconList.map((iconName) => {
                const IconComponent = icons[iconName];
                return (
                  <CommandItem
                    key={iconName}
                    value={iconName}
                    onSelect={(currentValue) => {
                      onChange(currentValue === value ? "" : iconName);
                      setOpen(false);
                    }}
                  >
                    <Check
                      className={cn(
                        "mr-2 h-4 w-4",
                        value === iconName ? "opacity-100" : "opacity-0"
                      )}
                    />
                    <div className="flex items-center gap-2">
                      <IconComponent className="h-4 w-4 text-muted-foreground" />
                      <span>{iconName}</span>
                    </div>
                  </CommandItem>
                );
              })}
            </CommandGroup>
          </CommandList>
        </Command>
      </PopoverContent>
    </Popover>
  );
};


============================================================
FILE_PATH: src\components\shared\Modal.tsx
============================================================
"use client";

import { ReactNode, useEffect, useLayoutEffect } from "react";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { useIsModalOpen, useModalActions } from "@/hooks/useModal";

export interface ModalProps {
  id: string;
  triggerText?: string;
  title?: string;
  description?: string;
  className?: string;
  children?: ReactNode;
  disableOutside?: boolean;
  disableEscape?: boolean;
  onOpen?: () => void;
  onClose?: () => void;
}

export function Modal({
  triggerText,
  title,
  children,
  id,
  description,
  className,
  disableEscape,
  disableOutside,
  onClose,
  onOpen,
}: ModalProps) {
  const { registerModal, unRegisterModal, closeModal } = useModalActions();
  const isOpen = useIsModalOpen(id);

  useLayoutEffect(() => {
    registerModal(id);
    return () => unRegisterModal(id);
  }, [id]);

  useEffect(() => {
    if (isOpen) onOpen?.();
  }, [isOpen]);

  const openChange = (open: boolean) => {
    if (open) return;
    onClose?.();
    closeModal(id);
  };

  return (
    <Dialog open={isOpen} onOpenChange={openChange}>
      <DialogPortal>
        {triggerText && (
          <DialogTrigger asChild>
            <Button>{triggerText}</Button>
          </DialogTrigger>
        )}

        <DialogContent
          className={"sm:max-w-106.25 " + className}
          onEscapeKeyDown={(e) => {
            if (disableEscape) e.preventDefault();
          }}
          onInteractOutside={(e) => {
            if (disableOutside) e.preventDefault();
          }}
        >
          <DialogHeader className="">
            <DialogTitle>{title}</DialogTitle>
          </DialogHeader>

          <DialogDescription className={!description ? "sr-only" : ""}>
            {description}
          </DialogDescription>

          <div className="mt-4">{children}</div>
        </DialogContent>
      </DialogPortal>
    </Dialog>
  );
}


============================================================
FILE_PATH: src\components\shared\SearchToolbar.tsx
============================================================
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils"; // Asumiendo que usas la utilidad estándar de shadcn/ui

interface SearchToolbarProps {
  value: string;
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  placeholder?: string;
  actionLabel?: string;
  onAction?: () => void;
  isLoading?: boolean;
  className?: string;
}

export const SearchToolbar = ({
  value,
  onChange,
  placeholder = "Buscar...",
  actionLabel,
  onAction,
  isLoading = false,
  className,
}: SearchToolbarProps) => {
  return (
    <div className={cn("w-full flex gap-4 items-center", className)}>
      <Input
        onChange={onChange}
        placeholder={placeholder}
        value={value}
        aria-label={placeholder}
        className="flex-1"
        disabled={isLoading}
      />
      {actionLabel && (
        <Button variant="default" onClick={onAction} disabled={isLoading}>
          {actionLabel}
        </Button>
      )}
    </div>
  );
};


============================================================
FILE_PATH: src\components\shared\modals\ConfirmModal.tsx
============================================================
import { useModalActions } from "@/hooks/useModal";
import { Modal, ModalProps } from "../Modal";
import { Button } from "@/components/ui/button";

type ConfirmModalProps = ModalProps & {
  onConfirm?: () => void;
  onCancel?: () => void;
  confirmName?: string;
};

export const ConfirmModal = (props: ConfirmModalProps) => {
  const { closeModal } = useModalActions();
  const onCancel = () => {
    props.onCancel?.();
    closeModal(props.id);
  };
  const onConfirm = () => {
    props.onConfirm?.();
    closeModal(props.id);
  };

  return (
    <Modal {...props} className={"w-80 " + props.className}>
      <div className="w-full  flex gap-10 justify-center">
        <Button variant="outline" onClick={onCancel}>
          Cancelar
        </Button>
        <Button variant="default" onClick={onConfirm}>
          {props.confirmName ?? "Confirmar"}
        </Button>
      </div>
    </Modal>
  );
};


============================================================
FILE_PATH: src\components\shared\modals\FormModal.tsx
============================================================
import { useModalActions } from "@/hooks/useModal";
import { DynamicForm, DynamicFormProps } from "../DynamicForm";
import { Modal, ModalProps } from "../Modal";

type FormModalProps = ModalProps &
  Omit<DynamicFormProps, "className"> & { classNameForm?: string };

export const FormModal = (props: FormModalProps) => {
  const { closeModal } = useModalActions();
  const handleSummit = (data, error) => {
    props.onSubmit?.(data, error);
    closeModal(props.id);
  };
  return (
    <Modal {...props}>
      <DynamicForm
        {...props}
        onSubmit={handleSummit}
        className={props.classNameForm}
      />
    </Modal>
  );
};


============================================================
FILE_PATH: src\components\shared\modals\LoadingModal.tsx
============================================================
"use client";
import { Loader2 } from "lucide-react";
import { cn } from "@/lib/utils";
import { Modal, ModalProps } from "../Modal";
import { useModalActions } from "@/hooks/useModal";

export const LoadingModal = ({ className, ...props }: ModalProps) => {
  const { getModalData } = useModalActions();
  const data = getModalData(props.id) || {};
  const message = data.message || "Cargando...";
  const subMessage = data.subMessage;
  return (
    <Modal
      {...props}
      disableEscape
      disableOutside
      className={cn(
        "min-w-75 w-auto h-auto p-8 flex flex-col items-center justify-center outline-none",
        className
      )}
    >
      <div className="flex flex-col items-center justify-center space-y-4">
        <div className="relative flex h-12 w-12 items-center justify-center rounded-full bg-primary/10">
          <Loader2 className="h-7 w-7 animate-spin text-primary" />
        </div>
        <div className="text-center space-y-1">
          <h3 className="text-lg font-semibold text-foreground">{message}</h3>
          {subMessage && (
            <p className="text-sm text-muted-foreground animate-pulse">
              {subMessage}
            </p>
          )}
        </div>
      </div>
    </Modal>
  );
};


============================================================
FILE_PATH: src\components\ui\BottomTabs.tsx
============================================================
"use client";

import React, { useEffect, useState, useRef } from "react";
import { Plus, X } from "lucide-react";
import { cn } from "@/lib/utils";
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragEndEvent,
} from "@dnd-kit/core";
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  useSortable,
  horizontalListSortingStrategy,
} from "@dnd-kit/sortable";
import { CSS } from "@dnd-kit/utilities";
import { restrictToHorizontalAxis } from "@dnd-kit/modifiers";

// --- Tipos ---

export interface TabData {
  id: string;
  label: string;
}

interface TabsProps {
  initialTabs?: TabData[];
  onSelect?: (tabId: string) => void;
  onDelete?: (tabId: string) => void;
  onAdd?: (newTab: TabData) => void;
  onRename?: (tabId: string, newLabel: string) => void;
  onReorder?: (newOrder: TabData[]) => void;

  /** * BLOQUEADOR: Si se provee, se ejecutará antes de eliminar.
   * @param tabId El ID de la pestaña a eliminar.
   * @param confirmDelete La función que DEBE llamarse para proceder con la eliminación.
   */
  onDeleteRequest?: (tabId: string, confirmDelete: () => void) => void;
}

// --- Componente Individual (Sin cambios) ---

interface SortableTabProps {
  tab: TabData;
  isActive: boolean;
  onClick: () => void;
  onClose: (e: React.MouseEvent) => void;
  onRename: (id: string, newName: string) => void;
}

const SortableTab = ({
  tab,
  isActive,
  onClick,
  onClose,
  onRename,
}: SortableTabProps) => {
  const { attributes, listeners, setNodeRef, transform, transition } =
    useSortable({ id: tab.id });

  const [isEditing, setIsEditing] = useState(false);
  const [editValue, setEditValue] = useState(tab.label);
  const inputRef = useRef<HTMLInputElement>(null);

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
  };

  useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [isEditing]);

  const handleFinishEdit = () => {
    setIsEditing(false);
    if (editValue.trim() !== "") {
      onRename(tab.id, editValue);
    } else {
      setEditValue(tab.label);
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter") handleFinishEdit();
    if (e.key === "Escape") {
      setIsEditing(false);
      setEditValue(tab.label);
    }
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      {...attributes}
      {...listeners}
      onClick={onClick}
      className={cn(
        "group flex min-w-[120px] max-w-[200px] cursor-pointer select-none items-center justify-between border-r px-4 py-1.5 text-sm transition-colors shrink-0",
        isActive
          ? "bg-background font-medium text-foreground z-10 shadow-[inset_0_-2px_0_0_hsl(var(--primary))]"
          : "bg-muted/50 hover:bg-muted text-muted-foreground"
      )}
    >
      {isEditing ? (
        <input
          ref={inputRef}
          value={editValue}
          onChange={(e) => setEditValue(e.target.value)}
          onBlur={handleFinishEdit}
          onKeyDown={handleKeyDown}
          onPointerDown={(e) => e.stopPropagation()}
          className="h-5 w-full min-w-0 max-w-20 bg-transparent outline-none focus:border-b focus:border-primary text-foreground"
        />
      ) : (
        <span
          className="truncate w-full"
          onDoubleClick={() => setIsEditing(true)}
          title="Doble click para renombrar"
        >
          {tab.label}
        </span>
      )}

      <button
        onClick={onClose}
        onPointerDown={(e) => e.stopPropagation()}
        className={cn(
          "ml-2 rounded-full p-0.5 hover:bg-red-200 hover:text-red-700 opacity-0 transition-all",
          (isActive || "group-hover:opacity-100") && "opacity-100"
        )}
      >
        <X className="size-3" />
      </button>
    </div>
  );
};

// --- Componente Principal ---

export function Tabs({
  initialTabs,
  onSelect,
  onDelete,
  onAdd,
  onRename,
  onReorder,
  onDeleteRequest, // <--- Nueva prop recibida
}: TabsProps) {
  const [isMounted, setIsMounted] = useState(false);
  const [activeTabId, setActiveTabId] = useState("sheet1");

  const [tabs, setTabs] = useState<TabData[]>(
    initialTabs || [
      { id: "sheet1", label: "Hoja 1" },
      { id: "sheet2", label: "Hoja 2" },
    ]
  );

  useEffect(() => {
    // eslint-disable-next-line react-hooks/set-state-in-effect
    setIsMounted(true);
  }, []);

  const sensors = useSensors(
    useSensor(PointerSensor, { activationConstraint: { distance: 8 } }),
    useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })
  );

  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;
    if (over && active.id !== over.id) {
      setTabs((items) => {
        const oldIndex = items.findIndex((i) => i.id === active.id);
        const newIndex = items.findIndex((i) => i.id === over.id);
        const newOrder = arrayMove(items, oldIndex, newIndex);
        if (onReorder) onReorder(newOrder);
        return newOrder;
      });
    }
  };

  const handleAddTab = () => {
    const newId = `sheet-${Date.now()}`;
    const num = tabs.length + 1;
    const newTab: TabData = { id: newId, label: `Hoja ${num}` };
    const updatedTabs = [...tabs, newTab];
    setTabs(updatedTabs);
    setActiveTabId(newId);
    if (onAdd) onAdd(newTab);
    if (onSelect) onSelect(newId);
  };

  // --- LÓGICA DE ELIMINACIÓN MODIFICADA ---
  const handleCloseTab = (e: React.MouseEvent, id: string) => {
    e.stopPropagation();
    if (tabs.length <= 1) return;

    // 1. Definimos la acción real de eliminar
    const executeDelete = () => {
      // Nota: Usamos setTabs con callback para asegurar el estado más fresco
      setTabs((currentTabs) => {
        const targetIndex = currentTabs.findIndex((t) => t.id === id);
        const newTabs = currentTabs.filter((t) => t.id !== id);

        // Ajustar tab activa si borramos la que estaba seleccionada
        if (activeTabId === id) {
          const newActiveIndex = Math.max(0, targetIndex - 1);
          // Verificar que existe una pestaña remanente
          if (newTabs[newActiveIndex]) {
            const newActiveId = newTabs[newActiveIndex].id;
            setActiveTabId(newActiveId);
            if (onSelect) onSelect(newActiveId);
          }
        }
        return newTabs;
      });

      // Notificar eliminación exitosa
      if (onDelete) onDelete(id);
    };

    // 2. Comprobamos si hay un interceptor (onDeleteRequest)
    if (onDeleteRequest) {
      // Pasamos el ID y la función para ejecutar la eliminación
      onDeleteRequest(id, executeDelete);
    } else {
      // Si no hay interceptor, eliminamos directamente
      executeDelete();
    }
  };

  const handleTabClick = (id: string) => {
    setActiveTabId(id);
    if (onSelect) onSelect(id);
  };

  const handleRename = (id: string, newLabel: string) => {
    const updatedTabs = tabs.map((t) =>
      t.id === id ? { ...t, label: newLabel } : t
    );
    setTabs(updatedTabs);
    if (onRename) onRename(id, newLabel);
  };

  if (!isMounted) return <div className="h-10 border-t bg-muted/30" />;

  return (
    <div className="flex h-12 w-full items-start pt-1 border-t bg-muted/30">
      <div className="flex flex-1 overflow-x-auto overflow-y-hidden pb-1 [&::-webkit-scrollbar]:h-2 [&::-webkit-scrollbar-thumb]:rounded-full [&::-webkit-scrollbar-thumb]:bg-muted-foreground/20 hover:[&::-webkit-scrollbar-thumb]:bg-muted-foreground/40 [&::-webkit-scrollbar-track]:bg-transparent">
        <DndContext
          sensors={sensors}
          collisionDetection={closestCenter}
          onDragEnd={handleDragEnd}
          modifiers={[restrictToHorizontalAxis]}
        >
          <SortableContext
            items={tabs.map((t) => t.id)}
            strategy={horizontalListSortingStrategy}
          >
            <div className="flex h-full min-w-max items-center">
              {tabs.map((tab) => (
                <SortableTab
                  key={tab.id}
                  tab={tab}
                  isActive={activeTabId === tab.id}
                  onClick={() => handleTabClick(tab.id)}
                  onClose={(e) => handleCloseTab(e, tab.id)}
                  onRename={handleRename}
                />
              ))}
            </div>
          </SortableContext>
        </DndContext>
      </div>

      <button
        onClick={handleAddTab}
        className="flex h-full w-10 shrink-0 items-center justify-center border-l hover:bg-muted transition-colors text-muted-foreground z-20 bg-muted/30"
        title="Nueva hoja"
      >
        <Plus className="size-5" />
      </button>
    </div>
  );
}


============================================================
FILE_PATH: src\components\ui\breadcrumb.tsx
============================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

function Breadcrumb({ ...props }: React.ComponentProps<"nav">) {
  return <nav aria-label="breadcrumb" data-slot="breadcrumb" {...props} />
}

function BreadcrumbList({ className, ...props }: React.ComponentProps<"ol">) {
  return (
    <ol
      data-slot="breadcrumb-list"
      className={cn(
        "text-muted-foreground flex flex-wrap items-center gap-1.5 text-sm break-words sm:gap-2.5",
        className
      )}
      {...props}
    />
  )
}

function BreadcrumbItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-item"
      className={cn("inline-flex items-center gap-1.5", className)}
      {...props}
    />
  )
}

function BreadcrumbLink({
  asChild,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
}) {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      data-slot="breadcrumb-link"
      className={cn("hover:text-foreground transition-colors", className)}
      {...props}
    />
  )
}

function BreadcrumbPage({ className, ...props }: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-page"
      role="link"
      aria-disabled="true"
      aria-current="page"
      className={cn("text-foreground font-normal", className)}
      {...props}
    />
  )
}

function BreadcrumbSeparator({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-separator"
      role="presentation"
      aria-hidden="true"
      className={cn("[&>svg]:size-3.5", className)}
      {...props}
    >
      {children ?? <ChevronRight />}
    </li>
  )
}

function BreadcrumbEllipsis({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-ellipsis"
      role="presentation"
      aria-hidden="true"
      className={cn("flex size-9 items-center justify-center", className)}
      {...props}
    >
      <MoreHorizontal className="size-4" />
      <span className="sr-only">More</span>
    </span>
  )
}

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}


============================================================
FILE_PATH: src\components\ui\button-group.tsx
============================================================
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { Separator } from "@/components/ui/separator"

const buttonGroupVariants = cva(
  "flex w-fit items-stretch [&>*]:focus-visible:z-10 [&>*]:focus-visible:relative [&>[data-slot=select-trigger]:not([class*='w-'])]:w-fit [&>input]:flex-1 has-[select[aria-hidden=true]:last-child]:[&>[data-slot=select-trigger]:last-of-type]:rounded-r-md has-[>[data-slot=button-group]]:gap-2",
  {
    variants: {
      orientation: {
        horizontal:
          "[&>*:not(:first-child)]:rounded-l-none [&>*:not(:first-child)]:border-l-0 [&>*:not(:last-child)]:rounded-r-none",
        vertical:
          "flex-col [&>*:not(:first-child)]:rounded-t-none [&>*:not(:first-child)]:border-t-0 [&>*:not(:last-child)]:rounded-b-none",
      },
    },
    defaultVariants: {
      orientation: "horizontal",
    },
  }
)

function ButtonGroup({
  className,
  orientation,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof buttonGroupVariants>) {
  return (
    <div
      role="group"
      data-slot="button-group"
      data-orientation={orientation}
      className={cn(buttonGroupVariants({ orientation }), className)}
      {...props}
    />
  )
}

function ButtonGroupText({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"div"> & {
  asChild?: boolean
}) {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      className={cn(
        "bg-muted flex items-center gap-2 rounded-md border px-4 text-sm font-medium shadow-xs [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function ButtonGroupSeparator({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="button-group-separator"
      orientation={orientation}
      className={cn(
        "bg-input relative !m-0 self-stretch data-[orientation=vertical]:h-auto",
        className
      )}
      {...props}
    />
  )
}

export {
  ButtonGroup,
  ButtonGroupSeparator,
  ButtonGroupText,
  buttonGroupVariants,
}


============================================================
FILE_PATH: src\components\ui\button.tsx
============================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
        "icon-sm": "size-8",
        "icon-lg": "size-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant = "default",
  size = "default",
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      data-variant={variant}
      data-size={size}
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }


============================================================
FILE_PATH: src\components\ui\card.tsx
============================================================
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-2 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}


============================================================
FILE_PATH: src\components\ui\checkbox.tsx
============================================================
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { CheckIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="grid place-content-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}

export { Checkbox }


============================================================
FILE_PATH: src\components\ui\command.tsx
============================================================
"use client"

import * as React from "react"
import { Command as CommandPrimitive } from "cmdk"
import { SearchIcon } from "lucide-react"

import { cn } from "@/lib/utils"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"

function Command({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive>) {
  return (
    <CommandPrimitive
      data-slot="command"
      className={cn(
        "bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md",
        className
      )}
      {...props}
    />
  )
}

function CommandDialog({
  title = "Command Palette",
  description = "Search for a command to run...",
  children,
  className,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof Dialog> & {
  title?: string
  description?: string
  className?: string
  showCloseButton?: boolean
}) {
  return (
    <Dialog {...props}>
      <DialogHeader className="sr-only">
        <DialogTitle>{title}</DialogTitle>
        <DialogDescription>{description}</DialogDescription>
      </DialogHeader>
      <DialogContent
        className={cn("overflow-hidden p-0", className)}
        showCloseButton={showCloseButton}
      >
        <Command className="[&_[cmdk-group-heading]]:text-muted-foreground **:data-[slot=command-input-wrapper]:h-12 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

function CommandInput({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Input>) {
  return (
    <div
      data-slot="command-input-wrapper"
      className="flex h-9 items-center gap-2 border-b px-3"
    >
      <SearchIcon className="size-4 shrink-0 opacity-50" />
      <CommandPrimitive.Input
        data-slot="command-input"
        className={cn(
          "placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        {...props}
      />
    </div>
  )
}

function CommandList({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.List>) {
  return (
    <CommandPrimitive.List
      data-slot="command-list"
      className={cn(
        "max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto",
        className
      )}
      {...props}
    />
  )
}

function CommandEmpty({
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Empty>) {
  return (
    <CommandPrimitive.Empty
      data-slot="command-empty"
      className="py-6 text-center text-sm"
      {...props}
    />
  )
}

function CommandGroup({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Group>) {
  return (
    <CommandPrimitive.Group
      data-slot="command-group"
      className={cn(
        "text-foreground [&_[cmdk-group-heading]]:text-muted-foreground overflow-hidden p-1 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium",
        className
      )}
      {...props}
    />
  )
}

function CommandSeparator({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Separator>) {
  return (
    <CommandPrimitive.Separator
      data-slot="command-separator"
      className={cn("bg-border -mx-1 h-px", className)}
      {...props}
    />
  )
}

function CommandItem({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Item>) {
  return (
    <CommandPrimitive.Item
      data-slot="command-item"
      className={cn(
        "data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function CommandShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="command-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}


============================================================
FILE_PATH: src\components\ui\context-menu.tsx
============================================================
"use client"

import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function ContextMenu({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Root>) {
  return <ContextMenuPrimitive.Root data-slot="context-menu" {...props} />
}

function ContextMenuTrigger({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Trigger>) {
  return (
    <ContextMenuPrimitive.Trigger data-slot="context-menu-trigger" {...props} />
  )
}

function ContextMenuGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Group>) {
  return (
    <ContextMenuPrimitive.Group data-slot="context-menu-group" {...props} />
  )
}

function ContextMenuPortal({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Portal>) {
  return (
    <ContextMenuPrimitive.Portal data-slot="context-menu-portal" {...props} />
  )
}

function ContextMenuSub({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Sub>) {
  return <ContextMenuPrimitive.Sub data-slot="context-menu-sub" {...props} />
}

function ContextMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioGroup>) {
  return (
    <ContextMenuPrimitive.RadioGroup
      data-slot="context-menu-radio-group"
      {...props}
    />
  )
}

function ContextMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <ContextMenuPrimitive.SubTrigger
      data-slot="context-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto" />
    </ContextMenuPrimitive.SubTrigger>
  )
}

function ContextMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubContent>) {
  return (
    <ContextMenuPrimitive.SubContent
      data-slot="context-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

function ContextMenuContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Content>) {
  return (
    <ContextMenuPrimitive.Portal>
      <ContextMenuPrimitive.Content
        data-slot="context-menu-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-context-menu-content-available-height) min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </ContextMenuPrimitive.Portal>
  )
}

function ContextMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <ContextMenuPrimitive.Item
      data-slot="context-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function ContextMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.CheckboxItem>) {
  return (
    <ContextMenuPrimitive.CheckboxItem
      data-slot="context-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.CheckboxItem>
  )
}

function ContextMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioItem>) {
  return (
    <ContextMenuPrimitive.RadioItem
      data-slot="context-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.RadioItem>
  )
}

function ContextMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <ContextMenuPrimitive.Label
      data-slot="context-menu-label"
      data-inset={inset}
      className={cn(
        "text-foreground px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function ContextMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Separator>) {
  return (
    <ContextMenuPrimitive.Separator
      data-slot="context-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function ContextMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="context-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}


============================================================
FILE_PATH: src\components\ui\dialog.tsx
============================================================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 outline-none sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}


============================================================
FILE_PATH: src\components\ui\dropdown-menu.tsx
============================================================
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}


============================================================
FILE_PATH: src\components\ui\dynamic-icon.tsx
============================================================
import { AlertCircle, icons } from "lucide-react";
import { LucideProps } from "lucide-react";

export type IconName = keyof typeof icons;
interface DynamicIconProps extends LucideProps {
  name: IconName;
}

export const DynamicIcon = ({ name, ...props }: DynamicIconProps) => {
  const LucideIcon = icons[name];
  if (!LucideIcon) {
    return <AlertCircle />;
  }
  return <LucideIcon {...props} />;
};


============================================================
FILE_PATH: src\components\ui\form.tsx
============================================================
"use client"

import * as React from "react"
import type * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  useFormState,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState } = useFormContext()
  const formState = useFormState({ name: fieldContext.name })
  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

function FormItem({ className, ...props }: React.ComponentProps<"div">) {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div
        data-slot="form-item"
        className={cn("grid gap-2", className)}
        {...props}
      />
    </FormItemContext.Provider>
  )
}

function FormLabel({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  const { error, formItemId } = useFormField()

  return (
    <Label
      data-slot="form-label"
      data-error={!!error}
      className={cn("data-[error=true]:text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
}

function FormControl({ ...props }: React.ComponentProps<typeof Slot>) {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      data-slot="form-control"
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
}

function FormDescription({ className, ...props }: React.ComponentProps<"p">) {
  const { formDescriptionId } = useFormField()

  return (
    <p
      data-slot="form-description"
      id={formDescriptionId}
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function FormMessage({ className, ...props }: React.ComponentProps<"p">) {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : props.children

  if (!body) {
    return null
  }

  return (
    <p
      data-slot="form-message"
      id={formMessageId}
      className={cn("text-destructive text-sm", className)}
      {...props}
    >
      {body}
    </p>
  )
}

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}


============================================================
FILE_PATH: src\components\ui\input.tsx
============================================================
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }


============================================================
FILE_PATH: src\components\ui\label.tsx
============================================================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }


============================================================
FILE_PATH: src\components\ui\popover.tsx
============================================================
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  )
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }


============================================================
FILE_PATH: src\components\ui\scroll-area.tsx
============================================================
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }


============================================================
FILE_PATH: src\components\ui\select.tsx
============================================================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "item-aligned",
  align = "center",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        align={align}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span
        data-slot="select-item-indicator"
        className="absolute right-2 flex size-3.5 items-center justify-center"
      >
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}


============================================================
FILE_PATH: src\components\ui\separator.tsx
============================================================
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }


============================================================
FILE_PATH: src\components\ui\sheet.tsx
============================================================
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}


============================================================
FILE_PATH: src\components\ui\sidebar.tsx
============================================================
/* eslint-disable react-hooks/purity */
"use client";

import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import { PanelLeftIcon } from "lucide-react";

import { useIsMobile } from "@/hooks/use-mobile";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Separator } from "@/components/ui/separator";
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet";
import { Skeleton } from "@/components/ui/skeleton";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

const SIDEBAR_COOKIE_NAME = "sidebar_state";
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;
const SIDEBAR_WIDTH = "16rem";
const SIDEBAR_WIDTH_MOBILE = "18rem";
const SIDEBAR_WIDTH_ICON = "3rem";
const SIDEBAR_KEYBOARD_SHORTCUT = "b";

type SidebarContextProps = {
  state: "expanded" | "collapsed";
  open: boolean;
  setOpen: (open: boolean) => void;
  openMobile: boolean;
  setOpenMobile: (open: boolean) => void;
  isMobile: boolean;
  toggleSidebar: () => void;
};

const SidebarContext = React.createContext<SidebarContextProps | null>(null);

function useSidebar() {
  const context = React.useContext(SidebarContext);
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.");
  }

  return context;
}

function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  defaultOpen?: boolean;
  open?: boolean;
  onOpenChange?: (open: boolean) => void;
}) {
  const isMobile = useIsMobile();
  const [openMobile, setOpenMobile] = React.useState(false);

  // This is the internal state of the sidebar.
  // We use openProp and setOpenProp for control from outside the component.
  const [_open, _setOpen] = React.useState(defaultOpen);
  const open = openProp ?? _open;
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === "function" ? value(open) : value;
      if (setOpenProp) {
        setOpenProp(openState);
      } else {
        _setOpen(openState);
      }

      // This sets the cookie to keep the sidebar state.
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`;
    },
    [setOpenProp, open]
  );

  // Helper to toggle the sidebar.
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open);
  }, [isMobile, setOpen, setOpenMobile]);

  // Adds a keyboard shortcut to toggle the sidebar.
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (
        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
        (event.metaKey || event.ctrlKey)
      ) {
        event.preventDefault();
        toggleSidebar();
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [toggleSidebar]);

  // We add a state so that we can do data-state="expanded" or "collapsed".
  // This makes it easier to style the sidebar with Tailwind classes.
  const state = open ? "expanded" : "collapsed";

  const contextValue = React.useMemo<SidebarContextProps>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
  );

  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          data-slot="sidebar-wrapper"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH,
              "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn(
            "group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full",
            className
          )}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  );
}

function Sidebar({
  side = "left",
  variant = "sidebar",
  collapsible = "offcanvas",
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  side?: "left" | "right";
  variant?: "sidebar" | "floating" | "inset";
  collapsible?: "offcanvas" | "icon" | "none";
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar();

  if (collapsible === "none") {
    return (
      <div
        data-slot="sidebar"
        className={cn(
          "bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col",
          className
        )}
        {...props}
      >
        {children}
      </div>
    );
  }

  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-slot="sidebar"
          data-mobile="true"
          className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <SheetHeader className="sr-only">
            <SheetTitle>Sidebar</SheetTitle>
            <SheetDescription>Displays the mobile sidebar.</SheetDescription>
          </SheetHeader>
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    );
  }

  return (
    <div
      className="group peer text-sidebar-foreground hidden md:block"
      data-state={state}
      data-collapsible={state === "collapsed" ? collapsible : ""}
      data-variant={variant}
      data-side={side}
      data-slot="sidebar"
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        data-slot="sidebar-gap"
        className={cn(
          "relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear",
          "group-data-[collapsible=offcanvas]:w-0",
          "group-data-[side=right]:rotate-180",
          variant === "floating" || variant === "inset"
            ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon)"
        )}
      />
      <div
        data-slot="sidebar-container"
        className={cn(
          "fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex",
          side === "left"
            ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
            : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          variant === "floating" || variant === "inset"
            ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l",
          className
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          data-slot="sidebar-inner"
          className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
        >
          {children}
        </div>
      </div>
    </div>
  );
}

function SidebarTrigger({
  className,
  onClick,
  classNameIcon,
  ...props
}: React.ComponentProps<typeof Button> & { classNameIcon?: string }) {
  const { toggleSidebar } = useSidebar();

  return (
    <Button
      data-sidebar="trigger"
      data-slot="sidebar-trigger"
      variant="ghost"
      size="icon"
      className={cn("size-7", className)}
      onClick={(event) => {
        onClick?.(event);
        toggleSidebar();
      }}
      {...props}
    >
      <PanelLeftIcon className={classNameIcon} />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  );
}

function SidebarRail({ className, ...props }: React.ComponentProps<"button">) {
  const { toggleSidebar } = useSidebar();

  return (
    <button
      data-sidebar="rail"
      data-slot="sidebar-rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex",
        "in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  );
}

function SidebarInset({ className, ...props }: React.ComponentProps<"main">) {
  return (
    <main
      data-slot="sidebar-inset"
      className={cn(
        "bg-background relative flex w-full flex-1 flex-col",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2",
        className
      )}
      {...props}
    />
  );
}

function SidebarInput({
  className,
  ...props
}: React.ComponentProps<typeof Input>) {
  return (
    <Input
      data-slot="sidebar-input"
      data-sidebar="input"
      className={cn("bg-background h-8 w-full shadow-none", className)}
      {...props}
    />
  );
}

function SidebarHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-header"
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  );
}

function SidebarFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-footer"
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  );
}

function SidebarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="sidebar-separator"
      data-sidebar="separator"
      className={cn("bg-sidebar-border mx-2 w-auto", className)}
      {...props}
    />
  );
}

function SidebarContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-content"
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  );
}

function SidebarGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group"
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  );
}

function SidebarGroupLabel({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"div"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "div";

  return (
    <Comp
      data-slot="sidebar-group-label"
      data-sidebar="group-label"
      className={cn(
        "text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  );
}

function SidebarGroupAction({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "button";

  return (
    <Comp
      data-slot="sidebar-group-action"
      data-sidebar="group-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  );
}

function SidebarGroupContent({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group-content"
      data-sidebar="group-content"
      className={cn("w-full text-sm", className)}
      {...props}
    />
  );
}

function SidebarMenu({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu"
      data-sidebar="menu"
      className={cn("flex w-full min-w-0 flex-col gap-1", className)}
      {...props}
    />
  );
}

function SidebarMenuItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-item"
      data-sidebar="menu-item"
      className={cn("group/menu-item relative", className)}
      {...props}
    />
  );
}

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = "default",
  size = "default",
  tooltip,
  className,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean;
  isActive?: boolean;
  tooltip?: string | React.ComponentProps<typeof TooltipContent>;
} & VariantProps<typeof sidebarMenuButtonVariants>) {
  const Comp = asChild ? Slot : "button";
  const { isMobile, state } = useSidebar();

  const button = (
    <Comp
      data-slot="sidebar-menu-button"
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  );

  if (!tooltip) {
    return button;
  }

  if (typeof tooltip === "string") {
    tooltip = {
      children: tooltip,
    };
  }

  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent
        side="right"
        align="center"
        hidden={state !== "collapsed" || isMobile}
        {...tooltip}
      />
    </Tooltip>
  );
}

function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean;
  showOnHover?: boolean;
}) {
  const Comp = asChild ? Slot : "button";

  return (
    <Comp
      data-slot="sidebar-menu-action"
      data-sidebar="menu-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0",
        className
      )}
      {...props}
    />
  );
}

function SidebarMenuBadge({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-menu-badge"
      data-sidebar="menu-badge"
      className={cn(
        "text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none",
        "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  );
}

function SidebarMenuSkeleton({
  className,
  showIcon = false,
  ...props
}: React.ComponentProps<"div"> & {
  showIcon?: boolean;
}) {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`;
  }, []);

  return (
    <div
      data-slot="sidebar-menu-skeleton"
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-(--skeleton-width) flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  );
}

function SidebarMenuSub({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu-sub"
      data-sidebar="menu-sub"
      className={cn(
        "border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  );
}

function SidebarMenuSubItem({
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-sub-item"
      data-sidebar="menu-sub-item"
      className={cn("group/menu-sub-item relative", className)}
      {...props}
    />
  );
}

function SidebarMenuSubButton({
  asChild = false,
  size = "md",
  isActive = false,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean;
  size?: "sm" | "md";
  isActive?: boolean;
}) {
  const Comp = asChild ? Slot : "a";

  return (
    <Comp
      data-slot="sidebar-menu-sub-button"
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  );
}

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
};


============================================================
FILE_PATH: src\components\ui\skeleton.tsx
============================================================
import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }


============================================================
FILE_PATH: src\components\ui\switch.tsx
============================================================
"use client"

import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }


============================================================
FILE_PATH: src\components\ui\table.tsx
============================================================
"use client"

import * as React from "react"

import { cn } from "@/lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}


============================================================
FILE_PATH: src\components\ui\Tabs.tsx
============================================================
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }


============================================================
FILE_PATH: src\components\ui\tooltip.tsx
============================================================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-foreground text-background animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-foreground fill-foreground z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }


============================================================
FILE_PATH: src\features\auth\index.ts
============================================================
export { AuthButtons } from "./components/AuthButtons";
export { AuthHeader } from "./components/AuthHeader";
export { LoginForm } from "./components/LoginForm";
export { useAuthForm } from "./hooks/useAuthForm";


============================================================
FILE_PATH: src\features\auth\components\AuthButtons.tsx
============================================================
import { Button } from "@/components/ui/button";

export const AuthButtons = ({
  isSignUp,
  setIsSignUp,
}: {
  isSignUp: boolean;
  setIsSignUp: (value: boolean) => void;
}) => (
  <Button
    variant="link"
    className="text-sm text-muted-foreground"
    onClick={() => setIsSignUp(!isSignUp)}
  >
    {isSignUp
      ? "¿Ya tienes cuenta? Inicia sesión"
      : "¿No tienes cuenta? Regístrate"}
  </Button>
);


============================================================
FILE_PATH: src\features\auth\components\AuthHeader.tsx
============================================================
import { CardDescription, CardHeader, CardTitle } from "@/components/ui/card";

export const AuthHeader = ({ isSignUp }: { isSignUp: boolean }) => (
  <CardHeader className="space-y-1">
    <CardTitle className="text-2xl font-bold text-center">
      {isSignUp ? "Crear cuenta" : "Bienvenido de nuevo"}
    </CardTitle>
    <CardDescription className="text-center">
      {isSignUp
        ? "Ingresa tus datos para registrarte en la plataforma"
        : "Ingresa tu email y contraseña para acceder"}
    </CardDescription>
  </CardHeader>
);


============================================================
FILE_PATH: src\features\auth\components\LoginForm.tsx
============================================================
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Loader2 } from "lucide-react";

export const LoginForm = ({
  email,
  setEmail,
  password,
  setPassword,
  onSubmit,
  isLoading,
  isSignUp,
}: {
  email: string;
  setEmail: (value: string) => void;
  password: string;
  setPassword: (value: string) => void;
  onSubmit: (e: React.FormEvent) => Promise<void>;
  isLoading: boolean;
  isSignUp?: boolean;
}) => (
  <form onSubmit={onSubmit} className="space-y-4">
    <div className="space-y-2">
      <Label htmlFor="email">Email</Label>
      <Input
        id="email"
        type="email"
        placeholder="nombre@ejemplo.com"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        required
        disabled={isLoading}
      />
    </div>
    <div className="space-y-2">
      <Label htmlFor="password">Contraseña</Label>
      <Input
        id="password"
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        required
        disabled={isLoading}
      />
    </div>

    <Button className="w-full" type="submit" disabled={isLoading}>
      {isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
      {isSignUp ? "Crear cuenta" : "Iniciar sesión"}
    </Button>
  </form>
);


============================================================
FILE_PATH: src\features\auth\hooks\useAuthForm.ts
============================================================
"use client";

import { systemSupabase } from "@/lib/supabase/client";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { toast } from "sonner";

export const useAuthForm = () => {
  const router = useRouter();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [isSignUp, setIsSignUp] = useState(false);
  /*   const checkSession = useCheckSession();
   */
  const handleAuth = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);

    try {
      if (isSignUp) {
        const { error } = await systemSupabase.auth.signUp({
          email,
          password,
          options: {
            emailRedirectTo: `${window.location.origin}/auth/callback`,
          },
        });

        if (error) throw error;
        toast.success("¡Cuenta creada con éxito!", {
          description: "Por favor, revisa tu email para confirmar tu cuenta.",
          duration: 5000,
        });
      } else {
        const { error } = await systemSupabase.auth.signInWithPassword({
          email,
          password,
        });

        if (error) throw error;

        toast.success("¡Bienvenido de nuevo!", {
          description: "Iniciando sesión...",
        });
        router.refresh();
        router.push("/dashboard");
      }
    } catch (err: any) {
      toast.error("Ocurrió un error", {
        description: err.message || "No se pudo completar la solicitud.",
      });
    } finally {
      setIsLoading(false);
    }
  };

  return {
    isSignUp,
    setIsSignUp,
    email,
    setEmail,
    password,
    setPassword,
    isLoading,
    onSubmit: handleAuth,
  };
};


============================================================
FILE_PATH: src\features\dashboard\index.ts
============================================================
export { DashboardCard } from "./components/DashboardCard";
export { DashboardGrid } from "./components/DashboardGrid";
export { GalleryHeader } from "./components/GalleryHeader";
export { GalleryModals } from "./components/GalleryModals";
export { GallerySearchBar } from "./components/GallerySearchBar";


============================================================
FILE_PATH: src\features\dashboard\components\DashboardCard.tsx
============================================================
import { Button } from "@/components/ui/button";
import { Card, CardHeader, CardContent } from "@/components/ui/card";
import { TrashIcon, Play, Edit } from "lucide-react";
import { DashboardCardProps } from "../types/dashboard.types";

export const DashboardCard = ({
  name,
  onClick,
  onDelete,
  onEdit,
}: DashboardCardProps) => {
  return (
    <Card className="w-40 h-35 gap-4 items-center justify-center ">
      <CardHeader className="text-center  w-full text-2xl" title={name}>
        {name}
      </CardHeader>
      <CardContent className="flex gap-2">
        <Button variant="outline" size="icon" onClick={onDelete}>
          <TrashIcon className="h-4 w-4" />
        </Button>
        <Button variant="outline" size="icon" onClick={onEdit}>
          <Edit className="h-4 w-4" />
        </Button>
        <Button variant="outline" size="icon" onClick={onClick}>
          <Play className="h-4 w-4" />
        </Button>
      </CardContent>
    </Card>
  );
};


============================================================
FILE_PATH: src\features\dashboard\components\DashboardGrid.tsx
============================================================
import { DashboardCardData } from "../types/dashboard.types";
import { DashboardCard } from "./DashboardCard";

interface DashboardGridProps {
  dashboards: DashboardCardData[];
  onClick: (dashboardId: string) => void;
  onEdit: (dashboardId: string) => void;
  onDelete: (dashboardId: string) => void;
}

export const DashboardGrid = ({
  dashboards,
  onClick,
  onEdit,
  onDelete,
}: DashboardGridProps) => {
  if (dashboards.length === 0) {
    return (
      <div className="flex items-center justify-center p-8">
        <p className="text-muted-foreground text-lg">
          No se encontraron dashboards.
        </p>
      </div>
    );
  }

  return (
    <div className="flex flex-wrap gap-4">
      {dashboards.map((dashboard) => (
        <DashboardCard
          key={dashboard.id}
          name={dashboard.name}
          onClick={() => onClick(dashboard.id)}
          onEdit={() => onEdit(dashboard.id)}
          onDelete={() => onDelete(dashboard.id)}
        />
      ))}
    </div>
  );
};


============================================================
FILE_PATH: src\features\dashboard\components\DashboardHeader.tsx
============================================================
import { SidebarTrigger } from "@/components/ui/sidebar";
import { Button } from "@/components/ui/button";
import { Label } from "@radix-ui/react-label";
import { Switch } from "@radix-ui/react-switch";
import { Globe, Lock, ExternalLink, Settings } from "lucide-react";
import { DashboardHeaderProps } from "../types/dashboard.types";

export const DashboardHeader = ({
  currentPage,
  onPublicToggle,
  onOpenView,
  onSettings,
}: DashboardHeaderProps) => {
  return (
    <div className="grid w-full grid-cols-[auto_1fr_auto] items-center p-2">
      <SidebarTrigger classNameIcon="size-6" className="p-5" />
      <div />
      <div className="flex items-center gap-4 px-2">
        {currentPage && (
          <div className="flex items-center gap-2 border-r pr-4 mr-2">
            <div className="flex items-center space-x-2">
              <Switch
                id="public-mode"
                checked={currentPage.isPublic || false}
                onCheckedChange={onPublicToggle}
                aria-label={currentPage.isPublic ? "Público" : "Privado"}
              />
              <Label
                htmlFor="public-mode"
                className="flex items-center gap-1 text-xs cursor-pointer select-none text-muted-foreground"
              >
                {currentPage.isPublic ? (
                  <Globe className="size-3" />
                ) : (
                  <Lock className="size-3" />
                )}
                {currentPage.isPublic ? "Público" : "Privado"}
              </Label>
            </div>
          </div>
        )}
        {currentPage && (
          <>
            <Button
              variant="ghost"
              size="icon"
              onClick={onOpenView}
              title="Abrir vista previa"
              aria-label="Abrir vista previa en nueva pestaña"
            >
              <ExternalLink className="size-5" />
            </Button>
            <Button
              variant="ghost"
              size="icon"
              onClick={onSettings}
              title="Configurar Scripts"
              aria-label="Configurar scripts de la página"
            >
              <Settings className="size-6" />
            </Button>
          </>
        )}
      </div>
    </div>
  );
};


============================================================
FILE_PATH: src\features\dashboard\components\GalleryHeader.tsx
============================================================
import { Button } from "@/components/ui/button";
import { LogOut } from "lucide-react";

interface GalleryHeaderProps {
  onSignOut: () => void;
}

export const GalleryHeader = ({ onSignOut }: GalleryHeaderProps) => {
  return (
    <div className="mb-10 pt-2 flex justify-between items-center">
      <h1 className="text-3xl font-bold">Dashboard</h1>
      <Button
        variant="ghost"
        onClick={onSignOut}
        className="text-muted-foreground hover:text-destructive hover:bg-destructive/10"
      >
        <LogOut className="mr-2 h-4 w-4" />
        Cerrar Sesión
      </Button>
    </div>
  );
};


============================================================
FILE_PATH: src\features\dashboard\components\GalleryModals.tsx
============================================================
import { ConfirmModal } from "@/components/shared/modals/ConfirmModal";
import { FormModal } from "@/components/shared/modals/FormModal";
import { DASHBOARD_FIELDS, DASHBOARD_SCHEMA } from "../types/dashboard.types";
import { LoadingModal } from "@/components/shared/modals/LoadingModal";

interface GalleryModalsProps {
  addFormId: string;
  editFormId: string;
  confirmId: string;
  loadingModalId: string;
  onConfirm: (data: { name: string }) => void;
  onConfirmEdit: (data: { name: string }) => void;
  onConfirmDelete: () => void;
}

export const GalleryModals = ({
  addFormId,
  editFormId,
  confirmId,
  loadingModalId,
  onConfirm,
  onConfirmEdit,
  onConfirmDelete,
}: GalleryModalsProps) => {
  return (
    <>
      <FormModal
        id={addFormId}
        title="Nuevo Dashboard"
        schema={DASHBOARD_SCHEMA}
        fields={DASHBOARD_FIELDS}
        confirmName="Dashboard"
        submitLabel="Crear"
        onSubmit={onConfirm}
      />
      <FormModal
        id={editFormId}
        title="Editar Dashboard"
        schema={DASHBOARD_SCHEMA}
        fields={DASHBOARD_FIELDS}
        confirmName="Dashboard"
        submitLabel="Guardar"
        onSubmit={onConfirmEdit}
      />
      <ConfirmModal
        id={confirmId}
        title="Confirmar Eliminación"
        description="¿Estás seguro de que quieres eliminar este dashboard? Esta acción no se puede deshacer."
        confirmName="Eliminar"
        onConfirm={onConfirmDelete}
      />
      <LoadingModal id={loadingModalId} />
    </>
  );
};


============================================================
FILE_PATH: src\features\dashboard\components\GallerySearchBar.tsx
============================================================
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";

interface GallerySearchBarProps {
  query: string;
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onAdd: () => void;
}

export const GallerySearchBar = ({
  query,
  onChange,
  onAdd,
}: GallerySearchBarProps) => {
  return (
    <div className="w-full h-20 flex gap-4">
      <Input
        onChange={onChange}
        placeholder="Buscar dashboard"
        value={query}
        aria-label="Buscar dashboard"
        className="flex-1"
      />
      <Button variant="default" onClick={onAdd}>
        Nuevo Dashboard
      </Button>
    </div>
  );
};


============================================================
FILE_PATH: src\features\dashboard\components\LoadingIndicator.tsx
============================================================
import { LoadingModal } from "@/components/shared/modals/LoadingModal";

interface LoadingIndicatorProps {
  loadingId: string;
}

export const LoadingIndicator = ({ loadingId }: LoadingIndicatorProps) => {
  return <LoadingModal id={loadingId} title="Cargando Dashboard" />;
};


============================================================
FILE_PATH: src\features\dashboard\components\sidebar\DashboardSidebar.tsx
============================================================
// components/custom/DashboardSidebar/DashboardSidebar.tsx
import {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
} from "@/components/ui/sidebar";
import { Button } from "@/components/ui/button";
import { LayoutDashboard, Plus, Settings } from "lucide-react";
import Link from "next/link";
import { useDashboardSidebar } from "./useDashboardSidebar";
import { SidebarPages } from "./SidebarPages";
import { DashboardSidebarModals } from "./DashboardSidebarModals";

export function DashboardSidebar() {
  const {
    status,
    pages,
    pageId,
    dashboardId,
    addPageId,
    editPageId,
    confirmDeleteId,
    confirmConnectionId,
    onAdd,
    onConfirmAdd,
    onDelete,
    onConfirmDelete,
    onEdit,
    onConfirmEdit,
    onSettings,
  } = useDashboardSidebar();

  return (
    <>
      <Sidebar className="select-none">
        <SidebarHeader>
          <Button asChild variant="outline" className="justify-center px-2">
            <Link href="/dashboard" className="w-full flex items-center gap-2">
              <LayoutDashboard className="size-5" />
              <span>Gallery</span>
            </Link>
          </Button>
        </SidebarHeader>

        <SidebarContent>
          <SidebarGroup>
            <SidebarGroupLabel className="text-lg h-10">
              Pages
            </SidebarGroupLabel>
            <SidebarGroupAction
              title="Add Page"
              className="size-8"
              onClick={onAdd}
            >
              <Plus className="size-4" />
              <span className="sr-only">Add Page</span>
            </SidebarGroupAction>
            <SidebarGroupContent>
              <SidebarPages
                pages={pages}
                status={status}
                pageId={pageId}
                dashboardId={dashboardId}
                onEdit={onEdit}
                onDelete={onDelete}
              />
            </SidebarGroupContent>
          </SidebarGroup>
        </SidebarContent>

        <SidebarFooter>
          <Button
            asChild
            variant="ghost"
            onClick={onSettings}
            className="w-full justify-start cursor-pointer px-2"
          >
            <div className="flex items-center gap-2">
              <Settings className="size-5" />
              <span>Settings</span>
            </div>
          </Button>
        </SidebarFooter>
      </Sidebar>

      <DashboardSidebarModals
        addPageId={addPageId}
        editPageId={editPageId}
        confirmDeleteId={confirmDeleteId}
        confirmConnectionId={confirmConnectionId}
        onConfirmAdd={onConfirmAdd}
        onConfirmEdit={onConfirmEdit}
        onConfirmDelete={onConfirmDelete}
      />
    </>
  );
}


============================================================
FILE_PATH: src\features\dashboard\components\sidebar\DashboardSidebarModals.tsx
============================================================
// components/custom/DashboardSidebar/DashboardSidebarModals.tsx
/* import { FormModal } from "@/components/custom/Modals/FormModal";
import { ConfirmModal } from "@/components/custom/Modals/ConfirmModal";
import { ConfigConnectionModal } from "@/components/custom/Modals/ConfigConnectionModal";
import { FieldConfig } from "@/components/custom/DynamicForm"; */
import { FieldConfig } from "@/components/shared/DynamicForm";
import { ConfirmModal } from "@/components/shared/modals/ConfirmModal";
import { FormModal } from "@/components/shared/modals/FormModal";
import { ConfigConnectionModal } from "@/features/editor/components/modals/ConfigConnectionModal";
import z from "zod";

const schema = z.object({
  name: z.string().min(4),
});

const fields: FieldConfig[] = [{ name: "name", label: "Nombre", type: "text" }];

interface DashboardSidebarModalsProps {
  addPageId: string;
  editPageId: string;
  confirmDeleteId: string;
  confirmConnectionId: string;
  onConfirmAdd: (data: Record<string, any>) => void;
  onConfirmEdit: (data: Record<string, string>) => void;
  onConfirmDelete: () => void;
}

export const DashboardSidebarModals: React.FC<DashboardSidebarModalsProps> = ({
  addPageId,
  editPageId,
  confirmDeleteId,
  confirmConnectionId,
  onConfirmAdd,
  onConfirmEdit,
  onConfirmDelete,
}) => {
  return (
    <>
      <FormModal
        className="gap-1"
        schema={schema}
        fields={fields}
        id={addPageId}
        title="Add Page"
        onSubmit={onConfirmAdd}
      />
      <FormModal
        className="gap-1"
        schema={schema}
        fields={fields}
        id={editPageId}
        title="Edit Page"
        onSubmit={onConfirmEdit}
      />
      <ConfirmModal
        onConfirm={onConfirmDelete}
        id={confirmDeleteId}
        description="Are you sure you want to delete this page?"
        title="Confirm Delete"
      />
      <ConfigConnectionModal
        id={confirmConnectionId}
        title="Config Connection"
        description="Set connection configuration"
      />
    </>
  );
};


============================================================
FILE_PATH: src\features\dashboard\components\sidebar\index.tsx
============================================================
export { DashboardSidebar } from "./DashboardSidebar";


============================================================
FILE_PATH: src\features\dashboard\components\sidebar\SidebarPages.tsx
============================================================
import { SidebarMenu, SidebarMenuItem } from "@/components/ui/sidebar";
import {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
} from "@/components/ui/dropdown-menu";
import { SidebarMenuButton, SidebarMenuAction } from "@/components/ui/sidebar";
import { MoreHorizontal, Pencil, Trash2 } from "lucide-react";
import Link from "next/link";
import { DynamicIcon, IconName } from "@/components/ui/dynamic-icon";

interface SidebarPagesProps {
  pages: any[];
  status: string;
  pageId: string | undefined;
  dashboardId: string;
  onEdit: (data: { id: string; name: string }) => void;
  onDelete: (data: { id: string }) => void;
}

export const SidebarPages: React.FC<SidebarPagesProps> = ({
  pages,
  status,
  pageId,
  dashboardId,
  onEdit,
  onDelete,
}) => {
  if (status === "loading") {
    return (
      <>
        {Array.from({ length: 3 }).map((_, i) => (
          <SidebarMenuItem key={i} className="px-2 py-2"></SidebarMenuItem>
        ))}
      </>
    );
  }

  return (
    <SidebarMenu>
      {pages?.map((item) => {
        const isActive = item.id === pageId;
        const href = `/dashboard/${dashboardId}/page/${item.id}`;

        return (
          <SidebarMenuItem key={item.id}>
            <SidebarMenuButton
              asChild
              isActive={isActive}
              className="select-none"
              tooltip={item.name}
            >
              <Link href={href}>
                <DynamicIcon name={item.icon as IconName} />
                <span className="truncate">{item.name}</span>
              </Link>
            </SidebarMenuButton>

            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <SidebarMenuAction showOnHover>
                  <MoreHorizontal />
                  <span className="sr-only">More</span>
                </SidebarMenuAction>
              </DropdownMenuTrigger>
              <DropdownMenuContent
                className="w-48 rounded-lg"
                side="right"
                align="start"
              >
                <DropdownMenuItem
                  onClick={() => onEdit({ id: item.id, name: item.name })}
                  className="cursor-pointer"
                >
                  <Pencil className="text-muted-foreground size-4 mr-2" />
                  <span>Rename Page</span>
                </DropdownMenuItem>
                <DropdownMenuItem
                  onClick={() => onDelete({ id: item.id })}
                  className="cursor-pointer text-destructive focus:text-destructive"
                >
                  <Trash2 className="size-4 mr-2" />
                  <span>Delete Page</span>
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </SidebarMenuItem>
        );
      })}
    </SidebarMenu>
  );
};


============================================================
FILE_PATH: src\features\dashboard\components\sidebar\useDashboardSidebar.tsx
============================================================
import { usePageStore } from "@/features/page/store/usePageStore";
import { useModalActions } from "@/hooks/useModal";
import { useParams, useRouter } from "next/navigation";
import { useCallback, useEffect, useId } from "react";
import { useUser } from "@/hooks/useUser";

export const useDashboardSidebar = () => {
  const router = useRouter();

  const params = useParams();
  const dashboardId = params.dashboardId as string;
  const pageId = params.pageId as string | undefined;
  const { fetchPages, status, pages, addPage, deletePage, renamePage } =
    usePageStore(pageId);
  const { openModal, closeModal, getModalData } = useModalActions();
  const addPageId = useId();
  const editPageId = useId();
  const confirmDeleteId = useId();
  const confirmConnectionId = useId();
  const user = useUser();

  // 1. Efectos
  useEffect(() => {
    if (!dashboardId) {
      router.replace("/dashboard");
    }
  }, [dashboardId, router]);

  useEffect(() => {
    if (status === "idle") {
      fetchPages(dashboardId);
    }
  }, [status]);

  const onAdd = useCallback(() => {
    openModal(addPageId);
  }, [openModal, addPageId]);

  const onConfirmAdd = useCallback(
    (data: Record<string, any>) => {
      addPage({
        name: data.name,
        icon: "LayoutDashboard",
        dashboardId,
        userId: user?.id,
      });
      closeModal(addPageId);
    },
    [addPage, dashboardId, user, closeModal, addPageId]
  );

  const onDelete = useCallback(
    (data: Record<string, any>) => {
      openModal(confirmDeleteId, data);
    },
    [openModal, confirmDeleteId]
  );

  const onConfirmDelete = useCallback(() => {
    const data = getModalData(confirmDeleteId);
    if (data?.id) {
      deletePage(data.id);
      router.replace(`/dashboard/${dashboardId}`);
    }
  }, [confirmDeleteId, getModalData, deletePage, router, dashboardId]);

  const onEdit = useCallback(
    (data: Record<string, any>) => {
      openModal(editPageId, data);
    },
    [openModal, editPageId]
  );

  const onConfirmEdit = useCallback(
    (newData: Record<string, string>) => {
      const data = getModalData(editPageId);
      if (data?.id) {
        renamePage(data.id, newData.name);
        closeModal(editPageId);
      }
    },
    [getModalData, editPageId, renamePage, closeModal]
  );

  const onSettings = useCallback(() => {
    openModal(confirmConnectionId);
  }, [openModal, confirmConnectionId]);

  return {
    status,
    pages,
    pageId,
    dashboardId,
    addPageId,
    editPageId,
    confirmDeleteId,
    confirmConnectionId,
    onAdd,
    onConfirmAdd,
    onDelete,
    onConfirmDelete,
    onEdit,
    onConfirmEdit,
    onSettings,
  };
};


============================================================
FILE_PATH: src\features\dashboard\hook\useDashboard.tsx
============================================================
import { useEffect, useId, useRef, useCallback } from "react";
import { useParams } from "next/navigation";
import { toast } from "sonner";

// Stores y Hooks
import { useDashboardActions } from "@/features/dashboard/store/useDashboard";
import { usePageStore } from "@/features/page/store/usePageStore"; // Asegúrate que la ruta sea correcta

// Tipos
import { useModalActions } from "@/hooks/useModal";
import { useEngine } from "@/features/engine";

export const useDashboard = () => {
  const params = useParams();
  const dashboardId = params?.dashboardId as string;
  const pageId = params?.pageId as string | undefined;

  const {
    dashboard: currentDashboard,
    status: dashboardStatus,
    refresh: fetchDashboards,
  } = useDashboardActions(dashboardId);

  const {
    status: pagesStatus,
    page: currentPage,
    updateSettings,
  } = usePageStore(pageId);

  // --- UTILS & REFS ---
  const { openModal, closeModal } = useModalActions();
  const { connect } = useEngine();
  /*   const { ConectionConfig } = useScriptConnectionActions(); */

  const loadingId = useId();
  const isModalOpenRef = useRef(false);
  const hasConnectedRef = useRef(false);

  useEffect(() => {
    if (dashboardStatus === "idle") {
      fetchDashboards();
    }
  }, [dashboardStatus, fetchDashboards]);

  useEffect(() => {
    const connectDatabase = async () => {
      if (
        currentDashboard?.config &&
        currentDashboard.config.type &&
        !hasConnectedRef.current
      ) {
        try {
          hasConnectedRef.current = true;
          await connect(currentDashboard.config as any);

          toast.success("Base de datos conectada", {
            description: `Proveedor: ${currentDashboard.config.type}`,
            duration: 3000,
          });
        } catch (error) {
          console.error("Connection error:", error);
          toast.error("Error de conexión", {
            description: "No se pudo conectar a la base de datos configurada.",
          });
          hasConnectedRef.current = false;
        }
      }
    };

    if (dashboardStatus === "succeeded") {
      connectDatabase();
    }
  }, [currentDashboard, dashboardStatus, connect]);

  useEffect(() => {
    const isLoading = dashboardStatus === "loading";

    if (isLoading && !isModalOpenRef.current) {
      openModal(loadingId, {
        message: "Sincronizando...",
        subMessage: "Obteniendo configuración y páginas",
      });
      isModalOpenRef.current = true;
    } else if (!isLoading && isModalOpenRef.current) {
      const timer = setTimeout(() => {
        closeModal(loadingId);
        isModalOpenRef.current = false;
      }, 300);
      return () => clearTimeout(timer);
    }
  }, [pagesStatus, dashboardStatus, openModal, closeModal, loadingId]);

  const handlePublicToggle = useCallback(
    async (checked: boolean) => {
      if (!currentPage || !updateSettings) return;

      try {
        await updateSettings({
          isPublic: checked,
        });

        toast.success(`Página ahora es ${checked ? "Pública" : "Privada"}`, {
          description: checked
            ? "Cualquiera con el enlace podrá verla."
            : "Solo tú puedes ver esta página.",
        });
      } catch (error) {
        toast.error("Error al actualizar privacidad");
        console.error("Toggle error:", error);
      }
    },
    [currentPage, updateSettings]
  );

  const handleOpenView = useCallback(() => {
    if (!currentPage) return;
    window.open(`/view/${currentPage.id}`, "_blank");
  }, [currentPage]);

  const handleOpenSettings = useCallback(() => {
    openModal("213123123_editor_modal");
  }, [openModal]);

  return {
    loadingId,
    currentPage,
    currentDashboard,
    isLoading: dashboardStatus === "loading",
    handlePublicToggle,
    handleOpenView,
    handleOpenSettings,
  };
};


============================================================
FILE_PATH: src\features\dashboard\hook\useDashboardGallery.tsx
============================================================
import { useSignOut, useUser } from "@/hooks/useUser";
import { useRouter } from "next/navigation";
import { ChangeEvent, useEffect, useId } from "react";
import { useModalActions, useModalData } from "@/hooks/useModal";
import { useSearch } from "@/hooks/useSearch";
import { useDashboardActions } from "../store/useDashboard";

export const useDashboardGallery = () => {
  const router = useRouter();
  const editFormId = useId();
  const confirmId = useId();
  const addFormId = useId();
  const loadingModalId = useId();
  const { openModal, closeModal, getModalData } = useModalActions();

  const user = useUser();
  const signOut = useSignOut();

  const {
    dashboards,
    addDashboard,
    deleteDashboard,
    renameDashboard,
    isLoading,
    refresh,
  } = useDashboardActions();

  useEffect(() => {
    if (user) {
      refresh();
    }
  }, [user, refresh]);

  useEffect(() => {
    if (isLoading) {
      openModal(loadingModalId, {
        message: "Cargando galería...",
        subMessage: "Obteniendo tus dashboards desde la nube.",
      });
    } else {
      const timeout = setTimeout(() => {
        closeModal(loadingModalId);
      }, 300);
      return () => clearTimeout(timeout);
    }
  }, [isLoading, closeModal, openModal, loadingModalId]);

  const { query, setQuery, results } = useSearch(dashboards, (item, value) => {
    return item.name.toLowerCase().includes(value.toLowerCase());
  });

  const onChange = (e: ChangeEvent<HTMLInputElement>) =>
    setQuery(e.target.value);

  const onAdd = () => {
    openModal(addFormId);
  };

  const onConfirm = (data: Record<string, string>) => {
    closeModal(addFormId);
    setQuery("");
    if (!user) return;
    addDashboard(data["name"]);
  };

  const onClick = (id: string) => {
    router.replace(`/dashboard/${id}`);
  };

  const onDelete = (id: string) => {
    openModal(confirmId, { id });
  };

  const onConfirmDelete = () => {
    const data = getModalData(confirmId);
    deleteDashboard(data.id);
  };

  const onEdit = (id: string) => {
    openModal(editFormId, { id });
  };

  const onConfirmEdit = ({ name }: { name: string }) => {
    const data = getModalData(editFormId);
    renameDashboard(data.id, name);
    closeModal(editFormId);
  };

  const onSignOut = async () => {
    router.replace("/login");
    await signOut();
  };

  return {
    results,
    query,
    onChange,
    onAdd,
    onConfirm,
    onClick,
    onDelete,
    onConfirmDelete,
    onEdit,
    onConfirmEdit,
    onSignOut,
    addFormId,
    editFormId,
    confirmId,
    loadingModalId,
  };
};


============================================================
FILE_PATH: src\features\dashboard\store\dashboard.store.ts
============================================================
import { create } from "zustand";
import { systemSupabase } from "@/lib/supabase/client";
import { Dashboard } from "../types/dashboard.types";

interface DashboardState {
  dashboards: Record<string, Dashboard>;
  status: "idle" | "loading" | "succeeded" | "failed";
  error: string | null;
  fetchDashboards: () => Promise<void>;
  getDashboardById: (id: string) => Dashboard | undefined;
  addDashboard: (name: string, userId: string) => Promise<void>;
  deleteDashboard: (id: string) => Promise<void>;
  renameDashboard: (id: string, newName: string) => Promise<void>;
  updateDashboard: (id: string, updates: Partial<Dashboard>) => Promise<void>;
}

const DBtoStore = (item: any): Dashboard => {
  return {
    id: item.id,
    name: item.name,
    config: item.config,
    configScript: item.config_script,
  };
};

const StoreToDB = (item: Partial<Dashboard>) => {
  const dbEntry = {
    id: item.id, // Si es undefined, lo filtraremos abajo
    name: item.name,
    config: item.config,
    config_script: item.configScript,
    updated_at: new Date().toISOString(), // Buena práctica
  };

  return Object.fromEntries(
    Object.entries(dbEntry).filter(([_, v]) => v != null)
  );
};

export const useDashboardStore = create<DashboardState>((set, get) => ({
  dashboards: {},
  status: "idle",
  error: null,

  fetchDashboards: async () => {
    set({ status: "loading" });
    try {
      const { data, error } = await systemSupabase
        .from("dashboards")
        .select("*");
      if (error) throw error;

      const newData = (data || []).map((item) => DBtoStore(item));
      const dashboardMap = newData.reduce((acc, curr) => {
        acc[curr.id] = curr;
        return acc;
      }, {} as Record<string, Dashboard>);

      set({ dashboards: dashboardMap, status: "succeeded" });
    } catch (err: any) {
      set({ status: "failed", error: err.message });
    }
  },

  getDashboardById: (id) => get().dashboards[id],

  addDashboard: async (name, userId) => {
    const { data, error } = await systemSupabase
      .from("dashboards")
      .insert({
        name,
        user_id: userId,
        config: {},
        config_script: "",
      })
      .select()
      .single();
    if (error) throw error;

    set((state) => ({
      dashboards: { ...state.dashboards, [data.id]: data },
    }));
  },

  deleteDashboard: async (id) => {
    set((state) => {
      const newDashboards = { ...state.dashboards };
      delete newDashboards[id];
      return { dashboards: newDashboards };
    });
    await systemSupabase.from("dashboards").delete().eq("id", id);
  },

  renameDashboard: async (id, name) => {
    set((state) => ({
      dashboards: {
        ...state.dashboards,
        [id]: { ...state.dashboards[id], name },
      },
    }));

    await systemSupabase.from("dashboards").update({ name }).eq("id", id);
  },
  updateDashboard: async (id, updates) => {
    set((state) => ({
      dashboards: {
        ...state.dashboards,
        [id]: { ...state.dashboards[id], ...updates },
      },
    }));

    const { error } = await systemSupabase
      .from("dashboards")
      .update(StoreToDB(updates))
      .eq("id", id);

    if (error) {
      console.error("Error updating dashboard:", error);
    }
  },
}));


============================================================
FILE_PATH: src\features\dashboard\store\useDashboard.ts
============================================================
import { useMemo, useCallback } from "react";
import { useParams } from "next/navigation";
import { useUser } from "@/hooks/useUser";
import { Dashboard } from "../types/dashboard.types";
import { useDashboardStore } from "./dashboard.store";
import { useShallow } from "zustand/react/shallow";

export const useDashboardActions = (id?: string) => {
  const user = useUser();
  const params = useParams();

  const dashboardId =
    id ??
    (typeof params?.dashboardId === "string" ? params.dashboardId : undefined);

  // 🔹 UNA sola suscripción a Zustand
  const {
    dashboards,
    status,
    error,
    addDashboard,
    deleteDashboard,
    updateDashboard,
    fetchDashboards,
  } = useDashboardStore(
    useShallow((s) => ({
      dashboards: s.dashboards,
      status: s.status,
      error: s.error,
      addDashboard: s.addDashboard,
      deleteDashboard: s.deleteDashboard,
      updateDashboard: s.updateDashboard,
      fetchDashboards: s.fetchDashboards,
    }))
  );

  // 🔹 Lista
  const dashboardList = useMemo(() => Object.values(dashboards), [dashboards]);

  // 🔹 Actual
  const currentDashboard = dashboardId ? dashboards[dashboardId] : undefined;

  const requireDashboard = useCallback(() => {
    if (!dashboardId) {
      console.error("No hay dashboard seleccionado");
      return false;
    }
    return true;
  }, [dashboardId]);

  return {
    // Estado
    status,
    error,
    isLoading: status === "idle" || status === "loading",
    dashboards: dashboardList,
    dashboard: currentDashboard,

    // Acciones
    refresh: fetchDashboards,

    addDashboard: async (name: string) => {
      if (!user?.id) {
        console.warn("Intento de crear dashboard sin usuario autenticado");
        return;
      }
      await addDashboard(name, user.id);
    },

    deleteDashboard,

    updateDashboard: async (targetId: string, updates: Partial<Dashboard>) => {
      await updateDashboard(targetId, updates);
    },

    renameDashboard: (targetId: string, name: string) =>
      updateDashboard(targetId, { name }),

    setConfig: (config: Record<string, any>) => {
      if (requireDashboard()) {
        updateDashboard(dashboardId!, { config });
      }
    },

    setConfigScript: (script: string) => {
      if (requireDashboard()) {
        updateDashboard(dashboardId!, { configScript: script });
      }
    },
  };
};


============================================================
FILE_PATH: src\features\dashboard\types\dashboard.types.ts
============================================================
import { FieldConfig } from "@/components/shared/DynamicForm";
import z from "zod";

export interface DatabaseConfig {
  type: string;
  url: string;
  key: string;
}

export interface LoadingState {
  pages: "idle" | "loading" | "succeeded" | "failed";
  dashboards: "idle" | "loading" | "succeeded" | "failed";
}

export interface DashboardHeaderProps {
  currentPage?: {
    id: string;
    isPublic?: boolean;
  } | null;
  onPublicToggle: (checked: boolean) => void;
  onOpenView: () => void;
  onSettings: () => void;
}

export interface ConnectionState {
  hasConnected: boolean;
  isModalOpen: boolean;
}
export interface Dashboard {
  id: string;
  name: string;
  config: Record<string, any>;
  configScript: string;
}

export interface DashboardCardProps {
  name: string;
  onClick?: () => void;
  onEdit?: () => void;
  onDelete?: () => void;
}

export interface DashboardCardData {
  id: string;
  name: string;
}

export interface GalleryModals {
  addFormId: string;
  editFormId: string;
  confirmId: string;
  loadingModalId: string;
}

export interface GalleryHandlers {
  query: string;
  results: DashboardCardData[];
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onClick: (dashboardId: string) => void;
  onAdd: () => void;
  onDelete: (dashboardId: string) => void;
  onConfirmDelete: () => void;
  onConfirm: (data: { name: string }) => void;
  onEdit: (dashboardId: string) => void;
  onConfirmEdit: (data: { name: string }) => void;
  onSignOut: () => void;
}

export const DASHBOARD_SCHEMA = z.object({
  name: z.string().min(4, "El nombre debe tener al menos 4 caracteres"),
});

export const DASHBOARD_FIELDS: FieldConfig[] = [
  {
    name: "name",
    label: "Nombre",
    type: "text",
    placeholder: "Ingresa el nombre del dashboard",
  },
];


============================================================
FILE_PATH: src\features\editor\components\editor\ComponentEditor.tsx
============================================================
"use client";
import { ButtonGroup } from "@/components/ui/button-group";
import { useCallback, useEffect, useRef, useState } from "react";
import { useCodeDefinitions } from "../../hooks/useCodeDefinitions";
import { Button } from "@/components/ui/button";
import { Loader2, Save } from "lucide-react";
import { DynamicComponent, useEditor, useEngine } from "@/features/engine";
import { Tap } from "./Tap";
import { TabContainer } from "./TabContainer";
import { ScriptEditor } from "./ScriptEditor";
import { IEngine } from "@/features/engine/modules";

interface ScriptEditorProps {
  initialSql?: string;
  initialScript?: string;
  onChangeJs?: (value: string) => void;
  onChangeSql?: (value: string) => void;
  onSave?: () => void;
  isSaving?: boolean;
}

export const ComponentEditor = ({
  onChangeJs,
  onChangeSql,
  onSave,
  isSaving,
}: ScriptEditorProps) => {
  const {
    sqlCode,
    addExecutionLogs,
    setJsCode,
    setSqlCode,
    jsCode,
    clearConsole,
    logs,
  } = useEditor();

  const { createEngine, runScript } = useEngine();

  const [uiState, setUiState] = useState({
    showEditor: true,
    showPreview: true,
  });

  const [liveComponent, setLiveComponent] = useState<any>(null);
  const hasRunInitialScript = useRef(false);
  const [engine, setEngine] = useState<IEngine | null>(null);

  // Generamos definiciones para Monaco
  const { definitions } = useCodeDefinitions({ sqlCode, engine });

  // 1. Inicialización del Engine (Solo una vez al montar)
  useEffect(() => {
    const _engine = createEngine();
    // eslint-disable-next-line react-hooks/set-state-in-effect
    setEngine(_engine);
  }, [createEngine]);

  // 2. Función de ejecución (Memorizada para evitar recreación)
  const onExecuteScript = useCallback(async () => {
    // Si no hay engine, no podemos hacer nada
    if (!engine) return;

    try {
      const response = await runScript(jsCode, sqlCode, engine);
      setLiveComponent(response.result);
    } catch (error: any) {
      setLiveComponent(null);
      addExecutionLogs([{ message: "Error crítico:", data: error.message }]);
    }
  }, [engine, jsCode, sqlCode, runScript, addExecutionLogs]);

  // 3. Ejecución inicial automática (CORREGIDO)
  useEffect(() => {
    if (engine && jsCode && !hasRunInitialScript.current) {
      // eslint-disable-next-line react-hooks/set-state-in-effect
      onExecuteScript();
      hasRunInitialScript.current = true;
    }
  }, [engine, jsCode, onExecuteScript]);

  // Handlers optimizados
  const handleChangeJs = useCallback(
    (v: string | undefined) => {
      const val = v || "";
      onChangeJs?.(val);
      setJsCode(val);
    },
    [onChangeJs, setJsCode]
  );

  const handleChangeSql = useCallback(
    (v: string | undefined) => {
      const val = v || "";
      onChangeSql?.(val);
      setSqlCode(val);
    },
    [onChangeSql, setSqlCode]
  );

  const handleOnSave = useCallback(() => {
    onExecuteScript();
    onSave?.();
  }, [onExecuteScript, onSave]);

  const onTab = (name: string) => {
    setUiState((prev) => {
      if (name === "Script") {
        // Toggle inteligente: Si solo hay preview, al hacer click en Script, mostramos ambos o switch
        if (!prev.showEditor && prev.showPreview) {
          return { ...prev, showEditor: true };
        }
        return { ...prev, showEditor: !prev.showEditor };
      }
      if (name === "Preview") {
        if (prev.showEditor && !prev.showPreview) {
          return { ...prev, showPreview: true };
        }
        return { ...prev, showPreview: !prev.showPreview };
      }
      return prev;
    });
  };

  return (
    // CAMBIO IMPORTANTE: h-full y min-h-0 para evitar desbordes
    <div className="w-full h-full flex flex-col overflow-hidden">
      {/* Header fijo */}
      <div className="flex-none h-12 flex gap-3 mb-2">
        <ButtonGroup>
          <Tap
            name="Script"
            onClick={() => onTab("Script")}
            active={uiState.showEditor}
          />
          <Tap
            name="Preview"
            onClick={() => onTab("Preview")}
            active={uiState.showPreview}
          />
        </ButtonGroup>
        <Button variant="outline" onClick={handleOnSave} disabled={isSaving}>
          {isSaving ? (
            <Loader2 className="size-5 animate-spin" />
          ) : (
            <Save className="size-5" />
          )}
        </Button>
      </div>

      {/* Contenedor de paneles: flex-1 ocupa el resto, min-h-0 habilita el scroll interno */}
      <div className="flex-1 w-full flex min-h-0 overflow-hidden gap-4">
        <TabContainer show={uiState.showEditor}>
          {engine && definitions.length > 0 && (
            <ScriptEditor
              sqlValue={sqlCode}
              onChangeSql={handleChangeSql}
              jsValue={jsCode}
              onChangeJs={handleChangeJs}
              logs={logs}
              onClean={clearConsole}
              onPlay={onExecuteScript}
              onSave={handleOnSave}
              definitions={definitions}
            />
          )}
        </TabContainer>

        <TabContainer show={uiState.showPreview}>
          <div className="h-full w-full overflow-auto bg-background/50 rounded-md border border-border">
            <DynamicComponent data={liveComponent} engine={engine} />
          </div>
        </TabContainer>
      </div>
    </div>
  );
};


============================================================
FILE_PATH: src\features\editor\components\editor\Console.tsx
============================================================
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  ChevronDown,
  ChevronRight,
  Copy,
  Check,
  Search,
  ArrowDownToLine,
  Ban,
} from "lucide-react";
import { useEffect, useRef, useState, useMemo } from "react";
import { cn } from "@/lib/utils"; // Asegúrate de tener esta utilidad de shadcn, si no, usa template strings

// Interfaces
export interface ILog {
  message: string;
  data?: any;
  type?: "info" | "error" | "success" | "warning"; // Nuevo campo opcional
  timestamp?: number;
}

// Sub-componente para visualizar JSON con botón de copiar
const JsonViewer = ({ data }: { data: any }) => {
  const [copied, setCopied] = useState(false);

  const handleCopy = () => {
    navigator.clipboard.writeText(JSON.stringify(data, null, 2));
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  return (
    <div className="relative group mt-1">
      <div className="absolute right-2 top-2 opacity-0 group-hover:opacity-100 transition-opacity">
        <Button
          variant="ghost"
          size="icon"
          className="h-6 w-6 bg-muted/50 hover:bg-muted"
          onClick={handleCopy}
        >
          {copied ? (
            <Check className="w-3 h-3 text-green-500" />
          ) : (
            <Copy className="w-3 h-3" />
          )}
        </Button>
      </div>
      <pre className="text-[10px] leading-tight text-muted-foreground bg-black/20 p-2 rounded-md overflow-x-auto border border-border/30">
        {JSON.stringify(data, null, 2)}
      </pre>
    </div>
  );
};

// Componente de fila individual memoizado
const LogItem = ({ log }: { log: ILog }) => {
  const [isExpanded, setIsExpanded] = useState(true);

  // Determinar color basado en el mensaje o tipo
  const getLogStyle = () => {
    const msg = log.message.toLowerCase();
    if (log.type === "error" || msg.includes("error") || msg.includes("fail"))
      return "text-red-400 border-l-2 border-red-500 bg-red-500/5";
    if (
      log.type === "success" ||
      msg.includes("success") ||
      msg.includes("done")
    )
      return "text-green-400 border-l-2 border-green-500 bg-green-500/5";
    if (log.type === "warning" || msg.includes("warn"))
      return "text-yellow-400 border-l-2 border-yellow-500 bg-yellow-500/5";
    return "text-blue-300 border-l-2 border-transparent hover:bg-white/5";
  };

  // Normalizar data a array
  const dataItems = useMemo(() => {
    if (!log.data) return [];
    const d = Array.isArray(log.data) ? log.data : [log.data];
    return d.filter(Boolean); // Eliminar nulls/undefined
  }, [log.data]);

  const hasData = dataItems.length > 0;
  const time = log.timestamp
    ? new Date(log.timestamp).toLocaleTimeString()
    : new Date().toLocaleTimeString();

  return (
    <div
      className={cn(
        "py-1 px-2 mb-[1px] text-xs font-mono transition-colors",
        getLogStyle()
      )}
    >
      <div className="flex items-start gap-2">
        <span className="text-gray-600 select-none shrink-0 text-[10px] mt-[2px]">
          {time}
        </span>

        <div className="flex-1 min-w-0">
          <div
            className="flex items-center gap-1 cursor-pointer group"
            onClick={() => hasData && setIsExpanded(!isExpanded)}
          >
            {hasData && (
              <span className="text-muted-foreground">
                {isExpanded ? (
                  <ChevronDown className="w-3 h-3" />
                ) : (
                  <ChevronRight className="w-3 h-3" />
                )}
              </span>
            )}
            <span className="font-semibold break-all">
              {log.message || "Log entry"}
            </span>
          </div>

          {isExpanded && hasData && (
            <div className="pl-4 mt-1 space-y-2">
              {dataItems.map((item, idx) => (
                <JsonViewer key={idx} data={item} />
              ))}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export const Console = ({
  logs = [],
  onClean,
}: {
  logs?: ILog[];
  onClean?: () => void;
}) => {
  const [searchTerm, setSearchTerm] = useState("");
  const [autoScroll, setAutoScroll] = useState(true);
  const endRef = useRef<HTMLDivElement>(null);

  const filteredLogs = useMemo(() => {
    if (!searchTerm) return logs;
    return logs.filter(
      (l) =>
        l.message.toLowerCase().includes(searchTerm.toLowerCase()) ||
        JSON.stringify(l.data).toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [logs, searchTerm]);

  // Auto-scroll effect
  useEffect(() => {
    if (autoScroll && endRef.current) {
      // Un pequeño timeout ayuda a que el ScrollArea recalcule la altura antes de hacer scroll
      setTimeout(() => {
        endRef.current?.scrollIntoView({ behavior: "smooth", block: "end" });
      }, 100);
    }
  }, [logs, autoScroll, filteredLogs.length]);

  return (
    <div className="h-full min-h-0 flex flex-col  bg-[#0c0c0c] border-t border-border overflow-hidden rounded-b-lg">
      {/* Toolbar */}
      <div className="flex justify-between items-center px-2 py-1.5 bg-muted/40 border-b border-border gap-2">
        <div className="flex items-center gap-2 flex-1 max-w-sm">
          <div className="relative w-full">
            <Search className="absolute left-2 top-1/2 -translate-y-1/2 w-3 h-3 text-muted-foreground" />
            <Input
              className="h-7 text-xs pl-7 bg-black/20 border-border/50 focus-visible:ring-1 focus-visible:ring-offset-0"
              placeholder="Filter logs..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
            />
          </div>
        </div>

        <div className="flex items-center gap-1">
          <Button
            variant={autoScroll ? "default" : "ghost"}
            size="icon"
            className={cn(
              "h-6 w-6",
              autoScroll && "bg-blue-600 hover:bg-blue-700"
            )}
            onClick={() => setAutoScroll(!autoScroll)}
            title="Toggle Auto-scroll"
          >
            <ArrowDownToLine className="w-3 h-3" />
          </Button>
          <Button
            variant="ghost"
            size="icon"
            className="h-6 w-6 hover:bg-red-900/20 hover:text-red-400"
            onClick={onClean}
            title="Clear Console"
          >
            <Ban className="w-3 h-3" />
          </Button>
        </div>
      </div>

      {/* 2. Reemplazamos el div con overflow nativo por ScrollArea */}
      <ScrollArea className="flex-1 bg-black/10 max-h-[94%]">
        <div className="p-2 flex flex-col min-h-full">
          {filteredLogs.length === 0 ? (
            <div className="flex-1 flex flex-col items-center justify-center text-muted-foreground/40 italic text-xs gap-2 py-10">
              <span>Waiting for output...</span>
            </div>
          ) : (
            <div className="flex flex-col">
              {filteredLogs.map((log, index) => (
                <LogItem key={index} log={log} />
              ))}
              <div ref={endRef} className="h-px w-full" />
            </div>
          )}
        </div>
      </ScrollArea>
    </div>
  );
};


============================================================
FILE_PATH: src\features\editor\components\editor\ScriptEditor.tsx
============================================================
import { Button } from "@/components/ui/button";
import { ButtonGroup } from "@/components/ui/button-group";
import { Editor, OnMount } from "@monaco-editor/react";
import { Console, ILog } from "./Console";
import { useEffect, useState } from "react";
import { Play } from "lucide-react";
import {
  useMonacoTypings,
  TypeDefinition,
} from "@/features/editor/hooks/useMonacoTypings";

export interface CustomEditorProps {
  onPlay?: () => void;
  logs?: ILog[];
  onClean?: () => void;
  onlyJs?: boolean;
  onMount?: OnMount;
  jsValue?: string;
  onChangeJs?: (value?: string) => void;
  sqlValue?: string;
  onChangeSql?: (value?: string) => void;
  disableConsole?: boolean;
  onSave?: () => void;
  globalDefinitions?: string;
  alwaysOpenConsole?: boolean;
  definitions?: TypeDefinition[];
}

export const ScriptEditor = ({
  onPlay,
  logs,
  onClean,
  onlyJs,
  disableConsole,
  jsValue,
  onChangeJs,
  onChangeSql,
  sqlValue,
  onSave,
  alwaysOpenConsole,
  definitions = [],
}: CustomEditorProps) => {
  const { handleEditorDidMount } = useMonacoTypings({ definitions });

  const [isJs, setIsJs] = useState(true);
  const [openConsole, setOpenConsole] = useState(false);

  const onTab = (name: string) => {
    if (name == "js") setIsJs(true);
    else setIsJs(false);
  };

  const onToggleConsole = () => {
    setOpenConsole(!openConsole);
  };

  const editorOptions = {
    minimap: { enabled: false },
    fontSize: 15,
    padding: { top: 10 },
    automaticLayout: true,
    scrollBeyondLastLine: false,
  };

  const handleOnPlay = () => {
    onPlay?.();
  };

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Verifica si se presiona Ctrl (Win/Linux) o Meta (Mac) junto con la tecla 's'
      if ((e.ctrlKey || e.metaKey) && (e.key === "s" || e.key === "S")) {
        e.preventDefault(); // 🛑 Importante: Bloquea el "Guardar página" del navegador

        if (onSave) {
          onSave();
        }
      }
    };

    // Agregamos el listener a la ventana global
    window.addEventListener("keydown", handleKeyDown);

    // Limpiamos el listener cuando el componente se desmonta
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, [onSave]); // Se vuelve a crear si la función onSave cambia
  const showHeader = !(onlyJs && disableConsole);
  return (
    // CAMBIO 1: Usamos flex flex-col en lugar de grid. h-full es crítico.
    <div className="flex flex-col h-full w-full rounded-lg overflow-hidden bg-background">
      {/* Header: Usamos flex-none para que no se encoja ni crezca */}
      {showHeader && (
        <div className="flex-none h-[45px] w-full bg-accent flex gap-3 items-center px-3 border-b border-border">
          {!onlyJs && (
            <ButtonGroup>
              <Button
                className="h-8 transition-none duration-0"
                variant={isJs ? "default" : "outline"}
                onClick={() => onTab("js")}
              >
                JS
              </Button>
              <Button
                className="h-8 transition-none duration-0"
                variant={!isJs ? "default" : "outline"}
                onClick={() => onTab("sql")}
              >
                SQL
              </Button>
            </ButtonGroup>
          )}

          {!disableConsole && (
            <>
              {!alwaysOpenConsole && (
                <Button
                  className="h-8 transition-none duration-0"
                  variant={openConsole ? "default" : "outline"}
                  onClick={onToggleConsole}
                >
                  Console
                </Button>
              )}

              <Button
                className="h-8 transition-none duration-0"
                variant="outline"
                onClick={handleOnPlay}
              >
                <Play />
              </Button>
            </>
          )}
        </div>
      )}

      <div className="flex-1 min-h-0 flex w-full overflow-hidden">
        {(!openConsole || alwaysOpenConsole) && (
          <div className="flex-1 min-w-0 h-full relative">
            {isJs || onlyJs ? (
              <Editor
                key={"js"}
                theme="vs-dark"
                onMount={handleEditorDidMount}
                value={jsValue}
                onChange={onChangeJs}
                language="javascript"
                options={editorOptions}
                className="absolute inset-0" // Forzamos al editor a llenar su contenedor
              />
            ) : (
              <Editor
                key={"sql"}
                theme="vs-dark"
                language="sql"
                value={sqlValue}
                onChange={onChangeSql}
                options={editorOptions}
                className="absolute inset-0"
              />
            )}
          </div>
        )}

        {(openConsole || alwaysOpenConsole) && (
          <div className="flex-1 min-w-0 h-full border-l border-border relative">
            {/* El Console ahora vivirá dentro de este contenedor flex estrictamente */}
            <div className="absolute inset-0">
              <Console logs={logs} onClean={onClean} />
            </div>
          </div>
        )}
      </div>
    </div>
  );
};


============================================================
FILE_PATH: src\features\editor\components\editor\TabContainer.tsx
============================================================
import { ReactNode } from "react";

export const TabContainer = ({
  show,
  children,
}: {
  show?: boolean;
  children?: ReactNode;
}) => {
  // Si no se debe mostrar, no renderizamos nada (más limpio que el Fragment)
  if (!show) return null;

  return (
    <div className="flex-1 h-full min-w-0 rounded-lg overflow-hidden border border-border bg-background relative transition-all">
      {children}
    </div>
  );
};


============================================================
FILE_PATH: src\features\editor\components\editor\Tap.tsx
============================================================
import { Button } from "@/components/ui/button";

export const Tap = ({
  onClick,
  name,
  active,
}: {
  onClick?: (name: string) => void;
  name: string;
  active?: boolean;
}) => {
  const onClickTab = () => {
    onClick?.(name);
  };
  return (
    <Button
      variant={active ? "default" : "outline"}
      onClick={onClickTab}
      className="uppercase min-w-20 transition-none duration-0"
    >
      {name}
    </Button>
  );
};


============================================================
FILE_PATH: src\features\editor\components\modals\ConfigConnectionModal.tsx
============================================================
import { Modal, ModalProps } from "@/components/shared/Modal";
import { useDashboardActions } from "@/features/dashboard/store/useDashboard";
import { useEditor, useEngine } from "@/features/engine";
import { useIsModalOpen } from "@/hooks/useModal";
import { useEffect, useState } from "react";
import { ScriptEditor } from "../editor/ScriptEditor";
import { IEngine } from "@/features/engine/modules";
import { useCodeDefinitions } from "../../hooks/useCodeDefinitions";

type ConfigConnectionModalProps = ModalProps & {};

export const ConfigConnectionModal = (props: ConfigConnectionModalProps) => {
  const { jsCode, setJsCode, clearConsole, logs } = useEditor();
  const { setConfigScript, dashboard } = useDashboardActions();
  const isOpen = useIsModalOpen(props.id);

  const { createEngine, runScript } = useEngine();

  const [engine, setEngine] = useState<IEngine | null>(null);

  useEffect(() => {
    // eslint-disable-next-line react-hooks/set-state-in-effect
    setEngine(createEngine({ include: ["Connect"] }));
  }, []);

  const { definitions } = useCodeDefinitions({ engine });

  const onConnect = async () => {
    if (!jsCode) return;
    if (engine) {
      await runScript(jsCode, "", engine);
    }
    setConfigScript(jsCode);
  };

  const handleChangeJs = (v) => {
    setJsCode(v || "");
  };

  const onClean = () => {
    clearConsole();
  };

  useEffect(() => {
    if (isOpen) {
      setJsCode(dashboard?.configScript ?? "");
    } else {
      onClean();
    }
  }, [isOpen, dashboard]);

  return (
    <Modal
      {...props}
      className="min-w-[80vw] min-h-[70vh] grid grid-rows-[10px_auto_1fr]"
      disableEscape
      disableOutside
    >
      <div className="w-full h-full grid grid-rows-[1fr] gap-2">
        <ScriptEditor
          onChangeJs={handleChangeJs}
          jsValue={jsCode ?? ""}
          onSave={onConnect}
          definitions={definitions}
          onPlay={onConnect}
          logs={logs}
          onlyJs
          alwaysOpenConsole
          onClean={onClean}
        />
      </div>
    </Modal>
  );
};


============================================================
FILE_PATH: src\features\editor\components\modals\CreateComponentModal.tsx
============================================================
import { ComponentEditor } from "../editor/ComponentEditor";
import { Modal, ModalProps } from "@/components/shared/Modal";
import { useEditor } from "@/features/engine";

type CreateComponentModalProps = Omit<ModalProps, "title"> & {
  isSaving?: boolean;
  onSave?: () => void;
};

export const ComponentEditorModal = (props: CreateComponentModalProps) => {
  const { clearConsole } = useEditor();

  /*   const onSave = () => {
    savePage(jsCode, sqlCode);
  };
 */
  const onClose = () => {
    props.onClose?.();
    clearConsole();
  };

  return (
    <Modal
      {...props}
      onClose={onClose}
      disableEscape
      disableOutside
      title="Create Component"
      className="min-w-[95%] min-h-[95%] max-h-[85%] grid grid-rows-[35px_1fr] gap-0"
    >
      <ComponentEditor
        /*         initialSql={sqlCode}
        initialScript={jsCode} */
        /*         onChangeJs={setJsTemp} // Asumiendo que ComponentEditor usa onChangeJs
        onChangeSql={setSqlTemp} // Asumiendo que ComponentEditor usa onChangeSql */
        onSave={props.onSave}
        isSaving={props.isSaving}
      />
    </Modal>
  );
};


============================================================
FILE_PATH: src\features\editor\hooks\useCodeDefinitions.ts
============================================================
import { useMemo } from "react";
import { TypeBuilder } from "../lib/monaco/TypeBuilder";
import { IEngine } from "@/features/engine/modules";

// Definimos la interfaz de lo que devuelve para evitar 'any'
interface IMonacoDefinition {
  path: string;
  content: string;
}

export const useCodeDefinitions = ({
  sqlCode,
  engine,
}: {
  sqlCode?: string;
  engine?: IEngine | null;
}) => {
  const definitions = useMemo(() => {
    const defs: IMonacoDefinition[] = [];

    // 1. Engine Context (Globales)
    if (engine) {
      const globalBuilder = new TypeBuilder();

      // Asumo que ModulesDefinition es compatible con addCustom
      globalBuilder.addCustom(engine.ModulesDefinition);

      defs.push({
        // Recomendación: Usa prefijos de archivo para evitar colisiones en Monaco
        path: "file:///globals.d.ts",
        content: globalBuilder.build(),
      });

      // ❌ ELIMINADO: return defs;
      // Queremos que el código siga fluyendo hacia abajo
    }

    // 2. SQL Context (Dinámico)
    if (sqlCode) {
      const sqlBuilder = new TypeBuilder(); // Instancia separada o encadenada según tu clase
      sqlBuilder.addSqlQueries(sqlCode);

      defs.push({
        path: "file:///sql-generated.d.ts",
        content: sqlBuilder.build(),
      });
    }

    // 3. Retorno final con todo acumulado
    return defs;
  }, [sqlCode, engine]);

  return { definitions };
};


============================================================
FILE_PATH: src\features\editor\hooks\useMonacoTypings.ts
============================================================
import { Monaco } from "@monaco-editor/react";
import { useEffect, useRef } from "react";

export interface TypeDefinition {
  path: string;
  content: string;
}

interface UseMonacoTypingsProps {
  definitions: TypeDefinition[];
  compilerOptions?: any;
}

export const useMonacoTypings = ({
  definitions,
  compilerOptions,
}: UseMonacoTypingsProps) => {
  const monacoRef = useRef<Monaco | null>(null);
  // Guardamos las funciones de limpieza (dispose) aquí
  const disposablesRef = useRef<any[]>([]);

  const initCompiler = (monaco: Monaco) => {
    const defaults = monaco.languages.typescript.javascriptDefaults;
    defaults.setCompilerOptions({
      target: monaco.languages.typescript.ScriptTarget.ES2020, // ESNext a veces es inestable, 2020 es seguro
      allowNonTsExtensions: true,
      moduleResolution: monaco.languages.typescript.ModuleResolutionKind.NodeJs,
      allowJs: true,
      checkJs: true, // Esto habilita el intellisense fuerte en JS
      noLib: false,
      ...compilerOptions,
    });
  };

  const updateLibs = () => {
    if (!monacoRef.current) return;
    const defaults = monacoRef.current.languages.typescript.javascriptDefaults;

    // 1. LIMPIEZA: Eliminamos las definiciones anteriores para evitar duplicados o residuos
    disposablesRef.current.forEach((d) => d.dispose());
    disposablesRef.current = [];

    // 2. INYECCIÓN
    definitions.forEach((def) => {
      // Normalizamos la URI. Monaco prefiere 'file:///' para simular sistema de archivos
      const uriString = def.path.startsWith("file:///")
        ? def.path
        : `file:///${def.path.replace("ts:filename/", "")}`; // Limpieza por si acaso

      const uri = monacoRef.current!.Uri.parse(uriString);

      // Añadimos la librería y guardamos el disposable
      const disposable = defaults.addExtraLib(def.content, uri.toString());
      disposablesRef.current.push(disposable);
    });
  };

  const handleEditorDidMount = (editor: any, monaco: Monaco) => {
    monacoRef.current = monaco;
    initCompiler(monaco);
    updateLibs();
  };

  useEffect(() => {
    updateLibs();

    // Cleanup final cuando el componente se desmonta por completo
    return () => {
      disposablesRef.current.forEach((d) => d.dispose());
    };
  }, [definitions]);

  return { handleEditorDidMount };
};


============================================================
FILE_PATH: src\features\editor\lib\monaco\TypeBuilder.ts
============================================================
import { parseSqlScript } from "../../../engine/lib/runScript/runScript";

export class TypeBuilder {
  private definitions: string[] = [];

  constructor() {}

  addCore(): this {
    this.definitions.push(`
      declare const console: {
        log(...args: any[]): void;
        warn(...args: any[]): void;
        error(...args: any[]): void;
      };
      declare const Math: any;
      declare const JSON: any;
    `);
    return this;
  }

  addContext(contextVariables: Record<string, string>): this {
    const lines = Object.entries(contextVariables).map(
      ([key, type]) => `declare const ${key}: ${type};`
    );
    this.definitions.push(lines.join("\n"));
    return this;
  }

  addSqlQueries(sqlCode: string): this {
    const queries = Object.keys(parseSqlScript(sqlCode));
    const queryProps = queries.map((q) => `  "${q}": string;`).join("\n");
    this.definitions.push(`
       /** Consultas extraídas automáticamente de tu SQL */
       declare const QUERIES: {
         ${queryProps}
       };
     `);
    return this;
  }

  addCustom(definition: string | string[]): this {
    if (typeof definition == "string") {
      this.definitions.push(definition);
    } else {
      this.definitions.push(...definition);
    }
    return this;
  }

  build(): string {
    return this.definitions.join("\n\n");
  }
}


============================================================
FILE_PATH: src\features\engine\index.ts
============================================================
export { DynamicComponent } from "./components/DynamicComponent";
export { createEngine } from "./modules";
export { useEngine } from "./hooks/useEngine";
export { useEditor } from "./store/useEditor";


============================================================
FILE_PATH: src\features\engine\components\DynamicComponent.tsx
============================================================
import { JSX, memo, useMemo } from "react";
import { v4 as uuid } from "uuid";
import { IComponent } from "../modules/types/component.type";
import { IEngine } from "../modules";

export const RecursiveComponent = memo(
  ({
    componentMap,
    data,
    context,
  }: {
    componentMap: Record<string, (...data: any) => JSX.Element>;
    data?: IComponent;
    context: any;
  }) => {
    // 1. Preparamos los datos seguros MEMORIZADOS
    const safeData = useMemo(() => {
      if (!data) return null;

      // Clonamos superficialmente para no mutar el objeto original del engine
      const clone = { ...data };

      // Aseguramos ID estable (si el engine no lo manda, lo creamos una vez)
      if (!clone.id) clone.id = uuid();

      // Limpieza de estilos
      if (clone.config && typeof clone.config.style === "string") {
        clone.config = { ...clone.config, style: undefined };
      }

      return clone;
    }, [data]); // Solo se recalcula si 'data' cambia referencialmente

    if (!safeData) return null;

    const TargetComponent = componentMap[safeData.type];
    if (!TargetComponent) return null;

    return (
      <TargetComponent
        {...safeData}
        componentMap={componentMap}
        context={context}
      >
        {safeData.subComponents &&
          (Array.isArray(safeData.subComponents) ? (
            safeData.subComponents.map((item) => {
              // Nota: Lo ideal es que el Engine asigne IDs, pero si no:
              const itemId = item.id || uuid();
              return (
                <RecursiveComponent
                  data={{ ...item, id: itemId }} // Pasamos el ID asegurado
                  key={itemId}
                  context={context}
                  componentMap={componentMap}
                />
              );
            })
          ) : (
            <RecursiveComponent
              data={safeData.subComponents}
              context={context}
              componentMap={componentMap}
            />
          ))}
      </TargetComponent>
    );
  }
);
RecursiveComponent.displayName = "RecursiveComponent";

export const DynamicComponent = memo(
  ({ engine, data }: { engine?: IEngine | null; data?: IComponent }) => {
    if (!engine) return null;
    const context = engine.globalContext.context;
    const componentMap = engine.ComponentMap;
    return (
      <RecursiveComponent
        componentMap={componentMap}
        data={data}
        context={context}
      />
    );
  }
);

DynamicComponent.displayName = "DynamicComponent";


============================================================
FILE_PATH: src\features\engine\hooks\useComponentRegistration.ts
============================================================
import { useLayoutEffect } from "react";
import { IContext } from "../modules/types/component.type";

export const useComponentRegistration = <TMethods extends Record<string, any>>(
  context: IContext | undefined,
  group: string,
  id: string,
  methods: TMethods
) => {
  useLayoutEffect(() => {
    if (!context || !id) return;
    const compRegistry = context.comp as any;
    if (!compRegistry) {
      context.comp = {} as any;
    }
    if (!context.comp[group as keyof typeof context.comp]) {
      (context.comp as any)[group] = {};
    }
    (context.comp as any)[group][id] = methods;
    return () => {
      const currentGroup = (context.comp as any)[group];
      if (currentGroup && currentGroup[id]) {
        delete currentGroup[id];
      }
    };
  }, [context, group, id, methods]);
};


============================================================
FILE_PATH: src\features\engine\hooks\useConnectionError.ts
============================================================
import { useCallback } from "react";
import { toast } from "sonner";
import { useEditor } from "../store/useEditor";

export const useScriptError = () => {
  const { isEditing, addExecutionLogs } = useEditor();
  const execute = useCallback(
    async <T>(
      callback?: (...args: any) => Promise<T> | T,
      ...props: any[]
    ): Promise<T | undefined> => {
      if (!callback) return undefined;
      try {
        return await callback(...props);
      } catch (error: unknown) {
        const errorMessage =
          error instanceof Error ? error.message : String(error);
        const errorStack = error instanceof Error ? error.stack : undefined;
        if (isEditing) {
          addExecutionLogs([
            {
              message: "RUNTIME ERROR",
              data: [
                {
                  message: errorMessage,
                  stack: errorStack,
                  original: error,
                },
              ],
            },
          ]);
        } else {
          console.error("Script Error:", error);
          toast.error("Se produjo un error", {
            description: errorMessage,
          });
        }
        return undefined;
      }
    },
    [isEditing, addExecutionLogs]
  );

  return execute;
};


============================================================
FILE_PATH: src\features\engine\hooks\useDynamicValue.ts
============================================================
import { useEffect, useRef, useState, useCallback } from "react";
import { useScriptError } from "./useConnectionError";
import {
  IComponentData,
  IContext,
  IDynamicFunction,
  IDynamicValue,
} from "../modules/types/component.type";

const globalDataCache = new WeakMap<object, any>();

function isComponentDataWrapper<T>(
  value: any
): value is { data: T; keepData: boolean } {
  return (
    value !== null &&
    typeof value === "object" &&
    "data" in value &&
    "keepData" in value
  );
}

export const useDynamicValue = <T>(
  context: IContext,
  _value: IComponentData<T> | undefined,
  defaultValue: T
) => {
  const execute = useScriptError();
  const getInitialValue = (): T => {
    if (
      _value &&
      isComponentDataWrapper(_value) &&
      _value.keepData &&
      globalDataCache.has(_value)
    ) {
      return globalDataCache.get(_value) as T;
    }
    return defaultValue;
  };

  const [value, setStateValue] = useState<T>(getInitialValue);
  const valueRef = useRef<T>(getInitialValue());
  const hasExecuted = useRef(false);

  const [reloadVersion, setReloadVersion] = useState(0);
  const ignoreCacheOnce = useRef(false);

  const setValue = (newValue: T) => {
    if (valueRef.current === newValue) return;
    valueRef.current = newValue;
    setStateValue(newValue);
  };

  const reload = useCallback(() => {
    ignoreCacheOnce.current = true;
    hasExecuted.current = false;
    setReloadVersion((v) => v + 1);
  }, []);

  useEffect(() => {
    let isMounted = true;

    const resolveValue = async () => {
      if (_value === undefined || _value === null) return;

      let source: IDynamicValue<T>;
      let shouldKeepData = false;
      let cacheKey: object | null = null;

      if (isComponentDataWrapper<IDynamicValue<T>>(_value)) {
        source = _value.data;
        shouldKeepData = _value.keepData;
        cacheKey = _value;
      } else {
        source = _value as IDynamicValue<T>;
      }
      if (shouldKeepData && hasExecuted.current && !ignoreCacheOnce.current) {
        return;
      }
      if (
        shouldKeepData &&
        cacheKey &&
        globalDataCache.has(cacheKey) &&
        !ignoreCacheOnce.current
      ) {
        const cachedVal = globalDataCache.get(cacheKey);
        setValue(cachedVal);
        hasExecuted.current = true;
        return;
      }

      if (typeof source === "function") {
        try {
          const func = source as IDynamicFunction<T>;
          const result = await execute<T>(func, context);

          if (isMounted && result !== undefined) {
            setValue(result);
            hasExecuted.current = true;
            if (shouldKeepData && cacheKey) {
              globalDataCache.set(cacheKey, result);
            }
          }
        } catch (error) {
          console.error("Error resolving dynamic value:", error);
        }
      } else {
        if (isMounted) {
          setValue(source as T);
          hasExecuted.current = true;
        }
      }
      if (ignoreCacheOnce.current) {
        ignoreCacheOnce.current = false;
      }
    };

    resolveValue();

    return () => {
      isMounted = false;
    };
  }, [_value, context, reloadVersion]);
  return [valueRef, setValue, value, reload] as const;
};


============================================================
FILE_PATH: src\features\engine\hooks\useEngine.ts
============================================================
import { ConnectFunc } from "../modules/functions/Connect/Connect";
import { useEditor } from "../store/useEditor";
import { createEngine, IEngine } from "../modules";
import { runScript as run } from "../lib/runScript/runScript";
import { useScriptConnection } from "../store/useScriptConnection";

export const useEngine = () => {
  const editor = useEditor();
  const connect = ConnectFunc();
  const scriptConnection = useScriptConnection();

  const runScript = async (
    jsCode: string,
    sqlCode: string,
    engine: IEngine
  ) => {
    return await run(jsCode, sqlCode, engine.globalContext);
  };

  return {
    ...scriptConnection,
    ...editor,
    connect,
    runScript,
    createEngine,
  };
};


============================================================
FILE_PATH: src\features\engine\lib\connectionsAdapters\MockAdapter.ts
============================================================
import { DatabaseAdapter, QueryResult } from "./types";

export class MockAdapter implements DatabaseAdapter {
  id = "mock";
  name = "Mock Local DB";
  private connected = false;

  async connect(): Promise<void> {
    this.connected = true;
  }

  async disconnect(): Promise<void> {
    this.connected = false;
  }

  isConnected(): boolean {
    return this.connected;
  }

  async execute(query: string): Promise<QueryResult> {
    if (!this.connected) return { data: null, error: "Disconnected" };

    // Simulamos una respuesta basada en lo que escribas
    if (query.toLowerCase().includes("select")) {
      return {
        data: [
          { id: 1, name: "Mock User 1", role: "admin" },
          { id: 2, name: "Mock User 2", role: "user" },
        ],
        error: null,
      };
    }

    return { data: null, error: "Syntax Error: Mock DB solo soporta SELECT" };
  }
}


============================================================
FILE_PATH: src\features\engine\lib\connectionsAdapters\SupabaseAdapter.ts
============================================================
import { createClient, SupabaseClient } from "@supabase/supabase-js";
import { DatabaseAdapter, QueryResult } from "./types";

export class SupabaseAdapter implements DatabaseAdapter {
  id = "supabase";
  name = "Supabase Production";
  private client: SupabaseClient | null = null;
  private connected = false;

  async connect(config: { url: string; key: string }): Promise<void> {
    if (!config?.url || !config?.key) {
      throw new Error("Supabase URL y Key son requeridos para conectar.");
    }

    try {
      // 1. Inicializamos el cliente con las credenciales proporcionadas dinámicamente
      this.client = createClient(config.url, config.key, {
        auth: {
          persistSession: false,
          detectSessionInUrl: false,
          autoRefreshToken: false,
        },
      });

      // 2. "Ping" de validación: Intentamos una consulta simple para verificar credenciales
      // Nota: Esto asume que ya creaste la función RPC 'exec_sql' en tu base de datos.
      const { error } = await this.client.rpc("exec_sql", {
        sql_query: "SELECT 1",
      });

      if (error) throw error;

      this.connected = true;
    } catch (err: any) {
      this.connected = false;
      this.client = null;
      throw new Error(`Fallo al conectar: ${err.message}`);
    }
  }

  async disconnect(): Promise<void> {
    // Supabase js no requiere desconexión explícita (es stateless via HTTP),
    // pero limpiamos la referencia.
    this.client = null;
    this.connected = false;
  }

  isConnected(): boolean {
    return this.connected && this.client !== null;
  }

  async execute(query: string): Promise<QueryResult> {
    if (!this.client || !this.connected) {
      return { data: null, error: "No hay conexión establecida con Supabase" };
    }

    try {
      // Llamamos a la función RPC que permite ejecutar RAW SQL
      const { data, error } = await this.client.rpc("exec_sql", {
        sql_query: query,
      });

      if (error) throw error;

      // Lógica para interpretar la respuesta de nuestra función RPC customizada:

      // Caso 1: Error controlado devuelto por el SQL (dentro del JSON)
      if (data && !Array.isArray(data) && data.error) {
        return { data: null, error: data.error };
      }

      // Caso 2: Mensaje de éxito (INSERT/UPDATE/DELETE que devuelve objeto de status)
      if (data && !Array.isArray(data) && data.status === "success") {
        return {
          data: null,
          error: null,
          message: data.message || "Comando ejecutado exitosamente",
        };
      }

      // Caso 3: Array de datos (SELECT)
      return {
        data: Array.isArray(data) ? data : [], // Si es null (sin filas), devolvemos array vacío
        error: null,
        message: undefined,
      };
    } catch (err: any) {
      return { data: null, error: err.message || "Error al ejecutar consulta" };
    }
  }
}


============================================================
FILE_PATH: src\features\engine\lib\connectionsAdapters\types.ts
============================================================
// src/lib/db-adapters/types.ts

export interface QueryResult {
  data: any[] | null;
  error: string | null;
  message?: string; // Para mensajes de éxito como "Table created"
}

// Interfaz que todos los adaptadores deben cumplir
export interface DatabaseAdapter {
  id: string; // 'supabase', 'local', 'mock'
  name: string; // Nombre legible

  // Conectar (puede recibir credenciales o config)
  connect(config?: any): Promise<void>;

  // Desconectar
  disconnect(): Promise<void>;

  // Ejecutar query
  execute(query: string): Promise<QueryResult>;

  // Verificar estado
  isConnected(): boolean;
}


============================================================
FILE_PATH: src\features\engine\lib\runScript\parseSqlScript.ts
============================================================
export function parseSqlScript(text) {
  const regex = /--\[(.*?)\]([\s\S]*?)(?=(?:--\[|$))/g;
  const queries = {};
  let match;
  while ((match = regex.exec(text)) !== null) {
    const key = match[1].trim();
    const query = match[2].trim();
    queries[key] = query;
  }
  return queries as Record<string, string>;
}


============================================================
FILE_PATH: src\features\engine\lib\runScript\processSqlTemplate.ts
============================================================
export function processSqlTemplate(
  sql: string,
  variables: Record<string, any>
) {
  // Regex: Busca {{ seguido de cualquier espacio, captura el nombre, espacios y }}
  return sql.replace(/\{\{\s*([^}]+)\s*\}\}/g, (_match, key) => {
    const varName = key.trim(); // Quitamos espacios extra: " parentId " -> "parentId"
    const value = variables[varName];

    // 1. Si no existe la variable, devolvemos NULL o dejamos el tag (tú decides)
    if (value === undefined) {
      console.warn(`Variable ${varName} no encontrada`);
      return "NULL";
    }

    // 2. Si es null
    if (value === null) return "NULL";

    // 3. Si es String, agregamos comillas simples para que sea SQL válido
    // 4. Si es Array (útil para IN (...)), los unimos por comas
    if (Array.isArray(value)) {
      return value.join(", ");
    }

    // 5. Números y booleanos se devuelven directos
    return String(value);
  });
}


============================================================
FILE_PATH: src\features\engine\lib\runScript\runScript.ts
============================================================
import { useEditorStore } from "../../store/editor.store";
import { parseSqlScript } from "./parseSqlScript";
import { processSqlTemplate } from "./processSqlTemplate";

const AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;

async function executeSafeScript(
  scriptCode: string,
  context: Record<string, any>,
  blockedList: string[]
) {
  let result;
  const allowedContext = {
    Math: Math,
    JSON: JSON,
    ...context,
  };
  try {
    const allowedKeys = Object.keys(allowedContext);
    const allowedValues = Object.values(allowedContext);
    const allArgNames = [...allowedKeys, ...blockedList];
    const allArgValues = [
      ...allowedValues,
      ...blockedList.map(() => undefined),
    ];
    const fn = new AsyncFunction(...allArgNames, scriptCode);
    result = await fn(...allArgValues);
  } catch (e: any) {
    useEditorStore.getState().addExecutionLogs([
      {
        message: "Error crítico de ejecución" + e.message,
      },
    ]);
  }

  return { result };
}

export async function runScript(
  jsScript: string,
  sqlScript: string,
  scriptContext?: Record<string, any>
) {
  const queries = parseSqlScript(sqlScript);

  const blockedList = [
    "fetch",
    "XMLHttpRequest",
    "setInterval",
    "globalThis",
    "eval",
    "Function",
    "document",
    "window",
    "console",
  ];

  const handleExecQuery = async (
    query: string,
    context: Record<string, string> = {}
  ) => {
    query = processSqlTemplate(query, context);
    return scriptContext?.execQuery ? await scriptContext.execQuery(query) : [];
  };

  const { result } = await executeSafeScript(
    jsScript,
    {
      execQuery: handleExecQuery,
      QUERIES: queries,
      ...scriptContext,
    },
    blockedList
  );

  return { result };
}

export { parseSqlScript };


============================================================
FILE_PATH: src\features\engine\lib\runScript\sqlHelper.ts
============================================================
// utils/sqlHelpers.ts
export const interpolateQuery = (
  query: string,
  variables: Record<string, any>
) => {
  return query.replace(/\{\{(\w+)\}\}/g, (_, key) => {
    return variables[key] !== undefined ? `'${variables[key]}'` : "NULL";
  });
};


============================================================
FILE_PATH: src\features\engine\modules\index.ts
============================================================
import { IComponentModule } from "./types/IComponentModule";
import { ComponentModules } from "./components";
import { ComponentType, ContextType } from "./types/component.definition";
import { FunctionModules } from "./functions";
import { IFunctionModule } from "./types/IFuntionsModule";
import { createContext } from "./lib/createContext";
import { JSX } from "react";

interface ICompDefinitions {
  components: Record<string, any>;
  eventsDefinition: string;
  builderDefinition: string;
  contextEvents: Record<string, string>;
  context: Record<string, any>;
}

interface IFunDefinitions {
  context: Record<string, any>;
  definition: string;
}

export interface IEngineOptions {
  include?: string[];
  exclude?: string[];
  includeFunctions?: string[];
  excludeFunctions?: string[];
}

function ProcessModule(
  prev: ICompDefinitions,
  curr: IComponentModule
): ICompDefinitions {
  prev.components[curr.name] = curr.component;
  prev.context[curr.name] = curr.builder;

  if (curr.eventsDefinition) {
    const defObj =
      typeof curr.eventsDefinition === "string"
        ? {
            definition: curr.eventsDefinition,
            key: curr.name.toLowerCase(),
            name: `I${curr.name}Map`,
          }
        : curr.eventsDefinition;

    const { definition, key, name } = defObj;

    prev.contextEvents[key] = name;
    prev.eventsDefinition += `\n${definition}\n`;
  }

  if (curr.builderDefinition) {
    prev.builderDefinition += `\n${curr.builderDefinition}\n`;
  }

  return prev;
}

function ProcessFunModule(prev: IFunDefinitions, curr: IFunctionModule) {
  prev.context[curr.name] = curr.func();
  prev.definition += curr.definition;
  return prev;
}

export interface IEngine {
  ComponentMap: Record<string, (data: any) => JSX.Element>;
  ModulesDefinition: string;
  globalContext: Record<string, any>;
  LoadedComponents: string[];
  LoadedFunctions: string[];
}

export const createEngine = (options: IEngineOptions = {}): IEngine => {
  let CompModuToProcess = [...ComponentModules];
  if (options.include && options.include.length > 0) {
    CompModuToProcess = CompModuToProcess.filter((mod) =>
      options.include!.includes(mod.name)
    );
  } else if (options.exclude && options.exclude.length > 0) {
    CompModuToProcess = CompModuToProcess.filter(
      (mod) => !options.exclude!.includes(mod.name)
    );
  }

  let functionsToProcess: any = [...FunctionModules];
  if (options.includeFunctions && options.includeFunctions.length > 0) {
    functionsToProcess = functionsToProcess.filter((func) =>
      options.includeFunctions!.includes(func.name)
    );
  } else if (options.excludeFunctions && options.excludeFunctions.length > 0) {
    functionsToProcess = functionsToProcess.filter(
      (func) => !options.excludeFunctions!.includes(func.name)
    );
  }

  const CompConfig = CompModuToProcess.reduce(ProcessModule, {
    components: {},
    eventsDefinition: "",
    builderDefinition: "",
    contextEvents: {},
    context: {},
  });

  const FunConfig = functionsToProcess.reduce(ProcessFunModule, {
    context: {},
    definition: "",
  });

  const definitions = [
    CompConfig.eventsDefinition,
    ContextType(CompConfig.contextEvents),
    ComponentType,
    CompConfig.builderDefinition,
    FunConfig.definition,
  ];

  const context = createContext();

  return {
    ComponentMap: CompConfig.components,
    ModulesDefinition: definitions.join("\n"),
    globalContext: {
      ...CompConfig.context,
      ...FunConfig.context,
      context,
    },
    LoadedComponents: CompModuToProcess.map((m) => m.name),
    LoadedFunctions: functionsToProcess.map((f) => f.name),
  };
};

export const DefaultEngine = createEngine();


============================================================
FILE_PATH: src\features\engine\modules\components\index.ts
============================================================
import { IComponentModule } from "../types/IComponentModule";
import { BUTTON } from "./button";
import { CONFIRM_MODAL } from "./confirmModal";
import { FORM } from "./form";
import { FORM_MODAL } from "./formModal";
import { FRAGMENT } from "./fragment";
import { GALLERY } from "./gallery";
import { LAYOUT } from "./layout";
import { LOADING_MODAL } from "./loadingModal";
import { NAVIGATION } from "./navigation";
import { TABLE } from "./table";
import { TEXT } from "./text";

export const ComponentModules: IComponentModule[] = [
  BUTTON,
  TEXT,
  LAYOUT,
  FRAGMENT,
  CONFIRM_MODAL,
  LOADING_MODAL,
  NAVIGATION,
  GALLERY,
  TABLE,
  FORM,
  FORM_MODAL,
];


============================================================
FILE_PATH: src\features\engine\modules\components\button\button.builder.ts
============================================================
import { IComponent } from "../../types/component.type";
import { IButtonProps } from "./button.definition";

interface IButtonFactory {
  (data: IButtonProps): IComponent;
}

export const Button: IButtonFactory = ({
  id,
  config = {},
  label,
  context,
  load,
  // Eventos planos
  onClick,
  onMouseEnter,
  onMouseLeave,
  onFocus,
  onBlur,
}) => {
  // Mapeamos los eventos planos al objeto 'events' que usa el motor internamente
  const componentEvents: Record<string, any> = {};

  if (onClick) componentEvents.onClick = onClick;
  if (onMouseEnter) componentEvents.onMouseEnter = onMouseEnter;
  if (onMouseLeave) componentEvents.onMouseLeave = onMouseLeave;
  if (onFocus) componentEvents.onFocus = onFocus;
  if (onBlur) componentEvents.onBlur = onBlur;

  return {
    id,
    type: "Button",
    context,
    load,
    data: { label },
    config: {
      variant: "default",
      size: "default",
      ...config,
    },
    events: componentEvents,
  };
};


============================================================
FILE_PATH: src\features\engine\modules\components\button\button.component.tsx
============================================================
import { useScriptError } from "@/features/engine/hooks/useConnectionError";
import { IComponent, IContext } from "../../types/component.type";
import { useDynamicValue } from "@/features/engine/hooks/useDynamicValue";
import { useMemo, useRef, useState } from "react";
import { useComponentRegistration } from "@/features/engine/hooks/useComponentRegistration";
import { Button } from "@/components/ui/button";
import { DynamicIcon, IconName } from "@/components/ui/dynamic-icon";
import { IButtonProps } from "./button.definition";
import { Loader2 } from "lucide-react";

export const DynamicButton = ({
  config = {},
  events, // El motor pasa los eventos aquí (gracias al builder)
  context,
  id,
  data,
}: IComponent & IButtonProps & { context: IContext }) => {
  const execute = useScriptError();

  // 1. Label Dinámico
  const [labelRef, setLabel, label] = useDynamicValue(
    context,
    data?.label,
    "Button"
  );

  // 2. Estados Locales
  const [isLoading, setIsLoading] = useState(config.loading || false);
  const [isDisabled, setIsDisabled] = useState(config.disabled || false);

  const buttonRef = useRef<HTMLButtonElement>(null);

  // 3. Helper para ejecutar eventos
  const handleEvent = (eventName: string, e: any) => {
    if (events && events[eventName]) {
      execute(events[eventName], e, context);
    }
  };

  // 4. Métodos Expuestos
  const exposedMethods = useMemo(
    () => ({
      setLabel: (value: string) => setLabel(value),
      getLabel: () => labelRef.current,
      setDisabled: (value: boolean) => setIsDisabled(value),
      setLoading: (value: boolean) => setIsLoading(value),
      click: () => buttonRef.current?.click(),
    }),
    [setLabel, labelRef]
  );

  useComponentRegistration(context, "btn", id, exposedMethods);

  const isButtonDisabled = isDisabled || isLoading;

  return (
    <Button
      ref={buttonRef}
      type={config.type || "button"}
      variant={config.variant || "default"}
      size={config.size || "default"}
      className={config.className}
      style={config.style}
      disabled={isButtonDisabled}
      onClick={(e) => handleEvent("onClick", e)}
      onMouseEnter={(e) => handleEvent("onMouseEnter", e)}
      onMouseLeave={(e) => handleEvent("onMouseLeave", e)}
      onFocus={(e) => handleEvent("onFocus", e)}
      onBlur={(e) => handleEvent("onBlur", e)}
    >
      {isLoading ? (
        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
      ) : (
        config.icon && (
          <DynamicIcon
            name={config.icon as IconName}
            className="mr-2 h-4 w-4"
          />
        )
      )}
      {label}
    </Button>
  );
};


============================================================
FILE_PATH: src\features\engine\modules\components\button\button.definition.ts
============================================================
import {
  IComponent,
  IComponentEvent,
  IContext,
  IComponentData,
} from "../../types/component.type";

// --- 1. Tipos de Variantes y Configuración ---

export type ButtonVariant =
  | "default"
  | "destructive"
  | "outline"
  | "secondary"
  | "ghost"
  | "link";

export type ButtonSize = "default" | "sm" | "lg" | "icon";

/**
 * Configuración visual y de comportamiento del botón.
 */
export interface IButtonConfig {
  className?: string;
  style?: React.CSSProperties;
  variant?: ButtonVariant;
  size?: ButtonSize;
  icon?: string;
  disabled?: boolean;
  loading?: boolean;
  type?: "button" | "submit" | "reset";
}

// --- 2. Datos Dinámicos ---

export interface IButtonData {
  /** Texto del botón (soporta binding dinámico) */
  label?: IComponentData<string>;
}

// --- 3. Eventos (Estructura Plana para DX) ---

export interface IButtonEvents {
  onClick?: IComponentEvent;
  onMouseEnter?: IComponentEvent;
  onMouseLeave?: IComponentEvent;
  onFocus?: IComponentEvent;
  onBlur?: IComponentEvent;
}

// --- 4. Props Principales ---

/**
 * Propiedades del componente Button.
 * Los eventos se definen en el nivel raíz para mejorar la DX.
 */
export interface IButtonProps extends IButtonData, IButtonEvents {
  id: string;
  config?: IButtonConfig;
  context?: IContext;
  load?: () => void;
}

export type ButtonFactory = (props: IButtonProps) => IComponent;

// --- 5. Definiciones para el Editor (Strings) ---

export const BUTTON_TYPE_DEFINITION = `
/** Opciones visuales */
type ButtonVariant = "default" | "destructive" | "outline" | "secondary" | "ghost" | "link";
type ButtonSize = "default" | "sm" | "lg" | "icon";

interface IButtonConfig {
  className?: string;
  /** Estilos CSS en objeto. Ej: { backgroundColor: 'red' } */
  style?: Record<string, any>; 
  variant?: ButtonVariant;
  size?: ButtonSize;
  icon?: string;
  disabled?: boolean;
  loading?: boolean;
  type?: "button" | "submit" | "reset";
}

/** Propiedades del Botón */
interface IButtonProps {
  id: string;
  config?: IButtonConfig;
  label?: IComponentData<string>;
  
  // Eventos
  onClick?: IComponentEvent;
  onMouseEnter?: IComponentEvent;
  onMouseLeave?: IComponentEvent;
  onFocus?: IComponentEvent;
  onBlur?: IComponentEvent;
}

/** Crea un componente Botón */
declare const Button: (props: IButtonProps) => IComponent;
`;

const BUTTON_CONTEXT_EVENTS_DEFINITION = `
interface IButtonExposedMethods {
  setLabel: (value: string) => void;
  getLabel: () => string;
  setDisabled: (disabled: boolean) => void;
  setLoading: (loading: boolean) => void;
  click: () => void;
}

interface IButtonMap {
  [id: string]: IButtonExposedMethods;
}
`;

export const BUTTON_CONTEXT_EVENT = {
  key: "btn",
  name: "IButtonMap",
  definition: BUTTON_CONTEXT_EVENTS_DEFINITION,
};


============================================================
FILE_PATH: src\features\engine\modules\components\button\index.ts
============================================================
import { IComponentModule } from "../../types/IComponentModule";
import { Button } from "./button.builder";
import { DynamicButton } from "./button.component";
import {
  BUTTON_CONTEXT_EVENT,
  BUTTON_TYPE_DEFINITION,
} from "./button.definition";

export const BUTTON: IComponentModule = {
  name: "Button",
  builder: Button,
  component: DynamicButton,
  eventsDefinition: BUTTON_CONTEXT_EVENT,
  builderDefinition: BUTTON_TYPE_DEFINITION,
};


============================================================
FILE_PATH: src\features\engine\modules\components\confirmModal\confirm-modal.builder.ts
============================================================
import { IComponent } from "../../types/component.type";
import { ConfirmModalFactory } from "./confirm-modal.definition";

export const ConfirmModal: ConfirmModalFactory = ({
  id,
  config = {},
  context,
  load,
  // Desestructuramos los eventos planos
  onConfirm,
  onCancel,
}): IComponent => {
  // Construimos el objeto events para el motor
  const componentEvents: Record<string, any> = {};

  if (onConfirm) componentEvents.onConfirm = onConfirm;
  if (onCancel) componentEvents.onCancel = onCancel;

  return {
    id,
    type: "ConfirmModal",
    context,
    load,
    config: {
      title: "Are you sure?", // Valores por defecto seguros
      description: "This action cannot be undone.",
      ...config,
    },
    data: {},
    events: componentEvents,
    subComponents: [], // Es un componente hoja, no suele tener hijos dinámicos
  };
};


============================================================
FILE_PATH: src\features\engine\modules\components\confirmModal\confirm-modal.component.tsx
============================================================
import { useScriptError } from "@/features/engine/hooks/useConnectionError";
import { useComponentRegistration } from "@/features/engine/hooks/useComponentRegistration";
import { ConfirmModal as SharedConfirmModal } from "@/components/shared/modals/ConfirmModal"; // Tu componente UI base
import { IComponent, IContext } from "../../types/component.type";
import { IConfirmModalProps } from "./confirm-modal.definition";
import { useMemo } from "react";

export const DynamicConfirmModal = ({
  config = {},
  events,
  id,
  context,
}: IComponent & IConfirmModalProps & { context: IContext }) => {
  const execute = useScriptError();

  // 1. Handlers de eventos
  const handleOnConfirm = () => {
    if (events?.onConfirm) {
      execute(events.onConfirm, undefined, context);
    }
  };

  const handleOnCancel = () => {
    if (events?.onCancel) {
      execute(events.onCancel, undefined, context);
    }
  };

  // 2. Registro (opcional, pero buena práctica)
  const exposedMethods = useMemo(() => ({}), []);
  useComponentRegistration(context, "confirmModal", id, exposedMethods);

  return (
    <SharedConfirmModal
      id={id}
      title={config.title}
      description={config.description}
      className={config.className}
      // Pasamos los handlers que ejecutan el script
      onConfirm={handleOnConfirm}
      onCancel={handleOnCancel}
      // Si tu componente UI soporta style, pásalo también
      // style={config.style}
    />
  );
};


============================================================
FILE_PATH: src\features\engine\modules\components\confirmModal\confirm-modal.definition.ts
============================================================
import {
  IComponent,
  IComponentEvent,
  IContext,
} from "../../types/component.type";

// --- 1. Configuración ---

export interface IConfirmModalConfig {
  /** Título del modal */
  title?: string;
  /** Descripción o mensaje del cuerpo */
  description?: string;
  /** Clases CSS adicionales */
  className?: string;
  /** Estilos en línea */
  style?: React.CSSProperties;
  /** Texto del botón confirmar (opcional, si tu UI lo soporta) */
  confirmText?: string;
  /** Texto del botón cancelar (opcional, si tu UI lo soporta) */
  cancelText?: string;
}

// --- 2. Eventos (Planos) ---

export interface IConfirmModalEvents {
  /** Se ejecuta al confirmar la acción */
  onConfirm?: IComponentEvent;
  /** Se ejecuta al cancelar o cerrar el modal */
  onCancel?: IComponentEvent;
}

// --- 3. Props Principales ---

export interface IConfirmModalProps extends IConfirmModalEvents {
  id: string;
  config?: IConfirmModalConfig;
  context?: IContext;
  load?: () => void;
}

export type ConfirmModalFactory = (props: IConfirmModalProps) => IComponent;

// --- 4. Definiciones para el Editor (Strings) ---

export const CONFIRM_MODAL_TYPE_DEFINITION = `
interface IConfirmModalConfig {
  title?: string;
  description?: string;
  className?: string;
  style?: Record<string, any>;
  confirmText?: string;
  cancelText?: string;
}

interface IConfirmModalProps {
  id: string;
  config?: IConfirmModalConfig;
  
  // Eventos
  onConfirm?: IComponentEvent;
  onCancel?: IComponentEvent;
}

/** * Crea un Modal de Confirmación.
 * Útil para solicitar validación antes de una acción destructiva.
 */
declare const ConfirmModal: (props: IConfirmModalProps) => IComponent;
`;

// Definición de contexto vacía (por si en el futuro quieres métodos como .open() o .close())
export const CONFIRM_MODAL_CONTEXT_EVENT = {
  key: "confirmModal",
  name: "IConfirmModalMap",
  definition: "",
};


============================================================
FILE_PATH: src\features\engine\modules\components\confirmModal\index.ts
============================================================
import { IComponentModule } from "../../types/IComponentModule";
import { ConfirmModal } from "./confirm-modal.builder";
import { DynamicConfirmModal } from "./confirm-modal.component";
import {
  CONFIRM_MODAL_CONTEXT_EVENT,
  CONFIRM_MODAL_TYPE_DEFINITION,
} from "./confirm-modal.definition";

export const CONFIRM_MODAL: IComponentModule = {
  name: "ConfirmModal",
  component: DynamicConfirmModal,
  builder: ConfirmModal,
  eventsDefinition: CONFIRM_MODAL_CONTEXT_EVENT,
  builderDefinition: CONFIRM_MODAL_TYPE_DEFINITION,
};


============================================================
FILE_PATH: src\features\engine\modules\components\form\form.builder.ts
============================================================
import { IComponent } from "../../types/component.type";
import { FormFactory } from "./form.definition";

export const Form: FormFactory = ({
  id,
  config = {},
  // Datos extraídos del nivel raíz
  schema,
  fields,
  defaultValues,
  context,
  load,
  // Eventos
  onSubmit,
}) => {
  const componentEvents: Record<string, any> = {};

  if (onSubmit) componentEvents.onSubmit = onSubmit;

  return {
    id,
    type: "Form", // Debe coincidir con index.ts y el registro
    context,
    load,
    // Empaquetamos la definición en data
    data: {
      schema,
      fields,
      defaultValues,
    },
    config: {
      confirmLabel: "Guardar",
      cancelLabel: "Cancelar",
      ...config,
    },
    events: componentEvents,
  };
};


============================================================
FILE_PATH: src\features\engine\modules\components\form\form.component.tsx
============================================================
import { useMemo } from "react";
// Asegúrate de que esta ruta sea correcta hacia tu componente UI base
import { DynamicForm as UIForm } from "@/components/shared/DynamicForm";

import { useScriptError } from "@/features/engine/hooks/useConnectionError";
import { useComponentRegistration } from "@/features/engine/hooks/useComponentRegistration";
import { useDynamicValue } from "@/features/engine/hooks/useDynamicValue";

import { IComponent, IContext } from "../../types/component.type";
import { IFormProps } from "./form.definition";

export const DynamicFormComponent = ({
  config = {},
  events,
  context,
  id,
  data,
}: IComponent & IFormProps & { context: IContext }) => {
  const execute = useScriptError();

  // 1. Valores por defecto dinámicos
  // Esto permite hacer binding: defaultValues: table.selectedRow
  const [_, __, defaultValues] = useDynamicValue(
    context,
    data?.defaultValues,
    {}
  );

  // 2. Manejo del Submit
  const handleOnSubmit = (formData: any) => {
    if (events?.onSubmit) {
      execute(events.onSubmit, formData, context);
    }
  };

  // 3. Registro (Opcional, por si quieres métodos como form.reset() en el futuro)
  const exposedMethods = useMemo(() => ({}), []);
  useComponentRegistration(context, "form", id, exposedMethods);

  return (
    <UIForm
      // Configuración visual
      className={config.className}
      /*       classNameForm={config.classNameForm} */
      /*       title={config.title} */
      /*       description={config.description} */
      confirmName={config.confirmLabel} // Mapeo de nombres si tu UI usa 'confirmName'
      /*       cancelName={config.cancelLabel} */
      // Datos del formulario
      schema={data?.schema}
      fields={data?.fields || []}
      defaultValues={defaultValues}
      // Eventos
      onSubmit={handleOnSubmit}
    />
  );
};


============================================================
FILE_PATH: src\features\engine\modules\components\form\form.definition.ts
============================================================
import {
  IComponent,
  IComponentEvent,
  IContext,
  IComponentData,
} from "../../types/component.type";

// --- 1. Tipos Auxiliares (FieldConfig placeholder) ---
// Asumimos que FieldConfig viene de tu librería de UI, pero lo definimos genérico aquí
export type FieldConfig = Record<string, any>;

// --- 2. Configuración Visual ---

export interface IFormConfig {
  className?: string;
  classNameForm?: string;
  title?: string;
  description?: string;
  /** Texto del botón de confirmar/enviar */
  confirmLabel?: string;
  /** Texto del botón de cancelar */
  cancelLabel?: string;
}

// --- 3. Datos del Formulario ---

export interface IFormData {
  /** Esquema de validación (ej: Zod Schema serializado o objeto config) */
  schema?: any;
  /** Definición de los campos (Array de configuración) */
  fields?: FieldConfig[];
  /** Valores iniciales (soporta binding dinámico) */
  defaultValues?: IComponentData<any>;
}

// --- 4. Eventos ---

export interface IFormEvents {
  /** Se ejecuta al enviar el formulario con éxito. Recibe los datos { ... } */
  onSubmit?: IComponentEvent;
}

// --- 5. Props Principales ---

export interface IFormProps extends IFormData, IFormEvents {
  id: string;
  config?: IFormConfig;
  context?: IContext;
  load?: () => void;
}

export type FormFactory = (props: IFormProps) => IComponent;

// --- 6. Definiciones para el Editor (Strings) ---

export const FORM_TYPE_DEFINITION = `
interface FieldConfig {
  name: string;
  label: string;
  type: "text" | "number" | "select" | "date" | "checkbox" | "textarea" | "password";
  placeholder?: string;
  [key: string]: any;
}

interface IFormConfig {
  className?: string;
  classNameForm?: string;
  title?: string;
  description?: string;
  confirmLabel?: string;
  cancelLabel?: string;
}

interface IFormProps {
  id: string;
  config?: IFormConfig;
  
  // Datos
  schema?: Record<string, any>;
  fields?: FieldConfig[];
  defaultValues?: IComponentData<any>;

  // Eventos
  onSubmit?: IComponentEvent;
}

/**
 * Crea un Formulario Dinámico basado en un esquema y campos.
 */
declare const Form: (props: IFormProps) => IComponent;
`;

// No suele exponer métodos públicos, pero dejamos la estructura lista
export const FORM_CONTEXT_EVENT = {
  key: "form",
  name: "IFormMap",
  definition: "",
};


============================================================
FILE_PATH: src\features\engine\modules\components\form\index.ts
============================================================
import { IComponentModule } from "../../types/IComponentModule";
import { Form } from "./form.builder";
import { DynamicFormComponent } from "./form.component";
import { FORM_CONTEXT_EVENT, FORM_TYPE_DEFINITION } from "./form.definition";

export const FORM: IComponentModule = {
  name: "Form",
  component: DynamicFormComponent,
  builder: Form,
  eventsDefinition: FORM_CONTEXT_EVENT,
  builderDefinition: FORM_TYPE_DEFINITION,
};


============================================================
FILE_PATH: src\features\engine\modules\components\formModal\form-modal.builder.ts
============================================================
import { IComponent } from "../../types/component.type";
import { FormModalFactory } from "./form-modal.definition";

export const FormModal: FormModalFactory = ({
  id,
  config = {},
  // Datos extraídos del nivel raíz
  schema,
  fields,
  defaultValues,
  context,
  load,
  // Eventos
  onSubmit,
}) => {
  const componentEvents: Record<string, any> = {};

  if (onSubmit) componentEvents.onSubmit = onSubmit;

  return {
    id,
    type: "FormModal",
    context,
    load,
    // Estructuramos los datos para el componente
    data: {
      schema,
      fields,
      defaultValues,
    },
    config: {
      confirmName: "Guardar",
      cancelName: "Cancelar",
      ...config,
    },
    events: componentEvents,
  };
};


============================================================
FILE_PATH: src\features\engine\modules\components\formModal\form-modal.component.tsx
============================================================
import { useEffect, useMemo } from "react";
// Asegúrate de que esta ruta apunte a tu componente UI compartido
import { FormModal as UIFormModal } from "@/components/shared/modals/FormModal";

// Hooks del Engine
import { useScriptError } from "@/features/engine/hooks/useConnectionError";
import { useDynamicValue } from "@/features/engine/hooks/useDynamicValue";
import { useComponentRegistration } from "@/features/engine/hooks/useComponentRegistration";
import { useIsModalOpen, useModalActions } from "@/hooks/useModal"; // Hooks globales de modal

import { IComponent, IContext } from "../../types/component.type";
import { IFormModalProps } from "./form-modal.definition";

export const DynamicFormModal = ({
  config = {},
  events,
  context,
  id,
  data,
}: IComponent & IFormModalProps & { context: IContext }) => {
  const execute = useScriptError();
  const { openModal, closeModal } = useModalActions();
  const isOpen = useIsModalOpen(id);

  // 1. Manejo de Valores Dinámicos
  // 'reload' es vital para refrescar datos al abrir el modal
  const [_, __, defaultValues, reload] = useDynamicValue(
    context,
    data?.defaultValues,
    {}
  );

  // 2. Efecto de Recarga
  // Cuando el modal se abre (isOpen cambia a true), recargamos los valores
  useEffect(() => {
    if (isOpen) {
      reload();
    }
  }, [isOpen, reload]);

  // 3. Manejo de Submit
  const handleOnSubmit = (formData: any) => {
    if (events?.onSubmit) {
      execute(events.onSubmit, formData, context);
    }
  };

  // 4. Registro de componente en el contexto (API para scripts)
  // Permite: formModal.miModal.open()
  const exposedMethods = useMemo(
    () => ({
      open: (modalData?: any) => openModal(id, modalData),
      close: () => closeModal(id),
    }),
    [id, openModal, closeModal]
  );

  useComponentRegistration(context, "formModal", id, exposedMethods);

  return (
    <UIFormModal
      id={id}
      {...config}
      // Configuración Visual
      className={config.className}
      classNameForm={config.classNameForm}
      title={config.title}
      description={config.description}
      confirmName={config.confirmName}
      /*       cancelName={config.cancelName} */

      // Datos
      schema={data?.schema}
      fields={data?.fields}
      defaultValues={defaultValues}
      // Eventos
      onSubmit={handleOnSubmit}
    />
  );
};


============================================================
FILE_PATH: src\features\engine\modules\components\formModal\form-modal.definition.ts
============================================================
import {
  IComponent,
  IComponentEvent,
  IContext,
  IComponentData,
} from "../../types/component.type";

// --- 1. Tipos Auxiliares ---
// Definición flexible para TS, pero detallada en el string del editor
export type FieldConfig = Record<string, any>;

// --- 2. Configuración Visual ---

export interface IFormModalConfig {
  className?: string;
  classNameForm?: string;
  title?: string;
  description?: string;
  /** Texto del botón confirmar */
  confirmName?: string;
  /** Texto del botón cancelar */
  cancelName?: string;
}

// --- 3. Datos del Formulario ---

export interface IFormModalData {
  /** Esquema de validación (Zod o config object) */
  schema?: any;
  /** Array de configuración de campos */
  fields?: FieldConfig[];
  /** Valores por defecto (se recargan al abrir el modal) */
  defaultValues?: IComponentData<any>;
}

// --- 4. Eventos ---

export interface IFormModalEvents {
  /** Se ejecuta al enviar el formulario correctamente */
  onSubmit?: IComponentEvent;
}

// --- 5. Props Principales ---

export interface IFormModalProps extends IFormModalData, IFormModalEvents {
  id: string;
  config?: IFormModalConfig;
  context?: IContext;
  load?: () => void;
}

export type FormModalFactory = (props: IFormModalProps) => IComponent;

// --- 6. Definiciones para el Editor (Strings) ---

export const FORM_MODAL_TYPE_DEFINITION = `
type FieldType = "text" | "number" | "email" | "select" | "date" | "icon" | "password" | "textarea";

interface FieldConfig {
  name: string;
  label: string;
  type: FieldType;
  placeholder?: string;
  /** Opciones para tipo 'select' */
  options?: { label: string; value: string }[];
  /** Clases de grid (ej: 'col-span-2') */
  className?: string;
  [key: string]: any;
}

interface IFormModalConfig {
  className?: string;
  classNameForm?: string;
  title?: string;
  description?: string;
  confirmName?: string;
  cancelName?: string;
}

interface IFormModalProps {
  id: string;
  config?: IFormModalConfig;
  
  // Datos
  schema?: Record<string, any>;
  fields?: FieldConfig[];
  defaultValues?: IComponentData<any>;
  
  // Eventos
  onSubmit?: IComponentEvent;
}

/**
 * Crea un Modal que contiene un Formulario dinámico.
 * Los datos se recargan automáticamente cuando el modal se abre.
 */
declare const FormModal: (props: IFormModalProps) => IComponent;
`;

// Métodos expuestos para control via script
const FORM_MODAL_CONTEXT_EVENTS_DEFINITION = `
interface IFormModalExposedMethods {
  open: () => void;
  close: () => void;
}

interface IFormModalMap {
  [id: string]: IFormModalExposedMethods;
}
`;

export const FORM_MODAL_CONTEXT_EVENT = {
  key: "formModal",
  name: "IFormModalMap",
  definition: FORM_MODAL_CONTEXT_EVENTS_DEFINITION,
};


============================================================
FILE_PATH: src\features\engine\modules\components\formModal\index.ts
============================================================
import { IComponentModule } from "../../types/IComponentModule";
import { FormModal } from "./form-modal.builder";
import { DynamicFormModal } from "./form-modal.component";
import {
  FORM_MODAL_CONTEXT_EVENT,
  FORM_MODAL_TYPE_DEFINITION,
} from "./form-modal.definition";

export const FORM_MODAL: IComponentModule = {
  name: "FormModal",
  component: DynamicFormModal,
  builder: FormModal,
  eventsDefinition: FORM_MODAL_CONTEXT_EVENT,
  builderDefinition: FORM_MODAL_TYPE_DEFINITION,
};


============================================================
FILE_PATH: src\features\engine\modules\components\fragment\fragment.builder.ts
============================================================
import { IComponent } from "../../types/component.type";
import { FragmentFactory } from "./fragment.definition";

export const Fragment: FragmentFactory = (
  { id, context },
  children = [] // Segundo argumento: Array de hijos
): IComponent => {
  return {
    id,
    type: "Fragment",
    context,
    config: {}, // Vacío intencionalmente
    data: {}, // Vacío intencionalmente
    events: {}, // Vacío intencionalmente
    subComponents: children,
  };
};


============================================================
FILE_PATH: src\features\engine\modules\components\fragment\fragment.component.tsx
============================================================
import { ReactNode } from "react";
import { IComponent, IContext } from "../../types/component.type";
import { IFragmentProps } from "./fragment.definition";

/**
 * Renderiza un React Fragment (<>...</>).
 * Asume que el Engine procesa 'subComponents' y los pasa como 'children'.
 */
export const DynamicFragment = ({
  children,
}: IComponent &
  IFragmentProps & { context: IContext; children: ReactNode }) => {
  return <>{children}</>;
};


============================================================
FILE_PATH: src\features\engine\modules\components\fragment\fragment.definition.ts
============================================================
import { IComponent, IContext } from "../../types/component.type";

// --- 1. Props Principales ---

/**
 * Propiedades del Fragmento.
 * Los fragmentos son contenedores lógicos y no tienen configuración visual ni eventos.
 */
export interface IFragmentProps {
  id: string;
  context?: IContext;
}

// Factory: Recibe props y el array de hijos
export type FragmentFactory = (
  props: IFragmentProps,
  children?: IComponent[]
) => IComponent;

// --- 2. Definiciones para el Editor (Strings) ---

export const FRAGMENT_TYPE_DEFINITION = `
interface IFragmentProps {
  id: string;
}

/**
 * Crea un Fragmento (agrupador lógico sin nodo DOM).
 * @param props Datos básicos (id)
 * @param children Lista de componentes hijos
 */
declare const Fragment: (props: IFragmentProps, children?: IComponent[]) => IComponent;
`;

// No hay eventos de contexto para fragments usualmente
export const FRAGMENT_CONTEXT_EVENT = {
  key: "frag",
  name: "IFragmentMap",
  definition: "", // Sin métodos expuestos
};


============================================================
FILE_PATH: src\features\engine\modules\components\fragment\index.ts
============================================================
import { IComponentModule } from "../../types/IComponentModule";
import { Fragment } from "./fragment.builder";
import { DynamicFragment } from "./fragment.component";
import {
  FRAGMENT_CONTEXT_EVENT,
  FRAGMENT_TYPE_DEFINITION,
} from "./fragment.definition";

export const FRAGMENT: IComponentModule = {
  name: "Fragment",
  component: DynamicFragment,
  builder: Fragment,
  eventsDefinition: FRAGMENT_CONTEXT_EVENT,
  builderDefinition: FRAGMENT_TYPE_DEFINITION,
};


============================================================
FILE_PATH: src\features\engine\modules\components\gallery\gallery.builder.ts
============================================================
import { IComponent } from "../../types/component.type";
import { GalleryFactory } from "./gallery.definition";

export const Gallery: GalleryFactory = ({
  id,
  config = {},
  items,
  context,
  load,
  // Props especiales
  onCardClick,
  addButton,
  contextMenu,
}) => {
  const componentEvents: Record<string, any> = {};

  // 1. Evento Click Principal
  if (onCardClick) componentEvents.onCardClick = onCardClick;

  // 2. Procesar Botón de Agregar
  let internalAddButton: any = undefined;
  if (addButton) {
    componentEvents.onAddClick = addButton.onClick;
    internalAddButton = {
      label: addButton.label,
      icon: addButton.icon,
      variant: addButton.variant,
    };
  }

  // 3. Procesar Menú Contextual
  // Convertimos el array de objetos con 'onClick' a un array de configuración visual
  // y un conjunto de eventos mapeados por índice: onContextAction_0, onContextAction_1...
  const internalContextMenu = contextMenu?.map((item, index) => {
    if ("separator" in item) return { separator: true };

    // Registramos el evento con un ID único basado en el índice
    const eventName = `onContextAction_${index}`;
    componentEvents[eventName] = item.onClick;

    return {
      label: item.label,
      icon: item.icon,
      variant: item.variant,
      // No pasamos onClick aquí, el componente lo deducirá por el índice
    };
  });

  return {
    id,
    type: "Gallery",
    context,
    load,
    data: { items },
    config: {
      searchable: true, // Default
      height: "h-full",
      ...config,
      // Pasamos las configs procesadas internamente
      _addButton: internalAddButton,
      _contextMenu: internalContextMenu,
    },
    events: componentEvents,
  };
};


============================================================
FILE_PATH: src\features\engine\modules\components\gallery\gallery.component.tsx
============================================================
import { useCallback, useMemo, useState } from "react";
import { v4 as uuid } from "uuid";
import Image from "next/image"; // Asegúrate de configurar next.config.js para dominios externos o usa <img />
import { Search } from "lucide-react";

// UI Components
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  ContextMenu,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuTrigger,
  ContextMenuSeparator,
} from "@/components/ui/context-menu";
import { DynamicIcon, IconName } from "@/components/ui/dynamic-icon"; // Tu componente de iconos dinámico

// Engine Hooks
import { useComponentRegistration } from "@/features/engine/hooks/useComponentRegistration";
import { useDynamicValue } from "@/features/engine/hooks/useDynamicValue";
import { useScriptError } from "@/features/engine/hooks/useConnectionError";
import { cn } from "@/lib/utils";

import { IComponent, IContext } from "../../types/component.type";
import { IGalleryProps, IGalleryItem } from "./gallery.definition";

export const DynamicGallery = ({
  config = {},
  events,
  context,
  id,
  data,
}: IComponent & IGalleryProps & { context: IContext }) => {
  const execute = useScriptError();

  // 1. Datos Dinámicos
  const [itemsRef, setItems, items, reloadItems] = useDynamicValue<
    IGalleryItem[]
  >(context, data?.items, []);

  const [searchTerm, setSearchTerm] = useState("");

  // 2. Handlers de Eventos
  const handleCardClick = (item: IGalleryItem) => {
    if (events?.onCardClick) {
      execute(events.onCardClick, item, context);
    }
  };

  const handleAddClick = useCallback(() => {
    if (events?.onAddClick) {
      execute(events.onAddClick, null, context);
    }
  }, [events, execute, context]);

  const handleContextAction = useCallback(
    (index: number, item: IGalleryItem) => {
      // Reconstruimos el nombre del evento basado en el índice
      const eventName = `onContextAction_${index}`;
      if (events && events[eventName]) {
        execute(events[eventName], item, context);
      }
    },
    [events, execute, context]
  );

  // 3. Filtrado
  const filteredItems = useMemo(() => {
    const rawItems = Array.isArray(items) ? items : [];
    const term = searchTerm.toLowerCase();

    return rawItems
      .filter((item) => {
        if (!term) return true;
        return item.title?.toLowerCase().includes(term);
      })
      .map((item) => ({ ...item, id: item.id ?? uuid() })); // Asegurar ID
  }, [items, searchTerm]);

  // 4. API Expuesta
  const exposedMethods = useMemo(
    () => ({
      setItems: (newItems: IGalleryItem[]) => setItems(newItems),
      getItems: () => itemsRef.current,
      reload: () => reloadItems(),
    }),
    [setItems, itemsRef, reloadItems]
  );

  useComponentRegistration(context, "gallery", id, exposedMethods);

  // 5. Variables de Renderizado
  const { _addButton, _contextMenu } = config;
  const sizeClass = config.cardSize || "w-80 h-44"; // Default size
  const containerHeight = config.height || "h-full";

  return (
    <div
      className={cn(
        "flex flex-col gap-6 min-h-0 overflow-hidden",
        containerHeight,
        config.className
      )}
      style={config.style?.gallery}
    >
      {/* Header: Buscador + Botón Agregar */}
      {(config.searchable !== false || _addButton) && (
        <div className="flex-none flex justify-center items-center gap-2 w-full px-5 pt-6">
          {config.searchable !== false && (
            <div className="relative w-full max-w-md">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
              <Input
                placeholder="Buscar..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="pl-9 bg-background/50 border-muted-foreground/20 focus:border-primary transition-colors"
              />
            </div>
          )}

          {_addButton && (
            <Button
              onClick={handleAddClick}
              className="gap-2 shrink-0"
              variant={_addButton.variant as any}
            >
              {_addButton.icon ? (
                <DynamicIcon
                  name={_addButton.icon as IconName}
                  className="h-4 w-4"
                />
              ) : (
                <DynamicIcon name="Plus" className="h-4 w-4" />
              )}
              <span className="hidden sm:inline">{_addButton.label}</span>
            </Button>
          )}
        </div>
      )}

      {/* Grid de Contenido */}
      <ScrollArea className="flex-1 h-full w-full rounded-md border border-border/40 bg-background/50">
        <div className="p-6 mb-20">
          <div className="flex flex-wrap gap-5 content-start justify-center sm:justify-start">
            {filteredItems.map((item) => (
              <ContextMenu key={item.id}>
                <ContextMenuTrigger asChild>
                  <Card
                    className={cn(
                      "group relative flex flex-row items-center justify-center overflow-hidden px-3",
                      "border border-border/50 bg-card",
                      "hover:shadow-xl hover:border-primary/20",
                      "transition-all duration-300 ease-in-out cursor-pointer",
                      "flex-none shrink-0",
                      sizeClass
                    )}
                    style={config.style?.card}
                    onClick={() => handleCardClick(item)}
                  >
                    {/* Imagen */}
                    <div className="relative overflow-hidden bg-muted flex place-content-center shrink-0 rounded-md size-32">
                      {item.imageUrl ? (
                        <Image
                          src={item.imageUrl}
                          alt={item.title}
                          fill
                          unoptimized // Recomendado para URLs dinámicas externas
                          className="object-cover transition-transform duration-500 group-hover:scale-110 rounded-md"
                          style={config.style?.img}
                        />
                      ) : (
                        <div className="flex items-center justify-center h-full w-full text-muted-foreground">
                          <DynamicIcon
                            name="Image"
                            className="h-8 w-8 opacity-20"
                          />
                        </div>
                      )}
                    </div>

                    {/* Contenido Texto */}
                    <div className="p-4 flex flex-col justify-center bg-card z-10 flex-1 min-w-0">
                      <h3
                        className="font-semibold text-base leading-tight truncate text-foreground group-hover:text-primary transition-colors"
                        title={item.title}
                        style={config.style?.title}
                      >
                        {item.title}
                      </h3>
                      {item.description && (
                        <p
                          className="text-sm text-muted-foreground mt-1 line-clamp-3 leading-snug wrap-break-word"
                          style={config.style?.description}
                        >
                          {item.description}
                        </p>
                      )}
                    </div>
                  </Card>
                </ContextMenuTrigger>

                {/* Context Menu Dinámico */}
                {_contextMenu && _contextMenu.length > 0 && (
                  <ContextMenuContent className="w-48">
                    {_contextMenu.map((menuItem, index) => {
                      if (menuItem.separator) {
                        return <ContextMenuSeparator key={index} />;
                      }

                      const isDestructive = menuItem.variant === "destructive";

                      return (
                        <ContextMenuItem
                          key={index}
                          className={cn(
                            "cursor-pointer",
                            isDestructive &&
                              "text-red-600 focus:text-red-600 focus:bg-red-100/10"
                          )}
                          onClick={(e) => {
                            e.stopPropagation();
                            handleContextAction(index, item);
                          }}
                        >
                          {menuItem.icon && (
                            <DynamicIcon
                              name={menuItem.icon as IconName}
                              className="mr-2 h-4 w-4"
                            />
                          )}
                          <span>{menuItem.label}</span>
                        </ContextMenuItem>
                      );
                    })}
                  </ContextMenuContent>
                )}
              </ContextMenu>
            ))}

            {/* Empty State */}
            {filteredItems.length === 0 && (
              <div className="w-full flex flex-col items-center justify-center py-12 text-muted-foreground border-2 border-dashed rounded-lg opacity-50">
                <Search className="h-8 w-8 mb-2" />
                <p>No se encontraron resultados.</p>
              </div>
            )}
          </div>
        </div>
      </ScrollArea>
    </div>
  );
};


============================================================
FILE_PATH: src\features\engine\modules\components\gallery\gallery.definition.ts
============================================================
import {
  IComponent,
  IComponentEvent,
  IContext,
  IComponentData,
} from "../../types/component.type";

// --- 1. Datos del Item ---

export interface IGalleryItem {
  id: string;
  title: string;
  description?: string;
  imageUrl?: string;
  /** Datos extra para scripts */
  [key: string]: any;
}

// --- 2. Configuración de Acciones (Add Button & Context Menu) ---

export interface IContextMenuItem {
  label: string;
  /** Nombre del icono (ej: "Trash", "Edit") */
  icon?: string;
  variant?: "default" | "destructive";
  /** Evento al hacer click en la opción */
  onClick: IComponentEvent;
}

export interface IAddButtonConfig {
  label: string;
  icon?: string;
  variant?:
    | "default"
    | "outline"
    | "secondary"
    | "destructive"
    | "ghost"
    | "link";
  /** Evento al hacer click en agregar */
  onClick: IComponentEvent;
}

// --- 3. Configuración Visual ---

export interface IGalleryConfig {
  className?: string;
  /** Altura del contenedor (ej: "h-[500px]") */
  height?: string;
  /** Tamaño de las tarjetas (ej: "w-[300px] h-[200px]") */
  cardSize?: string;
  /** Activar barra de búsqueda interna */
  searchable?: boolean;

  /** Estilos granulares */
  style?: {
    gallery?: React.CSSProperties;
    card?: React.CSSProperties;
    img?: React.CSSProperties;
    title?: React.CSSProperties;
    description?: React.CSSProperties;
  };

  // Configuración interna generada por el Builder (no tocar manualmente)
  _addButton?: Omit<IAddButtonConfig, "onClick">;
  _contextMenu?: Array<
    Omit<IContextMenuItem, "onClick"> & { separator?: boolean }
  >;
}

// --- 4. Datos Dinámicos ---

export interface IGalleryData {
  items?: IComponentData<IGalleryItem[]>;
}

// --- 5. Eventos y Props Principales ---

export interface IGalleryProps extends IGalleryData {
  id: string;
  config?: IGalleryConfig;
  context?: IContext;
  load?: () => void;

  // Evento principal
  onCardClick?: IComponentEvent;

  // Configuración Avanzada (se procesa en el Builder)
  addButton?: IAddButtonConfig;
  contextMenu?: (IContextMenuItem | { separator: true })[];
}

export type GalleryFactory = (props: IGalleryProps) => IComponent;

// --- 6. Definiciones para el Editor (Strings) ---

export const GALLERY_TYPE_DEFINITION = `
type GalleryItem = {
  id: string;
  title: string;
  description?: string;
  imageUrl?: string;
};

interface IContextMenuItem {
  label: string;
  icon?: string;
  variant?: "default" | "destructive";
  onClick: IComponentEvent;
}

interface IAddButtonConfig {
  label: string;
  icon?: string;
  variant?: "default" | "outline";
  onClick: IComponentEvent;
}

interface IGalleryConfig {
  className?: string;
  height?: string;
  cardSize?: string;
  searchable?: boolean;
  style?: {
    gallery?: Record<string, any>;
    card?: Record<string, any>;
    img?: Record<string, any>;
    title?: Record<string, any>;
    description?: Record<string, any>;
  };
}

interface IGalleryProps {
  id: string;
  items?: IComponentData<GalleryItem[]>;
  config?: IGalleryConfig;
  
  // Eventos
  onCardClick?: IComponentEvent;
  
  // Acciones Avanzadas
  addButton?: IAddButtonConfig;
  contextMenu?: (IContextMenuItem | { separator: true })[];
}

/**
 * Crea una Galería de tarjetas con búsqueda, acciones y menú contextual.
 */
declare const Gallery: (props: IGalleryProps) => IComponent;
`;

const GALLERY_CONTEXT_EVENTS_DEFINITION = `
interface IGalleryExposedMethods {
  /** Reemplaza los items de la galería */
  setItems: (items: GalleryItem[]) => void;
  /** Obtiene los items actuales */
  getItems: () => GalleryItem[];
  /** Recarga los datos si provienen de una fuente externa */
  reload: () => void;
}

interface IGalleryMap {
  [id: string]: IGalleryExposedMethods;
}
`;

export const GALLERY_CONTEXT_EVENT = {
  key: "gallery",
  name: "IGalleryMap",
  definition: GALLERY_CONTEXT_EVENTS_DEFINITION,
};


============================================================
FILE_PATH: src\features\engine\modules\components\gallery\index.ts
============================================================
import { IComponentModule } from "../../types/IComponentModule";
import { Gallery } from "./gallery.builder";
import { DynamicGallery } from "./gallery.component";
import {
  GALLERY_CONTEXT_EVENT,
  GALLERY_TYPE_DEFINITION,
} from "./gallery.definition";

export const GALLERY: IComponentModule = {
  name: "Gallery",
  component: DynamicGallery,
  builder: Gallery,
  eventsDefinition: GALLERY_CONTEXT_EVENT,
  builderDefinition: GALLERY_TYPE_DEFINITION,
};


============================================================
FILE_PATH: src\features\engine\modules\components\layout\index.ts
============================================================
import { IComponentModule } from "../../types/IComponentModule";
import { Layout } from "./layout.builder";
import { DynamicLayout } from "./layout.component";
import {
  LAYOUT_CONTEXT_EVENT,
  LAYOUT_TYPE_DEFINITION,
} from "./layout.definition";

export const LAYOUT: IComponentModule = {
  name: "Layout",
  component: DynamicLayout,
  builder: Layout,
  eventsDefinition: LAYOUT_CONTEXT_EVENT,
  builderDefinition: LAYOUT_TYPE_DEFINITION,
};


============================================================
FILE_PATH: src\features\engine\modules\components\layout\layout.builder.ts
============================================================
import { IComponent } from "../../types/component.type";
import { ILayoutProps, LayoutFactory } from "./layout.definition";

export const Layout: LayoutFactory = (
  {
    id,
    config = {},
    context,
    // Eventos planos
    onClick,
    onMouseEnter,
    onMouseLeave,
  }: ILayoutProps,
  children = [] // Segundo argumento: Array de componentes hijos
): IComponent => {
  // Construcción dinámica de eventos
  const componentEvents: Record<string, any> = {};
  if (onClick) componentEvents.onClick = onClick;
  if (onMouseEnter) componentEvents.onMouseEnter = onMouseEnter;
  if (onMouseLeave) componentEvents.onMouseLeave = onMouseLeave;

  return {
    id,
    type: "Layout", // Debe coincidir con el nombre en index.ts
    context,
    config: {
      ...config,
    },
    data: {}, // Layout usualmente no tiene data compleja
    events: componentEvents,
    subComponents: children, // Aquí se asignan los hijos
  };
};


============================================================
FILE_PATH: src\features\engine\modules\components\layout\layout.component.tsx
============================================================
import { ReactNode, useMemo } from "react";
import { useScriptError } from "@/features/engine/hooks/useConnectionError";
import { useComponentRegistration } from "@/features/engine/hooks/useComponentRegistration";
import { cn } from "@/lib/utils"; // Utilidad recomendada para clases
import { IComponent, IContext } from "../../types/component.type";
import { ILayoutProps } from "./layout.definition";

export const DynamicLayout = ({
  config = {},
  events,
  children,
  context,
  id,
}: IComponent & ILayoutProps & { context: IContext; children: ReactNode }) => {
  const execute = useScriptError();

  // 1. Helper de eventos
  const handleEvent = (eventName: string, e: any) => {
    // Evita propagación si es un contenedor interactivo, opcionalmente
    // e.stopPropagation();
    if (events && events[eventName]) {
      execute(events[eventName], e, context);
    }
  };

  // 2. Registro del componente (aunque no tenga métodos, es buena práctica registrarlo)
  const exposedMethods = useMemo(() => ({}), []);
  useComponentRegistration(context, "layout", id, exposedMethods);

  // 3. Clases dinámicas
  const isInteractive = !!events?.onClick;

  return (
    <div
      id={config.htmlId}
      className={cn(
        config.className,
        isInteractive && "cursor-pointer" // Feedback visual básico
      )}
      style={config.style}
      onClick={(e) => handleEvent("onClick", e)}
      onMouseEnter={(e) => handleEvent("onMouseEnter", e)}
      onMouseLeave={(e) => handleEvent("onMouseLeave", e)}
    >
      {children}
    </div>
  );
};


============================================================
FILE_PATH: src\features\engine\modules\components\layout\layout.definition.ts
============================================================
import {
  IComponent,
  IComponentEvent,
  IContext,
} from "../../types/component.type";

// --- 1. Configuración ---

/**
 * Configuración visual del contenedor (Layout).
 */
export interface ILayoutConfig {
  /** Clases CSS (Tailwind) */
  className?: string;
  /** Estilos en línea */
  style?: React.CSSProperties;
  /** ID para anclas de navegación o pruebas */
  htmlId?: string;
}

// --- 2. Eventos (Estructura Plana para DX) ---

export interface ILayoutEvents {
  /** Click en el contenedor */
  onClick?: IComponentEvent;
  onMouseEnter?: IComponentEvent;
  onMouseLeave?: IComponentEvent;
}

// --- 3. Props Principales ---

/**
 * Propiedades del Layout.
 * Nota: Los hijos (children) se pasan como segundo argumento en el Builder.
 */
export interface ILayoutProps extends ILayoutEvents {
  id: string;
  config?: ILayoutConfig;
  context?: IContext;
}

// Definimos el Factory que acepta props y un array de hijos
export type LayoutFactory = (
  props: ILayoutProps,
  children?: IComponent[]
) => IComponent;

// --- 4. Definiciones para el Editor (Strings) ---

export const LAYOUT_TYPE_DEFINITION = `
interface ILayoutConfig {
  className?: string;
  /** Estilos CSS. Ej: { display: 'flex', gap: '10px' } */
  style?: Record<string, any>;
  htmlId?: string;
}

interface ILayoutProps {
  id: string;
  config?: ILayoutConfig;
  
  // Eventos
  onClick?: IComponentEvent;
  onMouseEnter?: IComponentEvent;
  onMouseLeave?: IComponentEvent;
}

/** * Crea un contenedor Layout.
 * @param props Configuración e ID
 * @param children Lista de componentes hijos
 */
declare const Layout: (props: ILayoutProps, children?: IComponent[]) => IComponent;
`;

// Contexto (Por si en el futuro quieres exponer métodos como scrollTo)
const LAYOUT_CONTEXT_EVENTS_DEFINITION = `
interface ILayoutExposedMethods {
  // Puedes agregar métodos aquí en el futuro (ej: scrollIntoView)
}

interface ILayoutMap {
  [id: string]: ILayoutExposedMethods;
}
`;

export const LAYOUT_CONTEXT_EVENT = {
  key: "layout",
  name: "ILayoutMap",
  definition: LAYOUT_CONTEXT_EVENTS_DEFINITION,
};


============================================================
FILE_PATH: src\features\engine\modules\components\loadingModal\index.ts
============================================================
import { IComponentModule } from "../../types/IComponentModule";
import { LoadingModal } from "./loading-modal.builder";
import { DynamicLoadingModal } from "./loading-modal.component";
import {
  LOADING_MODAL_CONTEXT_EVENT,
  LOADING_MODAL_TYPE_DEFINITION,
} from "./loading-modal.definition";

export const LOADING_MODAL: IComponentModule = {
  name: "LoadingModal",
  component: DynamicLoadingModal,
  builder: LoadingModal,
  eventsDefinition: LOADING_MODAL_CONTEXT_EVENT,
  builderDefinition: LOADING_MODAL_TYPE_DEFINITION,
};


============================================================
FILE_PATH: src\features\engine\modules\components\loadingModal\loading-modal.builder.ts
============================================================
import { IComponent } from "../../types/component.type";
import { LoadingModalFactory } from "./loading-modal.definition";

export const LoadingModal: LoadingModalFactory = ({
  id,
  config = {},
  context,
  load,
  // Eventos planos
  onOpen,
  onClose,
}): IComponent => {
  // Construcción de eventos
  const componentEvents: Record<string, any> = {};

  if (onOpen) componentEvents.onOpen = onOpen;
  if (onClose) componentEvents.onClose = onClose;

  return {
    id,
    type: "LoadingModal",
    context,
    load,
    config: {
      ...config,
    },
    data: {},
    events: componentEvents,
    subComponents: [],
  };
};


============================================================
FILE_PATH: src\features\engine\modules\components\loadingModal\loading-modal.component.tsx
============================================================
import { useMemo } from "react";
import { useScriptError } from "@/features/engine/hooks/useConnectionError"; // Ajusta ruta
import { useComponentRegistration } from "@/features/engine/hooks/useComponentRegistration"; // Ajusta ruta
import { LoadingModal as SharedLoadingModal } from "@/components/shared/modals/LoadingModal"; // Ajusta ruta
import { IComponent, IContext } from "../../types/component.type";
import { ILoadingModalProps } from "./loading-modal.definition";

export const DynamicLoadingModal = ({
  config = {},
  events,
  id,
  context,
}: IComponent & ILoadingModalProps & { context: IContext }) => {
  const execute = useScriptError();

  // 1. Handlers de eventos
  const handleOnOpen = async () => {
    if (events?.onOpen) {
      await execute(events.onOpen, undefined, context);
    }
  };

  const handleOnClose = async () => {
    if (events?.onClose) {
      await execute(events.onClose, undefined, context);
    }
  };

  // 2. Registro de métodos en el contexto (API para scripts)
  // Nota: Aquí deberías conectar tu lógica real de abrir/cerrar si usas un store global (Zustand/Redux)
  // Si no usas store y lo controlas por props, estos métodos podrían no hacer nada o necesitarías un estado local.
  const exposedMethods = useMemo(
    () => ({
      open: (data?: { message?: string; subMessage?: string }) => {
        console.log("Open loading modal via script", id, data);
        // Aquí iría tu lógica: openModal(id, data)
      },
      close: () => {
        console.log("Close loading modal via script", id);
        // Aquí iría tu lógica: closeModal(id)
      },
    }),
    [id]
  );

  useComponentRegistration(context, "loading", id, exposedMethods);

  // 3. Renderizado
  return (
    <SharedLoadingModal
      id={id}
      {...config}
      className={config.className} // Aseguramos que className pase si config lo tiene
      onOpen={handleOnOpen}
      onClose={handleOnClose}
    />
  );
};


============================================================
FILE_PATH: src\features\engine\modules\components\loadingModal\loading-modal.definition.ts
============================================================
import {
  IComponent,
  IComponentEvent,
  IContext,
} from "../../types/component.type";

// --- 1. Configuración ---

export interface ILoadingModalConfig {
  /** Clases CSS adicionales */
  className?: string;
  /** Estilos en línea */
  style?: React.CSSProperties;
  /** Título del mensaje de carga */
  title?: string;
  /** Subtítulo o descripción */
  description?: string;
  /** Evitar cerrar con tecla ESC */
  disableEscape?: boolean;
  /** Evitar cerrar al hacer clic fuera */
  disableOutside?: boolean;
}

// --- 2. Eventos (Planos) ---

export interface ILoadingModalEvents {
  /** Se ejecuta cuando el modal se abre */
  onOpen?: IComponentEvent;
  /** Se ejecuta cuando el modal se cierra */
  onClose?: IComponentEvent;
}

// --- 3. Props Principales ---

export interface ILoadingModalProps extends ILoadingModalEvents {
  id: string;
  config?: ILoadingModalConfig;
  context?: IContext;
  load?: () => void;
}

export type LoadingModalFactory = (props: ILoadingModalProps) => IComponent;

// --- 4. Definiciones para el Editor (Strings) ---

export const LOADING_MODAL_TYPE_DEFINITION = `
interface ILoadingModalConfig {
  className?: string;
  style?: Record<string, any>;
  title?: string;
  description?: string;
  disableEscape?: boolean;
  disableOutside?: boolean;
}

interface ILoadingModalProps {
  id: string;
  config?: ILoadingModalConfig;
  
  // Eventos
  onOpen?: IComponentEvent;
  onClose?: IComponentEvent;
}

/**
 * Crea un Modal de Carga.
 * Bloquea la interacción del usuario mientras se realiza una operación.
 */
declare const LoadingModal: (props: ILoadingModalProps) => IComponent;
`;

// Definición de métodos expuestos (útil para scripts: loading.open(), loading.close())
const LOADING_MODAL_CONTEXT_EVENTS_DEFINITION = `
interface ILoadingModalExposedMethods {
  open: (data?: { message?: string; subMessage?: string }) => void;
  close: () => void;
}

interface ILoadingModalMap {
  [id: string]: ILoadingModalExposedMethods;
}
`;

export const LOADING_MODAL_CONTEXT_EVENT = {
  key: "loading",
  name: "ILoadingModalMap",
  definition: LOADING_MODAL_CONTEXT_EVENTS_DEFINITION,
};


============================================================
FILE_PATH: src\features\engine\modules\components\navigation\index.ts
============================================================
import { IComponentModule } from "../../types/IComponentModule";
import { Navigation } from "./navigation.builder";
import { DynamicNavigation } from "./navigation.component";
import {
  NAVIGATION_CONTEXT_EVENT,
  NAVIGATION_TYPE_DEFINITION,
} from "./navigation.definition";

export const NAVIGATION: IComponentModule = {
  name: "Navigation",
  component: DynamicNavigation,
  builder: Navigation,
  eventsDefinition: NAVIGATION_CONTEXT_EVENT,
  builderDefinition: NAVIGATION_TYPE_DEFINITION,
};


============================================================
FILE_PATH: src\features\engine\modules\components\navigation\navigation.builder.ts
============================================================
import { IComponent } from "../../types/component.type";
import { NavigationFactory } from "./navigation.definition";

export const Navigation: NavigationFactory = ({
  id,
  config = {},
  routes,
  context,
  load,
  // Eventos planos
  onNavigate,
}): IComponent => {
  // Construcción de eventos
  const componentEvents: Record<string, any> = {};
  if (onNavigate) componentEvents.onNavigate = onNavigate;

  return {
    id,
    type: "Navigation",
    context,
    load,
    data: { routes },
    config: {
      homeLabel: "Inicio",
      showTabs: true,
      showBreadcrumb: true,
      ...config,
    },
    events: componentEvents,
  };
};


============================================================
FILE_PATH: src\features\engine\modules\components\navigation\navigation.component.tsx
============================================================
import { JSX, useEffect, useMemo, useState } from "react";
import { v4 as uuid } from "uuid";
import { ChevronRight } from "lucide-react";

// Imports de UI (ajusta rutas según tu proyecto)
import {
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPage,
} from "@/components/ui/breadcrumb";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";

// Imports de Engine
import { useComponentRegistration } from "@/features/engine/hooks/useComponentRegistration";
import { useScriptError } from "@/features/engine/hooks/useConnectionError";
import { IComponent, IContext } from "../../types/component.type";
import { INavigationProps, INavigationRoute } from "./navigation.definition";
import {
  DynamicComponent,
  RecursiveComponent,
} from "@/features/engine/components/DynamicComponent";

// --- Helpers de Lógica de Rutas ---

const findRouteTrail = (
  allRoutes: INavigationRoute[],
  pathString: string
): INavigationRoute[] => {
  if (!pathString) return [];
  const ids = pathString.split("/");
  const trail: INavigationRoute[] = [];
  let currentLevel = allRoutes;

  for (const id of ids) {
    const found = currentLevel.find((r) => r.id === id);
    if (!found) break;
    trail.push(found);
    if (found.subRoutes) {
      currentLevel = found.subRoutes;
    } else {
      break;
    }
  }
  return trail;
};

const resolveEffectivePath = (
  allRoutes: INavigationRoute[],
  inputPath: string
): string => {
  const trail = findRouteTrail(allRoutes, inputPath);

  if (trail.length === 0) return "";

  let lastNode = trail[trail.length - 1];
  let effectivePath = inputPath;

  // Si es un nodo intermedio sin hijos visuales pero con subrutas, bajar al primer hijo
  while (
    (!lastNode.children || lastNode.children.length === 0) &&
    lastNode.subRoutes &&
    lastNode.subRoutes.length > 0
  ) {
    const firstChild = lastNode.subRoutes[0];
    effectivePath = `${effectivePath}/${firstChild.id}`;
    lastNode = firstChild;
    trail.push(firstChild);
  }

  return effectivePath;
};

// --- Componente Principal ---

export const DynamicNavigation = ({
  config = {},
  events,
  context,
  id,
  data,
  componentMap,
}: IComponent &
  INavigationProps & {
    context: IContext;
    componentMap: Record<string, (...data: any) => JSX.Element>;
  }) => {
  const execute = useScriptError();
  const routes = data?.routes || [];

  // --- Estado Inicial (URL Hash o Default) ---
  const [currentPath, setCurrentPath] = useState<string>(() => {
    if (typeof window !== "undefined") {
      const hash = window.location.hash.replace("#", "");
      if (hash) {
        const effective = resolveEffectivePath(routes, hash);
        if (effective) {
          if (effective !== hash) {
            window.history.replaceState(null, "", `#${effective}`);
          }
          return effective;
        }
      }
    }
    const defaultRoute = routes[0];
    const defaultEffective = resolveEffectivePath(
      routes,
      defaultRoute?.id || ""
    );
    return defaultEffective;
  });

  const [routeData, setRouteData] = useState<any>(() => {
    if (typeof window !== "undefined") return window.history.state || null;
    return null;
  });

  // --- Cálculos Derivados ---
  const activeTrail = useMemo(
    () => findRouteTrail(routes, currentPath),
    [routes, currentPath]
  );

  const activeNode = activeTrail[activeTrail.length - 1];

  // --- Lógica de Navegación ---
  const navigateTo = (
    route: INavigationRoute,
    parentPath: string = "",
    extraData: any = null
  ) => {
    const targetPath = parentPath ? `${parentPath}/${route.id}` : route.id;
    const effectivePath = resolveEffectivePath(routes, targetPath);

    if (
      effectivePath === currentPath &&
      JSON.stringify(extraData) === JSON.stringify(routeData)
    )
      return;

    window.history.pushState(extraData, "", `#${effectivePath}`);
    setCurrentPath(effectivePath);
    setRouteData(extraData);

    // Disparar evento de script
    if (events?.onNavigate) {
      execute(events.onNavigate, effectivePath, context);
    }
  };

  // --- Efectos: Escuchar cambios de URL (Popstate/Hashchange) ---
  useEffect(() => {
    const handleLocationChange = (e?: PopStateEvent | HashChangeEvent) => {
      const hash = window.location.hash.replace("#", "");
      const effective = resolveEffectivePath(routes, hash);

      if (effective) {
        setCurrentPath(effective);
        const newState =
          e && "state" in e ? (e as PopStateEvent).state : window.history.state;
        setRouteData(newState);
      } else if (!hash && routes.length > 0) {
        // Fallback a home si se borra el hash
        const defaultEffective = resolveEffectivePath(routes, routes[0].id);
        setCurrentPath(defaultEffective);
        setRouteData(null);
      }
    };

    window.addEventListener("popstate", handleLocationChange);
    window.addEventListener("hashchange", handleLocationChange);

    return () => {
      window.removeEventListener("popstate", handleLocationChange);
      window.removeEventListener("hashchange", handleLocationChange);
    };
  }, [routes]);

  // --- Registro de API Pública (nav.navigate...) ---
  const exposedMethods = useMemo(
    () => ({
      navigate: (path: string, payload?: any) => {
        const effective = resolveEffectivePath(routes, path);
        if (effective) {
          window.history.pushState(payload || null, "", `#${effective}`);
          setCurrentPath(effective);
          setRouteData(payload || null);
        }
      },
      getCurrentPath: () => currentPath,
      getRouteData: () => routeData,
    }),
    [currentPath, routeData, routes]
  );

  useComponentRegistration(context, "nav", id, exposedMethods);

  // --- Renderizado de Capas de Navegación (Tabs) ---
  const navigationLayers = useMemo(() => {
    const layers = [routes];
    activeTrail.forEach((node) => {
      if (node.subRoutes && node.subRoutes.length > 0) {
        layers.push(node.subRoutes);
      }
    });
    return layers;
  }, [routes, activeTrail]);

  // --- Renderizado de Contenido Activo ---
  const activeContent = useMemo(() => {
    if (!activeNode?.children) return null;
    return (
      <div
        key={currentPath} // Forzar re-mount para animación
        className="animate-in fade-in zoom-in-95 duration-200 h-full"
      >
        {activeNode.children.map((item) => {
          const componentData = { ...item, id: item.id || uuid() };
          return (
            <RecursiveComponent
              key={componentData.id}
              data={componentData}
              componentMap={componentMap}
              context={context}
            />
          );
        })}
      </div>
    );
  }, [activeNode, currentPath, context, componentMap]);

  // --- Renderizado Final ---
  const showBreadcrumb = config.showBreadcrumb !== false;
  const showTabs = config.showTabs !== false;
  const showHeader = showBreadcrumb || showTabs;

  return (
    <div
      className={cn("flex flex-col gap-4 w-full h-full", config.className)}
      style={config.style}
    >
      {showHeader && (
        <div className="flex flex-col gap-3 border-b pb-4 bg-background/95 backdrop-blur sticky top-0 z-20 px-1 pt-2">
          {/* Breadcrumb Area */}
          {showBreadcrumb && (
            <Breadcrumb>
              <BreadcrumbList>
                <BreadcrumbItem>
                  <BreadcrumbLink
                    className="cursor-pointer hover:text-primary transition-colors"
                    onClick={() => navigateTo(routes[0])}
                  >
                    {config.homeLabel || "Inicio"}
                  </BreadcrumbLink>
                </BreadcrumbItem>

                {activeTrail.map((node, index) => {
                  const isLast = index === activeTrail.length - 1;
                  const pathUntilHere = activeTrail
                    .slice(0, index + 1)
                    .map((n) => n.id)
                    .join("/");

                  return (
                    <div
                      key={node.id}
                      className="flex items-center gap-1.5 text-muted-foreground/60"
                    >
                      <ChevronRight className="h-4 w-4" />
                      <BreadcrumbItem>
                        {isLast ? (
                          <BreadcrumbPage className="font-semibold text-primary">
                            {node.label}
                          </BreadcrumbPage>
                        ) : (
                          <BreadcrumbLink
                            className="cursor-pointer hover:text-foreground transition-colors"
                            onClick={() => {
                              // Navegación manual vía breadcrumb
                              window.history.pushState(
                                null,
                                "",
                                `#${pathUntilHere}`
                              );
                              setCurrentPath(pathUntilHere);
                              setRouteData(null);
                            }}
                          >
                            {node.label}
                          </BreadcrumbLink>
                        )}
                      </BreadcrumbItem>
                    </div>
                  );
                })}
              </BreadcrumbList>
            </Breadcrumb>
          )}

          {/* Tabs Area */}
          {showTabs && (
            <div className="flex flex-col gap-2">
              {navigationLayers.map((layerRoutes, layerIndex) => {
                const isRoot = layerIndex === 0;
                // Calculamos el padre de esta capa para construir rutas relativas
                const parentPath = activeTrail
                  .slice(0, layerIndex)
                  .map((n) => n.id)
                  .join("/");

                return (
                  <div
                    key={layerIndex}
                    className={cn(
                      "flex flex-wrap gap-2 transition-all animate-in slide-in-from-left-2 duration-300",
                      !isRoot && "pl-2 border-l-2 border-border/50 ml-1"
                    )}
                  >
                    {layerRoutes.map((route) => {
                      const isActive = activeTrail[layerIndex]?.id === route.id;
                      return (
                        <Button
                          key={route.id}
                          variant={
                            isActive
                              ? isRoot
                                ? "default"
                                : "secondary"
                              : "ghost"
                          }
                          size={isRoot ? "default" : "sm"}
                          onClick={() => navigateTo(route, parentPath, null)}
                          className={cn(
                            "transition-all",
                            !isRoot && "h-7 text-xs",
                            isActive && "shadow-sm"
                          )}
                        >
                          {route.label}
                        </Button>
                      );
                    })}
                  </div>
                );
              })}
            </div>
          )}
        </div>
      )}

      {/* Main Content Area */}
      <div className="flex-1 min-h-0 overflow-auto relative">
        {activeContent}
      </div>
    </div>
  );
};


============================================================
FILE_PATH: src\features\engine\modules\components\navigation\navigation.definition.ts
============================================================
import {
  IComponent,
  IComponentEvent,
  IContext,
} from "../../types/component.type";

// --- 1. Definición de Rutas (Recursiva) ---

export interface INavigationRoute {
  id: string;
  label: string;
  icon?: string;
  /** Componentes a renderizar cuando esta ruta está activa */
  children?: IComponent[];
  /** Sub-rutas anidadas */
  subRoutes?: INavigationRoute[];
}

// --- 2. Configuración ---

export interface INavigationConfig {
  className?: string;
  style?: React.CSSProperties;
  /** Etiqueta para el enlace de inicio en el breadcrumb */
  homeLabel?: string;
  /** Mostrar pestañas de navegación */
  showTabs?: boolean;
  /** Mostrar migas de pan (breadcrumb) */
  showBreadcrumb?: boolean;
}

// --- 3. Datos ---

export interface INavigationData {
  routes: INavigationRoute[];
}

// --- 4. Eventos (Planos) ---

export interface INavigationEvents {
  /** Se ejecuta al cambiar de ruta. Recibe el path como argumento. */
  onNavigate?: IComponentEvent;
}

// --- 5. Props Principales ---

export interface INavigationProps extends INavigationData, INavigationEvents {
  id: string;
  config?: INavigationConfig;
  context?: IContext;
  load?: () => void;
}

export type NavigationFactory = (props: INavigationProps) => IComponent;

// --- 6. Definiciones para el Editor (Strings) ---

export const NAVIGATION_TYPE_DEFINITION = `
type NavigationRoute = {
  id: string;
  label: string;
  icon?: string;
  children?: Component[];
  subRoutes?: NavigationRoute[];
};

interface INavigationConfig {
  className?: string;
  style?: Record<string, any>;
  homeLabel?: string;
  showTabs?: boolean;
  showBreadcrumb?: boolean;
}

interface INavigationProps {
  id: string;
  routes: NavigationRoute[];
  config?: INavigationConfig;
  
  // Eventos
  onNavigate?: IComponentEvent;
}

/**
 * Crea un sistema de navegación con soporte para rutas anidadas, tabs y breadcrumbs.
 */
declare const Navigation: (props: INavigationProps) => IComponent;
`;

// API expuesta para scripts (nav.navigate, etc.)
const NAVIGATION_CONTEXT_EVENTS_DEFINITION = `
interface INavigationExposedMethods {
  /** Navega programáticamente a una ruta */
  navigate: (routePath: string, data?: any) => void;
  /** Obtiene la ruta actual (ej: "settings/profile") */
  getCurrentPath: () => string;
  /** Obtiene los datos asociados a la navegación actual */
  getRouteData: () => any;
}

interface INavigationMap {
  [id: string]: INavigationExposedMethods;
}
`;

export const NAVIGATION_CONTEXT_EVENT = {
  key: "nav",
  name: "INavigationMap",
  definition: NAVIGATION_CONTEXT_EVENTS_DEFINITION,
};


============================================================
FILE_PATH: src\features\engine\modules\components\table\index.ts
============================================================
import { IComponentModule } from "../../types/IComponentModule";
import { Table } from "./table.builder";
import { DynamicTable } from "./table.component";
import { TABLE_CONTEXT_EVENT, TABLE_TYPE_DEFINITION } from "./table.definition";

export const TABLE: IComponentModule = {
  name: "Table",
  component: DynamicTable,
  builder: Table,
  eventsDefinition: TABLE_CONTEXT_EVENT,
  builderDefinition: TABLE_TYPE_DEFINITION,
};


============================================================
FILE_PATH: src\features\engine\modules\components\table\table.builder.ts
============================================================
import { IComponent } from "../../types/component.type";
import { TableFactory } from "./table.definition";

export const Table: TableFactory = ({
  id,
  config = {},
  columns,
  items,
  context,
  load,
  // Eventos planos
  onRowClick,
  onEdit,
  onDelete,
  onBulkDelete,
}) => {
  // Construcción de eventos
  const componentEvents: Record<string, any> = {};

  if (onRowClick) componentEvents.onRowClick = onRowClick;
  if (onEdit) componentEvents.onEdit = onEdit;
  if (onDelete) componentEvents.onDelete = onDelete;
  if (onBulkDelete) componentEvents.onBulkDelete = onBulkDelete;

  return {
    id,
    type: "Table",
    context,
    load,
    // Pasamos tanto columns como items dentro de data para ser procesados dinámicamente
    data: {
      columns,
      items, // Renombrado de 'data' a 'items' para claridad interna
    },
    config: {
      pageSize: 10, // Default actualizado a 10
      enableRowSelection: false,
      enableExport: true,
      ...config,
    },
    events: componentEvents,
  };
};


============================================================
FILE_PATH: src\features\engine\modules\components\table\table.component.tsx
============================================================
import { useMemo, useState } from "react";
import {
  useReactTable,
  getCoreRowModel,
  getPaginationRowModel,
  getSortedRowModel,
  flexRender,
  SortingState,
  ColumnDef,
} from "@tanstack/react-table";
import {
  ChevronLeft,
  ChevronRight,
  ArrowUpDown,
  Download,
  Trash2,
  Pencil,
} from "lucide-react";

// UI Components
import {
  Table as UITable,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import { cn } from "@/lib/utils";

// Engine Hooks
import { useComponentRegistration } from "@/features/engine/hooks/useComponentRegistration";
import { useDynamicValue } from "@/features/engine/hooks/useDynamicValue";
import { useScriptError } from "@/features/engine/hooks/useConnectionError";

import { IComponent, IContext } from "../../types/component.type";
import { ITableProps, ITableColumn } from "./table.definition";

export const DynamicTable = ({
  config = {},
  events,
  context,
  id,
  data,
}: IComponent & ITableProps & { context: IContext }) => {
  const execute = useScriptError();

  // 1. Hook para ITEMS (Data Rows)
  // Nota: data.items viene del builder (que mapeó 'items' a 'data.items')
  const [itemsRef, setItems, tableData, reloadItems] = useDynamicValue<any[]>(
    context,
    data?.items,
    []
  );

  // 2. Hook para COLUMNAS
  const [colsRef, setCols, tableColumns] = useDynamicValue<ITableColumn[]>(
    context,
    data?.columns,
    []
  );

  // 3. Estado local de la tabla
  const [sorting, setSorting] = useState<SortingState>([]);
  const [rowSelection, setRowSelection] = useState({});
  const [pagination, setPagination] = useState({
    pageIndex: 0,
    pageSize: config.pageSize || 10,
  });

  // --- Helpers ---

  // Exportar a CSV
  const handleExport = () => {
    if (!Array.isArray(tableData) || tableData.length === 0) return;

    // Usamos las columnas actuales para definir el orden y headers del CSV
    const currentCols = Array.isArray(tableColumns) ? tableColumns : [];

    const headers = currentCols.map((c) => c.header).join(",");
    const keys = currentCols.map((c) => c.accessorKey);

    const rows = tableData
      .map((row) =>
        keys
          .map((k) => {
            const val = row[k];
            // Manejo básico de valores nulos o objetos
            if (val === null || val === undefined) return "";
            if (typeof val === "object")
              return JSON.stringify(val).replace(/,/g, ";"); // Escapar comas
            return JSON.stringify(val);
          })
          .join(",")
      )
      .join("\n");

    const csvContent = "data:text/csv;charset=utf-8," + headers + "\n" + rows;
    const encodedUri = encodeURI(csvContent);
    const link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute(
      "download",
      `export_${id}_${new Date().toISOString().slice(0, 10)}.csv`
    );
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // --- Definición de Columnas para TanStack Table ---
  const columns = useMemo<ColumnDef<any>[]>(() => {
    const baseCols: ColumnDef<any>[] = [];

    // 1. Columna de Selección (Checkbox)
    if (config.enableRowSelection) {
      baseCols.push({
        id: "select",
        header: ({ table }) => (
          <Checkbox
            checked={table.getIsAllPageRowsSelected()}
            onCheckedChange={(value) =>
              table.toggleAllPageRowsSelected(!!value)
            }
            aria-label="Select all"
          />
        ),
        cell: ({ row }) => (
          <Checkbox
            checked={row.getIsSelected()}
            onCheckedChange={(value) => row.toggleSelected(!!value)}
            aria-label="Select row"
            onClick={(e) => e.stopPropagation()}
          />
        ),
        enableSorting: false,
        enableHiding: false,
        size: 40,
      });
    }

    // 2. Columnas de Datos (Dinámicas)
    const dataCols = (Array.isArray(tableColumns) ? tableColumns : []).map(
      (col) => ({
        accessorKey: col.accessorKey,
        header: ({ column }: any) => {
          if (col.enableSorting) {
            return (
              <Button
                variant="ghost"
                onClick={() =>
                  column.toggleSorting(column.getIsSorted() === "asc")
                }
                className="-ml-4 h-8 data-[state=open]:bg-accent text-xs font-semibold"
              >
                {col.header}
                <ArrowUpDown className="ml-2 h-3 w-3" />
              </Button>
            );
          }
          return <span className="text-xs font-semibold">{col.header}</span>;
        },
        cell: ({ getValue }: any) => {
          // Aquí podrías agregar formateadores (date, currency) basados en col.format
          const val = getValue();
          return <span className="text-sm">{val}</span>;
        },
      })
    );
    baseCols.push(...dataCols);

    // 3. Columna de Acciones (Editar/Eliminar)
    if (events?.onEdit || events?.onDelete) {
      baseCols.push({
        id: "actions",
        header: "Acciones",
        cell: ({ row }) => {
          return (
            <div className="flex items-center gap-1">
              {events?.onEdit && (
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-8 w-8 text-blue-600 hover:text-blue-800 hover:bg-blue-50"
                  onClick={(e) => {
                    e.stopPropagation();
                    execute(events.onEdit, row.original, context);
                  }}
                >
                  <Pencil className="h-4 w-4" />
                </Button>
              )}
              {events?.onDelete && (
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-8 w-8 text-red-500 hover:text-red-700 hover:bg-red-50"
                  onClick={(e) => {
                    e.stopPropagation();
                    execute(events.onDelete, row.original, context);
                  }}
                >
                  <Trash2 className="h-4 w-4" />
                </Button>
              )}
            </div>
          );
        },
      });
    }

    return baseCols;
  }, [tableColumns, config.enableRowSelection, events, context, execute]);

  // --- Instancia de la Tabla ---
  const table = useReactTable({
    data: Array.isArray(tableData) ? tableData : [],
    columns,
    getCoreRowModel: getCoreRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    getSortedRowModel: getSortedRowModel(),
    onSortingChange: setSorting,
    onPaginationChange: setPagination,
    onRowSelectionChange: setRowSelection,
    state: {
      sorting,
      pagination,
      rowSelection,
    },
  });

  const selectedRows = table.getFilteredSelectedRowModel().rows;

  // --- API Expuesta ---
  const exposedMethods = useMemo(
    () => ({
      setData: (newData: any[]) => {
        setItems(newData);
        setRowSelection({});
      },
      getData: () => itemsRef.current,
      getSelectedRows: () =>
        table.getSelectedRowModel().rows.map((r) => r.original),
      reload: () => reloadItems(),
    }),
    [setItems, itemsRef, table, reloadItems]
  );

  useComponentRegistration(context, "table", id, exposedMethods);

  // --- Renderizado ---
  return (
    <div
      className={cn("w-full flex flex-col gap-4", config.className)}
      style={config.style}
    >
      {/* Toolbar Superior */}
      <div className="flex items-center justify-between min-h-[40px]">
        <div className="flex items-center gap-2">
          {selectedRows.length > 0 && events?.onBulkDelete && (
            <div className="flex items-center gap-2 animate-in fade-in slide-in-from-left-2 duration-300">
              <span className="text-sm text-muted-foreground border-r pr-3 mr-1">
                {selectedRows.length} seleccionados
              </span>
              <Button
                variant="destructive"
                size="sm"
                onClick={() => {
                  const items = selectedRows.map((r) => r.original);
                  execute(events.onBulkDelete, items, context);
                  setRowSelection({});
                }}
              >
                <Trash2 className="mr-2 h-4 w-4" />
                Eliminar Selección
              </Button>
            </div>
          )}
        </div>

        {config.enableExport !== false && (
          <Button variant="outline" size="sm" onClick={handleExport}>
            <Download className="mr-2 h-4 w-4" />
            Exportar CSV
          </Button>
        )}
      </div>

      {/* Tabla */}
      <div className="rounded-md border bg-card">
        <UITable>
          <TableHeader>
            {table.getHeaderGroups().map((headerGroup) => (
              <TableRow key={headerGroup.id}>
                {headerGroup.headers.map((header) => (
                  <TableHead key={header.id}>
                    {header.isPlaceholder
                      ? null
                      : flexRender(
                          header.column.columnDef.header,
                          header.getContext()
                        )}
                  </TableHead>
                ))}
              </TableRow>
            ))}
          </TableHeader>
          <TableBody>
            {table.getRowModel().rows?.length ? (
              table.getRowModel().rows.map((row) => (
                <TableRow
                  key={row.id}
                  data-state={row.getIsSelected() && "selected"}
                  className={cn(
                    "transition-colors",
                    events?.onRowClick && "cursor-pointer hover:bg-muted/50"
                  )}
                  onClick={() => {
                    if (events?.onRowClick) {
                      execute(events.onRowClick, row.original, context);
                    }
                  }}
                >
                  {row.getVisibleCells().map((cell) => (
                    <TableCell key={cell.id}>
                      {flexRender(
                        cell.column.columnDef.cell,
                        cell.getContext()
                      )}
                    </TableCell>
                  ))}
                </TableRow>
              ))
            ) : (
              <TableRow>
                <TableCell
                  colSpan={columns.length}
                  className="h-24 text-center text-muted-foreground"
                >
                  No hay resultados.
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </UITable>
      </div>

      {/* Paginación */}
      <div className="flex items-center justify-end space-x-2 py-2">
        <div className="text-sm text-muted-foreground">
          Página {table.getState().pagination.pageIndex + 1} de{" "}
          {table.getPageCount()}
        </div>
        <div className="space-x-2">
          <Button
            variant="outline"
            size="icon"
            className="h-8 w-8"
            onClick={() => table.previousPage()}
            disabled={!table.getCanPreviousPage()}
          >
            <ChevronLeft className="h-4 w-4" />
          </Button>
          <Button
            variant="outline"
            size="icon"
            className="h-8 w-8"
            onClick={() => table.nextPage()}
            disabled={!table.getCanNextPage()}
          >
            <ChevronRight className="h-4 w-4" />
          </Button>
        </div>
      </div>
    </div>
  );
};


============================================================
FILE_PATH: src\features\engine\modules\components\table\table.definition.ts
============================================================
import {
  IComponent,
  IComponentEvent,
  IContext,
  IComponentData,
} from "../../types/component.type";

// --- 1. Definición de Columnas ---

export interface ITableColumn {
  /** Clave de propiedad en el objeto de datos (ej: "nombre", "usuario.email") */
  accessorKey: string;
  /** Título de la columna */
  header: string;
  /** Permitir ordenar por esta columna */
  enableSorting?: boolean;
  /** Ancho sugerido (ej: "200px") */
  width?: string;
  /** Formato especial (ej: "currency", "date") - Para implementación futura */
  format?: string;
}

// --- 2. Configuración ---

export interface ITableConfig {
  className?: string;
  style?: React.CSSProperties;
  /** Número de filas por página */
  pageSize?: number;
  /** Permitir seleccionar filas con checkbox */
  enableRowSelection?: boolean;
  /** Mostrar botón de exportar a CSV */
  enableExport?: boolean;
}

// --- 3. Datos Dinámicos ---

export interface ITableData {
  /** Definición de columnas (puede ser dinámica) */
  columns: IComponentData<ITableColumn[]>;
  /** Array de datos a mostrar */
  items?: IComponentData<any[]>;
}

// --- 4. Eventos (Planos) ---

export interface ITableEvents {
  /** Click en una fila */
  onRowClick?: IComponentEvent;
  /** Click en botón editar (acción rápida) */
  onEdit?: IComponentEvent;
  /** Click en botón eliminar (acción rápida) */
  onDelete?: IComponentEvent;
  /** Click en eliminar selección múltiple */
  onBulkDelete?: IComponentEvent;
}

// --- 5. Props Principales ---

export interface ITableProps extends ITableData, ITableEvents {
  id: string;
  config?: ITableConfig;
  context?: IContext;
  load?: () => void;
}

export type TableFactory = (props: ITableProps) => IComponent;

// --- 6. Definiciones para el Editor (Strings) ---

export const TABLE_TYPE_DEFINITION = `
type TableColumn = {
  accessorKey: string;
  header: string;
  enableSorting?: boolean;
  width?: string;
};

interface ITableConfig {
  className?: string;
  style?: Record<string, any>;
  pageSize?: number;
  enableRowSelection?: boolean;
  enableExport?: boolean;
}

interface ITableProps {
  id: string;
  // Columnas dinámicas
  columns: IComponentData<TableColumn[]>;
  // Datos dinámicos
  items?: IComponentData<any[]>;
  
  config?: ITableConfig;
  
  // Eventos
  onRowClick?: IComponentEvent;
  onEdit?: IComponentEvent;
  onDelete?: IComponentEvent;
  onBulkDelete?: IComponentEvent;
}

/**
 * Crea una Tabla de datos con paginación, ordenamiento y selección.
 */
declare const Table: (props: ITableProps) => IComponent;
`;

const TABLE_CONTEXT_EVENTS_DEFINITION = `
interface ITableExposedMethods {
  /** Reemplaza los datos de la tabla */
  setData: (data: any[]) => void;
  /** Obtiene los datos actuales */
  getData: () => any[];
  /** Obtiene las filas seleccionadas actualmente */
  getSelectedRows: () => any[];
  /** Recarga los datos (si vienen de URL) */
  reload: () => void;
}

interface ITableMap {
  [id: string]: ITableExposedMethods;
}
`;

export const TABLE_CONTEXT_EVENT = {
  key: "table",
  name: "ITableMap",
  definition: TABLE_CONTEXT_EVENTS_DEFINITION,
};


============================================================
FILE_PATH: src\features\engine\modules\components\text\index.ts
============================================================
import { IComponentModule } from "../../types/IComponentModule";
import { CText } from "./text.builder";
import { DynamicText } from "./text.component";
import { TEXT_CONTEXT_EVENT, TEXT_TYPE_DEFINITION } from "./text.definition";

export const TEXT: IComponentModule = {
  name: "CText",
  component: DynamicText,
  builder: CText,
  eventsDefinition: TEXT_CONTEXT_EVENT,
  builderDefinition: TEXT_TYPE_DEFINITION,
};


============================================================
FILE_PATH: src\features\engine\modules\components\text\text.builder.ts
============================================================
import { IComponent } from "../../types/component.type";
import { ITextProps } from "./text.definition";

interface ITextFactory {
  (data: ITextProps): IComponent;
}

export const CText: ITextFactory = ({
  id,
  config = {},
  content,
  context,
  load,
  // Desestructuramos eventos planos
  onClick,
  onMouseEnter,
  onMouseLeave,
}) => {
  // Construimos el objeto events dinámicamente
  const componentEvents: Record<string, any> = {};

  if (onClick) componentEvents.onClick = onClick;
  if (onMouseEnter) componentEvents.onMouseEnter = onMouseEnter;
  if (onMouseLeave) componentEvents.onMouseLeave = onMouseLeave;

  return {
    id,
    type: "CText",
    context,
    load,
    data: { content },
    config: {
      variant: "p", // Default seguro
      align: "left",
      ...config,
    },
    events: componentEvents,
  };
};


============================================================
FILE_PATH: src\features\engine\modules\components\text\text.component.tsx
============================================================
import { JSX, useMemo } from "react";
import { useDynamicValue } from "@/features/engine/hooks/useDynamicValue"; // Ajusta ruta según tu proyecto
import { useComponentRegistration } from "@/features/engine/hooks/useComponentRegistration"; // Ajusta ruta
import { useScriptError } from "@/features/engine/hooks/useConnectionError"; // Ajusta ruta
import { cn } from "@/lib/utils";
import { IComponent, IContext } from "../../types/component.type";
import { ITextProps } from "./text.definition";

// --- Mapas de Configuración ---

const TagMap: Record<string, keyof JSX.IntrinsicElements> = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  p: "p",
  blockquote: "blockquote",
  lead: "p",
  large: "div",
  small: "small",
  muted: "p",
};

const ClassMap: Record<string, string> = {
  h1: "scroll-m-20 text-4xl font-extrabold tracking-tight lg:text-5xl",
  h2: "scroll-m-20 border-b pb-2 text-3xl font-semibold tracking-tight first:mt-0",
  h3: "scroll-m-20 text-2xl font-semibold tracking-tight",
  h4: "scroll-m-20 text-xl font-semibold tracking-tight",
  p: "leading-7 [&:not(:first-child)]:mt-6",
  blockquote: "mt-6 border-l-2 pl-6 italic",
  lead: "text-xl text-muted-foreground",
  large: "text-lg font-semibold",
  small: "text-sm font-medium leading-none",
  muted: "text-sm text-muted-foreground",
};

const AlignMap: Record<string, string> = {
  left: "text-left",
  center: "text-center",
  right: "text-right",
  justify: "text-justify",
};

// --- Componente ---

export const DynamicText = ({
  config = {},
  events,
  context,
  id,
  data,
}: IComponent & ITextProps & { context: IContext }) => {
  const execute = useScriptError();

  // 1. Manejo dinámico del contenido
  const [contentRef, setContent, content] = useDynamicValue(
    context,
    data?.content,
    ""
  );

  // 2. Helper para ejecutar eventos
  const handleEvent = (eventName: string, e: any) => {
    if (events && events[eventName]) {
      execute(events[eventName], e, context);
    }
  };

  // 3. Exponer métodos
  const exposedMethods = useMemo(
    () => ({
      setText: (text: string) => setContent(text),
      getText: () => contentRef.current,
    }),
    [setContent, contentRef]
  );

  useComponentRegistration(context, "txt", id, exposedMethods);

  // 4. Renderizado
  const variant = config.variant || "p";
  const Tag = TagMap[variant] || "p";
  const alignClass = AlignMap[config.align || "left"];
  const variantClass = ClassMap[variant] || ClassMap["p"];

  // Feedback visual si hay evento click
  const isClickable = !!events?.onClick;

  return (
    <Tag
      className={cn(
        variantClass,
        alignClass,
        isClickable && "cursor-pointer hover:opacity-80 transition-opacity",
        config.className
      )}
      style={config.style}
      onClick={(e) => handleEvent("onClick", e)}
      onMouseEnter={(e) => handleEvent("onMouseEnter", e)}
      onMouseLeave={(e) => handleEvent("onMouseLeave", e)}
    >
      {content}
    </Tag>
  );
};


============================================================
FILE_PATH: src\features\engine\modules\components\text\text.definition.ts
============================================================
import {
  IComponent,
  IComponentEvent,
  IContext,
  IComponentData,
} from "../../types/component.type";

// --- 1. Variantes y Configuración ---

export type TextVariant =
  | "h1"
  | "h2"
  | "h3"
  | "h4"
  | "p"
  | "blockquote"
  | "lead"
  | "large"
  | "small"
  | "muted";

export type TextAlign = "left" | "center" | "right" | "justify";

/**
 * Configuración visual y de estilo del texto.
 */
export interface ITextConfig {
  /** Clases CSS adicionales (Tailwind) */
  className?: string;
  /** Estilos en línea */
  style?: React.CSSProperties;
  /** Variante tipográfica (h1, p, small, etc.) */
  variant?: TextVariant;
  /** Alineación del texto */
  align?: TextAlign;
}

// --- 2. Datos Dinámicos ---

export interface ITextData {
  /** El contenido del texto. Soporta binding dinámico. */
  content?: IComponentData<string>;
}

// --- 3. Eventos (Estructura Plana para DX) ---

export interface ITextEvents {
  /** Evento al hacer click en el texto */
  onClick?: IComponentEvent;
  onMouseEnter?: IComponentEvent;
  onMouseLeave?: IComponentEvent;
}

// --- 4. Props Principales ---

/**
 * Propiedades para construir el componente de Texto.
 */
export interface ITextProps extends ITextData, ITextEvents {
  id: string;
  config?: ITextConfig;
  context?: IContext;
  load?: () => void;
}

export type TextFactory = (props: ITextProps) => IComponent;

// --- 5. Definiciones para el Editor (Strings) ---

export const TEXT_TYPE_DEFINITION = `
/** Variantes tipográficas disponibles */
type TextVariant = "h1" | "h2" | "h3" | "h4" | "p" | "blockquote" | "lead" | "large" | "small" | "muted";
type TextAlign = "left" | "center" | "right" | "justify";

interface ITextConfig {
  className?: string;
  /** Estilos CSS en objeto. Ej: { color: 'red' } */
  style?: Record<string, any>;
  variant?: TextVariant;
  align?: TextAlign;
}

interface ITextProps {
  id: string;
  config?: ITextConfig;
  /** Contenido del texto */
  content?: IComponentData<string>;
  
  // Eventos
  onClick?: IComponentEvent;
  onMouseEnter?: IComponentEvent;
  onMouseLeave?: IComponentEvent;
}

/** Crea un componente de Texto */
declare const CText: (props: ITextProps) => IComponent;
`;

const TEXT_CONTEXT_EVENTS_DEFINITION = `
interface ITextExposedMethods {
  /** Actualiza el contenido del texto dinámicamente */
  setText: (text: string) => void;
  /** Obtiene el contenido actual */
  getText: () => string;
}

interface ITextMap {
  [id: string]: ITextExposedMethods;
}
`;

export const TEXT_CONTEXT_EVENT = {
  key: "txt", // Prefijo sugerido para textos
  name: "ITextMap",
  definition: TEXT_CONTEXT_EVENTS_DEFINITION,
};


============================================================
FILE_PATH: src\features\engine\modules\functions\index.ts
============================================================
import { ZodFun } from "./Zod";
import { EditorLogFun } from "./EditorLog";
import { ModalFunc } from "./Modal";
import { SystemFun } from "./System";
import { ExecQueryFun } from "./ExecQuery";
import { ConnectFunc } from "./Connect";

export const FunctionModules = [
  ZodFun,
  EditorLogFun,
  ModalFunc,
  SystemFun,
  ExecQueryFun,
  ConnectFunc,
];


============================================================
FILE_PATH: src\features\engine\modules\functions\Connect\Connect.definition.ts
============================================================
export const ConnectType = `
declare const Connect:(config:{url:string; key:string; type:string;})=>Promise<void>
`;


============================================================
FILE_PATH: src\features\engine\modules\functions\Connect\Connect.ts
============================================================
import { useEditorStore } from "@/features/engine/store/editor.store";
import { useScriptConnectionStore } from "@/features/engine/store/scriptConnection.store";

export const ConnectFunc = () => {
  const { activeAdapter, setIsConnected, disconnect, setConfig, connect } =
    useScriptConnectionStore.getState();
  const { addExecutionLogs } = useEditorStore.getState();
  return async (
    config: { url: string; key: string; type: string },
    shouldSave: boolean = true
  ) => {
    try {
      if (activeAdapter) {
        setIsConnected(false);
        await disconnect();
      }
      await connect(config);
      if (shouldSave) {
        setConfig(config);
      }
      setIsConnected(true);
      if (activeAdapter) {
        addExecutionLogs([
          { message: `System: Connected to ${activeAdapter.name}` },
        ]);
      }
      return true;
    } catch (error: any) {
      if (activeAdapter) {
        addExecutionLogs([
          { message: `System: Connected to ${activeAdapter.name}` },
        ]);
      }
      throw error;
    }
  };
};


============================================================
FILE_PATH: src\features\engine\modules\functions\Connect\index.ts
============================================================
import { IFunctionModule } from "../../types/IFuntionsModule";
import { ConnectFunc as connect } from "./Connect";
import { ConnectType } from "./Connect.definition";

export const ConnectFunc: IFunctionModule = {
  name: "Connect",
  func: connect,
  definition: ConnectType,
};


============================================================
FILE_PATH: src\features\engine\modules\functions\EditorLog\EditorLog.definition.ts
============================================================
export const EditorLogType = "\ndeclare const Log:(...args:any[]) => void;";


============================================================
FILE_PATH: src\features\engine\modules\functions\EditorLog\EditorLog.ts
============================================================
import { useEditorStore } from "@/features/engine/store/editor.store";
import { useCallback } from "react";
const serializeWithFunctions = (item: any, seen = new WeakSet()): any => {
  // Si es una función, retornamos su representación en string
  if (typeof item === "function") {
    return `[Function: ${item.name || "anonymous"}]`;
  }

  // Si es primitivo o null, lo devolvemos tal cual
  if (item === null || typeof item !== "object") {
    return item;
  }

  // Manejo de referencias circulares para evitar crash
  if (seen.has(item)) {
    return "[Circular]";
  }
  seen.add(item);

  // Si es un array, procesamos cada elemento
  if (Array.isArray(item)) {
    return item.map((i) => serializeWithFunctions(i, seen));
  }

  // Si es un objeto, procesamos cada llave
  const result: any = {};
  for (const key in item) {
    if (Object.prototype.hasOwnProperty.call(item, key)) {
      result[key] = serializeWithFunctions(item[key], seen);
    }
  }
  return result;
};

interface LogEntry {
  message: string;
  data?: any[]; // El '?' hace que la propiedad sea opcional
}

export const EditorLog = () => {
  const state = useEditorStore.getState();
  const isEditing = state.isEditing; // O la propiedad correcta de tu store
  const addExecutionLogs = state.addExecutionLogs;

  return (...args: any) => {
    if (isEditing) {
      const entry: LogEntry = { message: "" };

      // Filtramos los que NO son strings y aplicamos la serialización
      // para preservar las funciones dentro de los objetos
      entry.data = args
        .filter((item) => typeof item != "string")
        .map((item) => serializeWithFunctions(item));

      entry.message = args.filter((item) => typeof item == "string").join(",");

      addExecutionLogs([entry]);
    } else {
      console.log(...args);
    }
  };
};


============================================================
FILE_PATH: src\features\engine\modules\functions\EditorLog\index.ts
============================================================
import { IFunctionModule } from "../../types/IFuntionsModule";
import { EditorLog } from "./EditorLog";
import { EditorLogType } from "./EditorLog.definition";

export const EditorLogFun: IFunctionModule = {
  name: "Log",
  func: EditorLog,
  definition: EditorLogType,
};


============================================================
FILE_PATH: src\features\engine\modules\functions\ExecQuery\ExecQuery.definition.ts
============================================================
export const ExecQueryType =
  "declare function execQuery(query: string, context?: Record<string,any>): Promise<any[]>;";


============================================================
FILE_PATH: src\features\engine\modules\functions\ExecQuery\ExecQuery.ts
============================================================
import { toast } from "sonner";
import { processSqlTemplate } from "../../../lib/runScript/processSqlTemplate";
import { useScriptConnectionStore } from "@/features/engine/store/scriptConnection.store";
import { useEditorStore } from "@/features/engine/store/editor.store";

export const ExecQuery = () => {
  const { activeAdapter } = useScriptConnectionStore.getState();
  const { addExecutionLogs } = useEditorStore.getState();
  return async (query: string, context?: Record<string, any>) => {
    if (!query) return [];
    if (!activeAdapter || !activeAdapter.isConnected()) {
      const errorMsg = "No hay una conexión activa. Verifica la configuración.";
      toast.error("Error de Ejecución", {
        description: errorMsg,
      });

      return [];
    }
    const processedQuery = context ? processSqlTemplate(query, context) : query;
    const start = performance.now();
    const result = await activeAdapter.execute(processedQuery);
    const end = performance.now();
    addExecutionLogs([
      {
        message: `Query Executed (${(end - start).toFixed(2)}ms)`,
        data: [
          processedQuery,
          result.message || `Rows: ${result.data?.length}`,
        ],
      },
    ]);
    if (result.error) {
      throw new Error(result.error);
    }

    return result.data || [];
  };
};


============================================================
FILE_PATH: src\features\engine\modules\functions\ExecQuery\index.ts
============================================================
import { IFunctionModule } from "../../types/IFuntionsModule";
import { ExecQuery } from "./ExecQuery";
import { ExecQueryType } from "./ExecQuery.definition";

export const ExecQueryFun: IFunctionModule = {
  name: "execQuery",
  func: ExecQuery,
  definition: ExecQueryType,
};


============================================================
FILE_PATH: src\features\engine\modules\functions\Modal\index.ts
============================================================
import { IFunctionModule } from "../../types/IFuntionsModule";
import { Modal } from "./Modal";
import { ModalType } from "./ModalType";

export const ModalFunc: IFunctionModule = {
  name: "modal",
  func: Modal,
  definition: ModalType,
};


============================================================
FILE_PATH: src\features\engine\modules\functions\Modal\Modal.ts
============================================================
import { useModalStore } from "@/hooks/useModal";

export const Modal = () => {
  const { openModal, closeModal, getModalData } = useModalStore.getState();
  return {
    open: (id: string, data: any) => openModal(id, data),
    close: (id: string) => closeModal(id),
    getData: (id: string) => getModalData(id),
  };
};


============================================================
FILE_PATH: src\features\engine\modules\functions\Modal\ModalType.ts
============================================================
export const ModalType = `
declare const modal:{
    open:(id:string,data?:any)=>void; 
    close:(id:string)=>void; 
    getData:(id:string)=>any
}`;


============================================================
FILE_PATH: src\features\engine\modules\functions\System\index.ts
============================================================
import { IFunctionModule } from "../../types/IFuntionsModule";
import { System } from "./System";
import { SystemType } from "./SystemType";

export const SystemFun: IFunctionModule = {
  name: "sys",
  func: System,
  definition: SystemType,
};


============================================================
FILE_PATH: src\features\engine\modules\functions\System\System.ts
============================================================
import { uuid } from "zod";

export const System = () => {
  return {
    uuid: () => uuid(),
  };
};


============================================================
FILE_PATH: src\features\engine\modules\functions\System\SystemType.ts
============================================================
export const SystemType = `
declare const sys:{
uuid:()=>string
}
`;


============================================================
FILE_PATH: src\features\engine\modules\functions\Zod\index.ts
============================================================
import { IFunctionModule } from "../../types/IFuntionsModule";
import { Zod } from "./Zod";
import { ZodType } from "./ZodType";

export const ZodFun: IFunctionModule = {
  name: "z",
  definition: ZodType,
  func: Zod,
};


============================================================
FILE_PATH: src\features\engine\modules\functions\Zod\Zod.ts
============================================================
import z from "zod";

export const Zod = () => {
  return z;
};


============================================================
FILE_PATH: src\features\engine\modules\functions\Zod\ZodType.ts
============================================================
export const ZodType = `

type ZodSafeParseReturnType<Output> = 
  | { success: true; data: Output } 
  | { success: false; error: { issues: any[]; message: string } };

interface ZodType<Output = any, Input = Output> {
  parse(data: unknown): Output;
  safeParse(data: unknown): ZodSafeParseReturnType<Output>;
  optional(): ZodType<Output | undefined, Input | undefined>;
  nullable(): ZodType<Output | null, Input | null>;
  or<T extends ZodType>(option: T): ZodType<Output | T["_output"], Input | T["_input"]>;
  and<T extends ZodType>(option: T): ZodType<Output & T["_output"], Input & T["_input"]>;
  _output: Output;
  _input: Input;
}

interface ZodString extends ZodType<string> {
  email(message?: string): ZodString;
  min(length: number, message?: string): ZodString;
  max(length: number, message?: string): ZodString;
  url(message?: string): ZodString;
  uuid(message?: string): ZodString;
  regex(regex: RegExp, message?: string): ZodString;
  nonempty:()=>ZodString
}

interface ZodNumber extends ZodType<number> {
  min(value: number, message?: string): ZodNumber;
  max(value: number, message?: string): ZodNumber;
  int(message?: string): ZodNumber;
  positive(message?: string): ZodNumber;
}

interface ZodArray<T extends ZodType> extends ZodType<T["_output"][], T["_input"][]> {
  element: T;
  min(length: number, message?: string): this;
  max(length: number, message?: string): this;
}

interface ZodObject<T extends Record<string, ZodType>> extends ZodType<
  { [K in keyof T]: T[K]["_output"] },
  { [K in keyof T]: T[K]["_input"] }
> {
  shape: T;
  extend<U extends Record<string, ZodType>>(augmentation: U): ZodObject<T & U>;
  pick<K extends keyof T>(mask: Record<K, true>): ZodObject<Pick<T, K>>;
  omit<K extends keyof T>(mask: Record<K, true>): ZodObject<Omit<T, K>>;
  partial(): ZodObject<{ [K in keyof T]: T[K] extends ZodType<infer O, infer I> ? ZodType<O | undefined, I | undefined> : never }>;
}

// Declaración del objeto 'z' y sus métodos
declare const z: {
  string: (params?: { required_error?: string; invalid_type_error?: string }) => ZodString;
  number: (params?: { required_error?: string; invalid_type_error?: string }) => ZodNumber;
  boolean: (params?: { required_error?: string; invalid_type_error?: string }) => ZodType<boolean>;
  date: () => ZodType<Date>;
  any: () => ZodType<any>;
  unknown: () => ZodType<unknown>;
  null: () => ZodType<null>;
  undefined: () => ZodType<undefined>;
  literal: <T extends string | number | boolean>(value: T) => ZodType<T>;
  union: <T extends [ZodType, ...ZodType[]]>(options: T) => ZodType<T[number]["_output"]>;
  array: <T extends ZodType>(schema: T) => ZodArray<T>;
  object: <T extends Record<string, ZodType>>(shape: T) => ZodObject<T>;
  enum: <U extends string, T extends [U, ...U[]]>(values: T) => ZodType<T[number]>;
  nativeEnum: <T extends EnumLike>(enumObj: T) => ZodType<T[keyof T]>;
  
  // Utilidad para inferencia de tipos dentro del script
  infer: <T extends ZodType>(schema: T) => T["_output"];
};

// Hack para permitir "type MyType = z.infer<typeof schema>"
declare namespace z {
    export type infer<T extends ZodType> = T["_output"];
}

type EnumLike = { [k: string]: string | number; [k: number]: string };`;


============================================================
FILE_PATH: src\features\engine\modules\lib\createContext.ts
============================================================
import { IContext } from "../types/component.type";

export const createContext = (): IContext => {
  const events: Record<string, { id: string; fn: (data: any) => any }[]> = {};

  const evensFuns = {
    register: (id, fn) => {
      if ((events[id]?.length ?? 0) == 1) return;
      events[id] ??= [];
      events[id].push({ id, fn });
    },
    unregister: (id) => {
      delete events[id];
    },
    suscribe: (id, fn) => {
      events[id] ??= [];
      events[id].push({ id, fn });
    },
    unSuscribe: (id) => {
      if (!events[id]) return;
      events[id] = events[id].filter((i) => i.id != id);
    },
    call: (id, data) => {
      if (!events[id] || events[id].length > 0) return;
      return events[id][0].fn(data);
    },
    trigger: (id, data) => {
      if (!events[id]) return;
      events[id].forEach((item) => item.fn(data));
    },
  };

  const context: IContext = {
    comp: {},
    events: evensFuns,
  };

  return context;
};


============================================================
FILE_PATH: src\features\engine\modules\types\component.definition.ts
============================================================
export const ContextType = (data: Record<string, string>) => {
  return `type IContext = {
  comp: {
  ${Object.keys(data)
    .map((item) => `${item}:${data[item]};`)
    .join(";\n")}
  };
  events: {
    suscribe: (id: string, fn: () => void) => void;
    unSuscribe: (id: string) => void;
    register: (id: string, fn: () => any) => void;
    unregister: (id:string) => void;
    call: (id: string, data: any) => any;
    trigger: (id: string, data: any) => void;
  };
};
declare const context:IContext;
`;
};
export const ComponentType = `


type IComponentEvent = (e: any, context: IContext) => void;
type IEvents = Record<string, IComponentEvent | undefined>;
type IDynamicResult<T> = T | Promise<T>;
type IDynamicFunction<T> = (context: IContext) => IDynamicResult<T>;
type IDynamicValue<T> = T | IDynamicFunction<T>;

type IComponentData<T> =
  | IDynamicValue<T>
  | { data: IDynamicValue<T>; keepData: boolean };

interface IComponent {
  type: string;
  id: string;
  config: Record<string, any>;
  data: Record<string, IComponentData<any>>;
  events: IEvents;
  context?: IContext;
  subComponents?: IComponent[] | IComponent;
  load?: () => void;
}

`;


============================================================
FILE_PATH: src\features\engine\modules\types\component.type.ts
============================================================
export type IContext = {
  comp: Record<string, any>;
  events: {
    suscribe: (id: string, fn: () => void) => void;
    unSuscribe: (id: string) => void;
    register: (id: string, fn: () => any) => void;
    unregister: (id) => void;
    call: (id: string, data: any) => any;
    trigger: (id: string, data: any) => void;
  };
};

export type IComponentEvent = (e: any, context: IContext) => void;
export type IEvents = Record<string, IComponentEvent | undefined>;
export type IDynamicResult<T> = T | Promise<T>;
export type IDynamicFunction<T> = (context: IContext) => IDynamicResult<T>;
export type IDynamicValue<T> = T | IDynamicFunction<T>;

export type IComponentData<T> =
  | IDynamicValue<T>
  | { data: IDynamicValue<T>; keepData: boolean };

export interface IComponent {
  type: string;
  id: string;
  config: Record<string, any>;
  data: Record<string, IComponentData<any>>;
  events: IEvents;
  context?: IContext;
  subComponents?: IComponent[] | IComponent;
  load?: () => void;
}


============================================================
FILE_PATH: src\features\engine\modules\types\IComponentModule.ts
============================================================
import { JSX } from "react";
import { IComponent } from "./component.type";

export interface IComponentModule {
  name: string;
  component: (data: any) => JSX.Element;
  builder: (data?: any) => IComponent;
  eventsDefinition: { key: string; name: string; definition: string };
  builderDefinition: string;
}


============================================================
FILE_PATH: src\features\engine\modules\types\IFuntionsModule.ts
============================================================
export interface IFunctionModule {
  name: string;
  func: any | Record<string, any>;
  definition: string;
}


============================================================
FILE_PATH: src\features\engine\store\editor.store.ts
============================================================
import { create } from "zustand";

export interface LogEntry {
  message: string;
  data?: any;
  step?: string;
}

interface EditorState {
  sqlCode: string;
  jsCode: string;
  logs: LogEntry[];
  isEditing: boolean;

  setJsCode: (code: string) => void;
  setSqlCode: (code: string) => void;
  clearConsole: () => void;
  setIsEditing: (value: boolean) => void;
  addExecutionLogs: (logs: LogEntry[], result?: any) => void;
  resetEditor: () => void;
}

const initialState = {
  sqlCode: "",
  jsCode: "",
  logs: [] as LogEntry[],
  isEditing: false,
};

export const useEditorStore = create<EditorState>((set) => ({
  ...initialState,

  setJsCode: (code) => set({ jsCode: code }),

  setSqlCode: (code) => set({ sqlCode: code }),

  clearConsole: () => set({ logs: [] }),

  setIsEditing: (value) => set({ isEditing: value }),

  addExecutionLogs: (logs, result) =>
    set((state) => {
      const newLogs = logs.map((l) => ({ step: "JS", ...l }));
      const updatedLogs = [...state.logs, ...newLogs];

      if (result !== undefined) {
        updatedLogs.push({
          message: "Script finalizado. Return:",
          data: result,
        });
      }

      return { logs: updatedLogs };
    }),

  resetEditor: () => set(initialState),
}));


============================================================
FILE_PATH: src\features\engine\store\scriptConnection.store.ts
============================================================
import { create } from "zustand";
import { DatabaseAdapter } from "../lib/connectionsAdapters/types";
import { SupabaseAdapter } from "../lib/connectionsAdapters/SupabaseAdapter";
import { MockAdapter } from "../lib/connectionsAdapters/MockAdapter";

interface ConnectionConfig {
  url: string;
  key: string;
  type: string;
}
interface ConnectionState {
  isConnected: boolean;
  isConnecting: boolean;
  config: ConnectionConfig | null;
  error: string | null;
  setIsConnected: (value: boolean) => void;
  activeAdapter: DatabaseAdapter | null;
  connect: (config: ConnectionConfig) => Promise<void>;
  disconnect: () => Promise<void>;
  setConfig: (config: ConnectionConfig) => void;
}

const createAdapter = (type: string): DatabaseAdapter => {
  switch (type?.toLowerCase()) {
    case "supabase":
      return new SupabaseAdapter();
    case "mock":
      return new MockAdapter();
    default:
      throw new Error(`Tipo de base de datos no soportado: ${type}`);
  }
};

export const useScriptConnectionStore = create<ConnectionState>((set, get) => ({
  isConnected: false,
  isConnecting: false,
  error: null,
  activeAdapter: null,
  config: null,
  setConfig: (config) => set({ config }),
  disconnect: async () => {
    const { activeAdapter } = get();
    if (activeAdapter) {
      await activeAdapter.disconnect();
    }
    set({ isConnected: false, activeAdapter: null });
  },
  setIsConnected: (value) => {
    set({ isConnected: value });
  },
  connect: async (config: ConnectionConfig) => {
    set({ isConnecting: true, error: null, isConnected: false });

    try {
      await get().disconnect();
      const adapter = createAdapter(config.type);
      await adapter.connect(config);
      set({
        isConnected: adapter.isConnected(),
        isConnecting: false,
        activeAdapter: adapter,
        config: config,
        error: null,
      });
    } catch (err: any) {
      const errorMessage = err.message || "Error desconocido al conectar";
      set({
        isConnected: false,
        isConnecting: false,
        error: errorMessage,
        activeAdapter: null,
      });
      throw err;
    }
  },
}));


============================================================
FILE_PATH: src\features\engine\store\useEditor.ts
============================================================
import { useCallback } from "react";
import { useEditorStore } from "./editor.store";
import { useDashboardActions } from "@/features/dashboard/store/useDashboard";
import { useShallow } from "zustand/react/shallow";

export const useEditor = () => {
  const {
    jsCode,
    sqlCode,
    logs,
    isEditing,
    setJsCode,
    setSqlCode,
    clearConsole,
    addExecutionLogs,
    setIsEditing,
    resetEditor,
  } = useEditorStore(
    useShallow((s) => ({
      jsCode: s.jsCode,
      sqlCode: s.sqlCode,
      logs: s.logs,
      isEditing: s.isEditing,
      setJsCode: s.setJsCode,
      setSqlCode: s.setSqlCode,
      clearConsole: s.clearConsole,
      addExecutionLogs: s.addExecutionLogs,
      setIsEditing: s.setIsEditing,
      resetEditor: s.resetEditor,
    }))
  );

  const {
    dashboard,
    setConfigScript,
    isLoading: isDashboardLoading,
  } = useDashboardActions();

  const loadScriptFromDashboard = useCallback(() => {
    if (dashboard?.configScript) {
      setJsCode(dashboard.configScript);
    }
  }, [dashboard, setJsCode]);

  const saveScriptToDashboard = useCallback(async () => {
    if (!dashboard) return;

    setConfigScript(jsCode);
    console.log("Script guardado en el dashboard:", dashboard.id);
  }, [dashboard, jsCode, setConfigScript]);

  return {
    jsCode,
    sqlCode,
    logs,
    isEditing,

    hasUnsavedChanges: dashboard?.configScript !== jsCode,
    isReady: !isDashboardLoading && !!dashboard,

    setJsCode,
    setSqlCode,
    clearConsole,
    addExecutionLogs,
    setIsEditing,
    resetEditor,

    // Integración Dashboard
    loadScriptFromDashboard,
    saveScriptToDashboard,
  };
};


============================================================
FILE_PATH: src\features\engine\store\useScriptConnection.ts
============================================================
import { useScriptConnectionStore } from "./scriptConnection.store";
export const useScriptConnection = () => {
  const isConnected = useScriptConnectionStore((s) => s.isConnected);
  const isConnecting = useScriptConnectionStore((s) => s.isConnecting);
  const error = useScriptConnectionStore((s) => s.error);
  const config = useScriptConnectionStore((s) => s.config);
  const activeAdapter = useScriptConnectionStore((s) => s.activeAdapter);
  const connect = useScriptConnectionStore((s) => s.connect);
  const disconnect = useScriptConnectionStore((s) => s.disconnect);
  const setConfig = useScriptConnectionStore((s) => s.setConfig);
  const setIsConnected = useScriptConnectionStore((s) => s.setIsConnected);

  return {
    isConnected,
    setIsConnected,
    isConnecting,
    error,
    activeAdapter,
    connect,
    disconnect,
    setConfig,
    config,
  };
};


============================================================
FILE_PATH: src\features\page\hooks\usePageViewer.ts
============================================================
/* eslint-disable react-hooks/set-state-in-effect */
import { useState, useEffect, useId, useCallback } from "react";
import { useParams, useRouter } from "next/navigation";
import { useModalActions } from "@/hooks/useModal";
import { usePageStore } from "../store/usePageStore";
import { useEditor, useEngine } from "@/features/engine";
import { IEngine } from "@/features/engine/modules";
import { IComponent } from "@/features/engine/modules/types/component.type";

export const usePageViewer = () => {
  const loadingId = useId();
  const router = useRouter();
  const params = useParams();

  const pageId = params.pageId as string;
  const dashboardId = params.dashboardId as string;

  const { openModal } = useModalActions();
  const { fetchContent, page, saveCode } = usePageStore(pageId);
  const { isConnected, createEngine, runScript } = useEngine();
  const { sqlCode, jsCode, setJsCode, setSqlCode, setIsEditing, isEditing } =
    useEditor();

  const [componentStruct, setComponentStruct] = useState<IComponent | null>(
    null
  );

  // 1. ESTADO DE SEGUIMIENTO DE TRANSICIÓN
  const [lastPageId, setLastPageId] = useState<string>(pageId);

  // 2. ESTADO DE EJECUCIÓN
  const [isRunningScript, setIsRunningScript] = useState(true);

  const [engine, setEngine] = useState<IEngine | null>(null);

  // Inicializar Engine
  useEffect(() => {
    setEngine(createEngine());
  }, []);

  // Redirección
  useEffect(() => {
    if (!pageId && dashboardId) {
      router.replace(`/dashboard/${dashboardId}`);
    }
  }, [pageId, dashboardId, router]);

  // --- DETECCIÓN DE CAMBIO DE PÁGINA ---
  useEffect(() => {
    if (pageId !== lastPageId) {
      setComponentStruct(null);
      setIsRunningScript(true);
      setLastPageId(pageId);
    }
  }, [pageId, lastPageId]);

  // Fetch de contenido
  useEffect(() => {
    if (pageId && !page?.isLoaded && isConnected) {
      fetchContent();
    }
  }, [pageId, isConnected, page?.isLoaded, fetchContent]);

  // Ejecución del Script
  useEffect(() => {
    let isMounted = true;
    let timeoutId: NodeJS.Timeout;

    if (pageId !== lastPageId) return;

    if (!pageId || !page?.isLoaded || !isConnected || !engine) return;
    if (page.id !== pageId) return;

    // Caso: Página sin script
    if (!page.jsScript || page.jsScript.trim() === "") {
      if (isMounted) {
        setComponentStruct(null);
        // DELAY AGREGADO: Forzamos 200ms antes de quitar el loader
        timeoutId = setTimeout(() => {
          if (isMounted) setIsRunningScript(false);
        }, 1500);
      }
      return () => clearTimeout(timeoutId);
    }

    setIsRunningScript(true);

    runScript(page.jsScript, page.sqlScript, engine)
      .then(({ result }) => {
        if (isMounted) {
          setComponentStruct(result);
        }
      })
      .catch((err) => {
        console.error("Error ejecutando script:", err);
        if (isMounted) setComponentStruct(null);
      })
      .finally(() => {
        // DELAY AGREGADO: Forzamos 200ms al terminar el script
        timeoutId = setTimeout(() => {
          if (isMounted) setIsRunningScript(false);
        }, 200);
      });

    return () => {
      isMounted = false;
      if (timeoutId) clearTimeout(timeoutId);
    };
  }, [page, isConnected, engine, pageId, lastPageId]);

  // --- Handlers ---
  const handleOnOpenEditor = useCallback(() => {
    if (page?.jsScript) setJsCode(page?.jsScript ?? "");
    if (page?.sqlScript) setSqlCode(page?.sqlScript ?? "");
    setIsEditing(true);
  }, [setJsCode, setSqlCode, setIsEditing, page]);

  const handleConfigure = useCallback(() => {
    openModal("213123123_editor_modal");
  }, [openModal]);

  const handleOnCloseEditor = useCallback(() => {
    setIsEditing(false);
  }, [setIsEditing]);

  const onSave = useCallback(() => {
    saveCode(jsCode, sqlCode);
  }, [jsCode, sqlCode, saveCode]);

  // --- LÓGICA DE CARGA ---
  const isLoading =
    pageId !== lastPageId || // Transición instantánea
    !page ||
    !page.isLoaded ||
    page.id !== pageId ||
    isRunningScript; // Se mantiene true durante los 200ms extra

  return {
    engine,
    componentStruct,
    page,
    isLoading,
    isEditing,
    setIsEditing,
    loadingId,
    handleConfigure,
    handleOnCloseEditor,
    handleOnOpenEditor,
    onSave,
  };
};


============================================================
FILE_PATH: src\features\page\store\usePageStore.tsx
============================================================
import { create } from "zustand";
import { systemSupabase } from "@/lib/supabase/client";
import { Page } from "../types/page.types";
import { useParams } from "next/navigation";
import { useCallback, useMemo, useState } from "react";
import { IconName } from "@/components/ui/dynamic-icon";

interface PageState {
  pages: Record<string, Page & { isLoaded?: boolean }>;
  status: "idle" | "loading" | "succeeded" | "failed";
  fetchPages: (dashboardId: string) => Promise<void>;
  fetchPageContent: (pageId: string) => Promise<void>;
  updatePageLocal: (pageId: string, updates: Partial<Page>) => void;
  savePageRemote: (pageId: string, js: string, sql: string) => Promise<void>;
  updatePageSettings: (pageId: string, updates: Partial<Page>) => Promise<void>;
  addPageRemote: (data: {
    dashboardId?: string;
    name: string;
    icon: IconName;
    userId?: string;
  }) => Promise<void>;
  deletePageRemote: (id: string) => Promise<void>;
  fetchPublicPage: (pageId: string) => Promise<any>;
}

const DatabaseToStore = (item) => {
  return {
    icon: item.icon,
    id: item.id,
    name: item.name,
    dashboardId: item.dashbaord_id,
    sqlScript: item.sql_script,
    jsScript: item.js_script,
    isPublic: item.is_public,
  };
};

export const useStore = create<PageState>((set, get) => ({
  pages: {},
  status: "idle",

  fetchPages: async (dashboardId) => {
    const { data, error } = await systemSupabase
      .from("pages")
      .select("*")
      .eq("dashboard_id", dashboardId);
    if (error) throw error;

    const pages: Record<string, Page & { isLoaded?: boolean }> = {};

    data.forEach((item) => {
      const page = DatabaseToStore(item);
      pages[page.id] = { ...page, isLoaded: true };
    });

    set({ pages });
  },
  fetchPageContent: async (pageId) => {
    if (get().pages[pageId]?.jsScript) return;

    set({ status: "loading" });
    const { data, error } = await systemSupabase
      .from("pages")
      .select("*")
      .eq("id", pageId)
      .single();

    const page = DatabaseToStore(data);

    if (!error && data) {
      set((state) => ({
        pages: {
          ...state.pages,
          [pageId]: { ...state.pages[pageId], ...page, isLoaded: true },
        },
        status: "succeeded",
      }));
    } else {
      set({ status: "failed" });
    }
  },
  updatePageLocal: (pageId, updates) => {
    set((state) => ({
      pages: {
        ...state.pages,
        [pageId]: { ...state.pages[pageId], ...updates },
      },
    }));
  },
  savePageRemote: async (pageId, jsScript, sqlScript) => {
    get().updatePageLocal(pageId, { jsScript, sqlScript });

    await systemSupabase
      .from("pages")
      .update({ js_script: jsScript, sql_script: sqlScript })
      .eq("id", pageId);
  },
  updatePageSettings: async (pageId, updates) => {
    set((state) => ({
      pages: {
        ...state.pages,
        [pageId]: { ...state.pages[pageId], ...updates },
      },
    }));
    const { error } = await systemSupabase
      .from("pages")
      .update(updates)
      .eq("id", pageId);

    if (error) {
      console.error("Error updating page:", error);
      throw error;
    }
  },
  addPageRemote: async ({ dashboardId, name, icon, userId }) => {
    const { data, error } = await systemSupabase
      .from("pages")
      .insert({
        dashboard_id: dashboardId,
        user_id: userId,
        name,
        icon,
        js_script: "",
        sql_script: "",
      })
      .select()
      .single();

    if (error) throw error;

    set((state) => {
      const pages = { ...state.pages, [data.id]: DatabaseToStore(data) };
      return { ...state, pages };
    });
  },
  deletePageRemote: async (id) => {
    const { error } = await systemSupabase.from("pages").delete().eq("id", id);
    if (error) throw error;
    set((state) => {
      const pages = { ...state.pages };
      delete pages[id];
      return { ...state, pages };
    });
  },
  fetchPublicPage: async (pageId) => {
    set({ status: "loading" });
    // 2. Llamada RPC (Lógica que tenías en el Thunk)
    const { data, error } = await systemSupabase
      .rpc("get_public_page_details", { p_page_id: pageId })
      .maybeSingle();

    if (error) {
      set({ status: "failed" });
      throw error;
    }

    // 3. Si no hay data (es privada o no existe), retornamos null
    if (!data) {
      set({ status: "succeeded" }); // O 'idle', según prefieras manejar el "Not Found"
      return null;
    }

    // 4. Formatear y guardar en el Store
    /* const page = DatabaseToStore(data); */

    set((state) => ({
      /*       pages: {
        ...state.pages,
        [page.id]: { ...page, isLoaded: true },
      }, */
      status: "succeeded",
    }));

    return data;
  },
}));

export const usePageStore = (id?: string) => {
  const params = useParams();
  const pageId = id || (params?.pageId as string);
  const pagesMap = useStore((s) => s.pages);
  const status = useStore((s) => s.status);
  const fetchPagesAction = useStore((s) => s.fetchPages);
  const fetchPageContentAction = useStore((s) => s.fetchPageContent);
  const updatePageLocalAction = useStore((s) => s.updatePageLocal);
  const savePageRemoteAction = useStore((s) => s.savePageRemote);
  const updatePageSettingsAction = useStore((s) => s.updatePageSettings);
  const addPageAction = useStore((s) => s.addPageRemote);
  const deletePageAction = useStore((s) => s.deletePageRemote);
  const fetchPublicPage = useStore((s) => s.fetchPublicPage);

  const pages = useMemo(() => Object.values(pagesMap), [pagesMap]);
  const currentPage = useMemo(
    () => (pageId ? pagesMap[pageId] : undefined),
    [pagesMap, pageId]
  );

  const requirePageId = useCallback(() => {
    if (!pageId) {
      console.error("Operación fallida: No hay una página seleccionada.");
      return false;
    }
    return true;
  }, [pageId]);

  return {
    status,
    isLoading: status === "loading" || status === "idle",
    pages,
    page: currentPage,
    fetchPages: async (dashboardId: string) => {
      await fetchPagesAction(dashboardId);
    },
    fetchContent: async () => {
      if (requirePageId()) {
        await fetchPageContentAction(pageId);
      }
    },
    updateLocal: (updates: Partial<Page>) => {
      if (requirePageId()) {
        updatePageLocalAction(pageId, updates);
      }
    },
    saveCode: async (js: string, sql: string) => {
      if (requirePageId()) {
        await savePageRemoteAction(pageId, js, sql);
      }
    },
    updateSettings: async (updates: Partial<Page>) => {
      if (requirePageId()) {
        await updatePageSettingsAction(pageId, updates);
      }
    },
    renamePage: async (pageId: string, name: string) => {
      await updatePageSettingsAction(pageId, { name });
    },
    addPage: addPageAction,
    deletePage: deletePageAction,
    fetchPublicPage,
  };
};


============================================================
FILE_PATH: src\features\page\types\page.types.ts
============================================================
import { IconName } from "@/components/ui/dynamic-icon";

export interface Page {
  icon: IconName;
  name: string;
  id: string;
  dashboardId: string;
  sqlScript: string;
  jsScript: string;
  isPublic: boolean;
}


============================================================
FILE_PATH: src\hooks\use-mobile.tsx
============================================================
import * as React from "react";

const MOBILE_BREAKPOINT = 768;

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(
    undefined
  );

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener("change", onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener("change", onChange);
  }, []);

  return !!isMobile;
}


============================================================
FILE_PATH: src\hooks\useModal.tsx
============================================================
import { create } from "zustand";
import { useShallow } from "zustand/react/shallow";

interface ModalState {
  modals: Set<string>;
  openModals: string[];
  modalData: Record<string, any>;
  openModal: (id: string, data?: any) => void;
  closeModal: (id: string) => void;
  isOpen: (id: string) => boolean;
  registerModal: (id: string) => void;
  unRegisterModal: (id: string) => void;
  getModalData: (id: string) => any;
}

export const useModalStore = create<ModalState>((set, get) => ({
  modals: new Set(),
  openModals: [],
  modalData: {},
  isOpen: (id) => {
    return get().openModals.includes(id);
  },
  openModal: (id, data) => {
    set((state) => {
      // 2. Corrección: Evitar duplicados
      if (state.openModals.includes(id)) return state;

      return {
        ...state,
        openModals: [...state.openModals, id],
        // Guardamos la data asociada a este ID
        modalData: { ...state.modalData, [id]: data },
      };
    });
  },
  closeModal: (id) => {
    set((state) => {
      const newModalData = { ...state.modalData };
      delete newModalData[id];
      return {
        ...state,
        openModals: state.openModals.filter((i) => i !== id),
        modalData: newModalData,
      };
    });
  },
  registerModal: (id) =>
    set((state) => ({ ...state, modals: new Set(state.modals).add(id) })),

  unRegisterModal: (id) =>
    set((state) => {
      const modals = new Set(state.modals);
      modals.delete(id);
      return { ...state, modals };
    }),
  getModalData: (id) => {
    return get().modalData[id] || null;
  },
}));

export const useModalActions = () => {
  return useModalStore(
    useShallow((s) => ({
      openModal: s.openModal,
      closeModal: s.closeModal,
      registerModal: s.registerModal,
      unRegisterModal: s.unRegisterModal,
      getModalData: s.getModalData,
    }))
  );
};

export const useIsModalOpen = (id: string) => {
  return useModalStore((s) => s.openModals.includes(id));
};

export const useModalData = (id: string) => {
  // Esto hace una suscripción directa: si 'modalData[id]' cambia, el componente se actualiza.
  return useModalStore((s) => s.modalData[id]);
};


============================================================
FILE_PATH: src\hooks\useSearch.tsx
============================================================
import { useMemo, useDeferredValue, useState } from "react";

export const useSearch = <T,>(
  data: T[],
  filterFn: (item: T, query: string) => boolean
) => {
  const [query, setQuery] = useState("");
  const deferredQuery = useDeferredValue(query);

  const filteredData = useMemo(() => {
    if (!deferredQuery) return data;
    return data.filter((item) => filterFn(item, deferredQuery));
  }, [data, deferredQuery, filterFn]);

  const isSearching = query !== deferredQuery;

  return {
    results: filteredData,
    query,
    setQuery,
    isSearching,
  };
};


============================================================
FILE_PATH: src\hooks\useUser.tsx
============================================================
"use client";

import { create } from "zustand";
import { User, Session, AuthChangeEvent } from "@supabase/supabase-js";
import { systemSupabase } from "@/lib/supabase/client";
import { useShallow } from "zustand/react/shallow";

interface UserState {
  user: User | null;
  session: Session | null; // En prod es útil tener el token
  isLoading: boolean;

  // Acciones internas
  setSession: (session: Session | null) => void;
  setLoading: (isLoading: boolean) => void;
  signOut: () => Promise<void>;
}

const useStore = create<UserState>((set) => ({
  user: null,
  session: null,
  isLoading: true,

  setSession: (session) =>
    set({
      session,
      user: session?.user ?? null,
      isLoading: false,
    }),

  setLoading: (isLoading) => set({ isLoading }),

  signOut: async () => {
    // El listener detectará el evento SIGNED_OUT,
    // pero forzamos el estado local por UX inmediata
    set({ user: null, session: null, isLoading: false });
    await systemSupabase.auth.signOut();
  },
}));

// --- Hooks Selectores Optimizados ---
export const useUser = () => useStore((state) => state.user);
export const useSession = () => useStore((state) => state.session);
export const useAuthLoading = () => useStore((state) => state.isLoading);
export const useSignOut = () => useStore((state) => state.signOut);

// Exportamos las acciones para usarlas en el Provider
export const useAuthActions = () =>
  useStore(
    useShallow((state) => ({
      setSession: state.setSession,
      setLoading: state.setLoading,
    }))
  );


============================================================
FILE_PATH: src\lib\utils.ts
============================================================
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}


============================================================
FILE_PATH: src\lib\supabase\client.ts
============================================================
// src/lib/supabase/client.ts
import { createBrowserClient } from "@supabase/ssr";

// Esta instancia es UNICA y se reutiliza.
// Se conecta a las variables de entorno de TU proyecto.
export const systemSupabase = createBrowserClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);


============================================================
FILE_PATH: src\lib\supabase\server.ts
============================================================
import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createClient() {
  const cookieStore = await cookies();

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            );
          } catch {
            // El método setAll puede fallar si se llama desde un Server Component
            // (que es solo lectura). Esto se ignora para no romper la app.
          }
        },
      },
    }
  );
}


============================================================
FILE_PATH: src\providers\AuthProvider.tsx
============================================================
"use client";

import { useEffect } from "react";
import { systemSupabase } from "@/lib/supabase/client";
import { useAuthActions } from "@/hooks/useUser"; // Ajusta la ruta

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const { setSession, setLoading } = useAuthActions();

  useEffect(() => {
    const initializeAuth = async () => {
      try {
        const {
          data: { session },
        } = await systemSupabase.auth.getSession();
        setSession(session);
      } catch (error) {
        console.error("Error checking auth:", error);
        setSession(null);
      }
    };

    initializeAuth();
    const {
      data: { subscription },
    } = systemSupabase.auth.onAuthStateChange(async (_event, session) => {
      // Opcional: Manejar eventos específicos como 'PASSWORD_RECOVERY'

      setSession(session);
    });

    return () => {
      subscription.unsubscribe();
    };
  }, [setSession, setLoading]);

  return <>{children}</>;
}


============================================================
FILE_PATH: src\providers\index.tsx
============================================================
import { ReactNode } from "react";
import { ThemeProvider } from "./ThemeProvider";
import { AuthProvider } from "./AuthProvider";

const Providers = ({ children }: { children?: ReactNode }) => {
  return (
    <AuthProvider>
      <ThemeProvider
        attribute="class"
        defaultTheme="system"
        enableSystem
        disableTransitionOnChange
      >
        {children}
      </ThemeProvider>
    </AuthProvider>
  );
};

export default Providers;


============================================================
FILE_PATH: src\providers\ThemeProvider.tsx
============================================================
"use client";

import * as React from "react";
import { ThemeProvider as NextThemesProvider } from "next-themes";

export function ThemeProvider({
  children,
  ...props
}: React.ComponentProps<typeof NextThemesProvider>) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}

