--- PROJECT EXPORT ---
Root: C:\Users\ASUS\Documents\projects\flex-core


============================================================
FILE_PATH: components.json
============================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/app/globals.css",
    "baseColor": "zinc",
    "cssVariables": true,
    "prefix": ""
  },
  "iconLibrary": "lucide",
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "registries": {}
}


============================================================
FILE_PATH: next-env.d.ts
============================================================
/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/dev/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


============================================================
FILE_PATH: next.config.ts
============================================================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {};

export default nextConfig;


============================================================
FILE_PATH: package.json
============================================================
{
  "name": "flex-core",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@dnd-kit/core": "^6.3.1",
    "@dnd-kit/modifiers": "^9.0.0",
    "@dnd-kit/sortable": "^10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "@hookform/resolvers": "^5.2.2",
    "@monaco-editor/react": "^4.7.0",
    "@radix-ui/react-checkbox": "^1.3.3",
    "@radix-ui/react-context-menu": "^2.2.16",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.16",
    "@radix-ui/react-label": "^2.1.8",
    "@radix-ui/react-popover": "^1.1.15",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-separator": "^1.1.8",
    "@radix-ui/react-slot": "^1.2.4",
    "@radix-ui/react-switch": "^1.2.6",
    "@radix-ui/react-tabs": "^1.1.13",
    "@radix-ui/react-tooltip": "^1.2.8",
    "@reduxjs/toolkit": "^2.11.2",
    "@supabase/ssr": "^0.8.0",
    "@supabase/supabase-js": "^2.89.0",
    "@tanstack/react-table": "^8.21.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "lucide-react": "^0.562.0",
    "next": "16.1.0",
    "next-themes": "^0.4.6",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "react-hook-form": "^7.69.0",
    "react-redux": "^9.2.0",
    "redux-persist": "^6.0.0",
    "sonner": "^2.0.7",
    "sql.js": "^1.13.0",
    "tailwind-merge": "^3.4.0",
    "uuid": "^13.0.0",
    "zod": "^4.2.1",
    "zustand": "^5.0.9"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "autoprefixer": "^10.4.23",
    "eslint": "^9",
    "eslint-config-next": "16.1.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.18",
    "tw-animate-css": "^1.4.0",
    "typescript": "^5"
  }
}


============================================================
FILE_PATH: tsconfig.json
============================================================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noImplicitAny": false,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}


============================================================
FILE_PATH: src\middleware.ts
============================================================
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

// 1. Definimos rutas para f√°cil mantenimiento
const publicRoutes = ["/login", "/auth", "/api/webhooks", "/view"]; // Rutas accesibles sin login
const authRoutes = ["/login", "/register"]; // Rutas que NO debe ver un usuario logueado

export async function middleware(request: NextRequest) {
  // Inicializamos la respuesta base
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll();
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => {
            request.cookies.set({ name, value, ...options });
            response = NextResponse.next({
              request: {
                headers: request.headers,
              },
            });
            response.cookies.set({ name, value, ...options });
          });
        },
      },
    }
  );

  // Verificamos al usuario (Seguro pero a√±ade latencia de red)
  const {
    data: { user },
  } = await supabase.auth.getUser();

  const url = request.nextUrl.clone();
  const path = url.pathname;

  // --- CASO A: NO HAY USUARIO (No Logueado) ---
  if (!user) {
    // Verificamos si la ruta actual empieza con alguna de las rutas p√∫blicas
    const isPublic = publicRoutes.some((route) => path.startsWith(route));

    if (!isPublic) {
      // MEJORA CR√çTICA: Si es una ruta de API, devolvemos 401 JSON, no redirect
      if (path.startsWith("/api")) {
        return NextResponse.json({ message: "Unauthorized" }, { status: 401 });
      }

      // Para el resto de la app, mandamos al login
      url.pathname = "/login";
      // A√±adimos la ruta original como query param para redirigir despu√©s del login (Opcional pero recomendado)
      // url.searchParams.set("next", path);
      return NextResponse.redirect(url);
    }
  }

  // --- CASO B: HAY USUARIO (Logueado) ---
  if (user) {
    // Si intenta entrar a Login o Register
    const isAuthRoute = authRoutes.some((route) => path.startsWith(route));

    // Si intenta entrar a Login, Register O a la ra√≠z "/"
    if (isAuthRoute || path === "/") {
      url.pathname = "/gallery"; // Redirecci√≥n al Dashboard
      return NextResponse.redirect(url);
    }
  }

  return response;
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * Feel free to modify this pattern to include more paths.
     */
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};


============================================================
FILE_PATH: src\app\globals.css
============================================================
@import "tailwindcss";
@import "tw-animate-css";
@custom-variant dark (&:is(.dark *));
/*
Source - https://stackoverflow.com/a
Posted by rozsazoltan, modified by community. See post 'Timeline' for change history
Retrieved 2025-12-25, License - CC BY-SA 4.0
*/

/* --- GRID SYSTEM (Cols, Rows, Spans) --- */
@source inline('{,sm:,md:,lg:,xl:,2xl:}{,hover:}{grid-cols,col-span,grid-rows,row-span,col,row}-{1,2,3,4,5,6,7,8,9,10,11,12}');

/* --- GAP (Spacing) --- */
@source inline('{,sm:,md:,lg:,xl:,2xl:}{,hover:}{gap,gap-x,gap-y}-{0,0.5,1,1.5,2,2.5,3,3.5,4,5,6,7,8,9,10,11,12,14,16,20,24,28,32,36,40,44,48,52,56,60,64,72,80,96}');

/* --- MARGINS (m, mx, my, mt, mb, ml, mr) --- */
@source inline('{,sm:,md:,lg:,xl:,2xl:}{,hover:}{m,mx,my,mt,mb,ml,mr,px,py,pl,pr,pt,pb,p}-{auto,0,0.5,1,1.5,2,2.5,3,3.5,4,5,6,7,8,9,10,11,12,14,16,20,24,28,32,36,40,44,48,52,56,60,64,72,80,96}');

/* --- SIZING: Width, Height, Size (Numeric + Keywords) --- */
/* AHORA INCLUYE 'size' (ancho + alto a la vez) */
@source inline('{,sm:,md:,lg:,xl:,2xl:}{,hover:}{w,h,size}-{auto,px,full,screen,min,max,fit,0,0.5,1,1.5,2,2.5,3,3.5,4,5,6,7,8,9,10,11,12,14,16,20,24,28,32,36,40,44,48,52,56,60,64,72,80,96}');

/* --- SIZING: Width, Height, Size (Fractions) --- */
@source inline('{,sm:,md:,lg:,xl:,2xl:}{,hover:}{w,h,size}-{1/2,1/3,2/3,1/4,2/4,3/4,1/5,2/5,3/5,4/5,1/6,2/6,3/6,4/6,5/6,1/12,2/12,3/12,4/12,5/12,6/12,7/12,8/12,9/12,10/12,11/12}');

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --radius-2xl: calc(var(--radius) + 8px);
  --radius-3xl: calc(var(--radius) + 12px);
  --radius-4xl: calc(var(--radius) + 16px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.141 0.005 285.823);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.141 0.005 285.823);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.141 0.005 285.823);
  --primary: oklch(0.21 0.006 285.885);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.967 0.001 286.375);
  --secondary-foreground: oklch(0.21 0.006 285.885);
  --muted: oklch(0.967 0.001 286.375);
  --muted-foreground: oklch(0.552 0.016 285.938);
  --accent: oklch(0.967 0.001 286.375);
  --accent-foreground: oklch(0.21 0.006 285.885);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.92 0.004 286.32);
  --input: oklch(0.92 0.004 286.32);
  --ring: oklch(0.705 0.015 286.067);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.141 0.005 285.823);
  --sidebar-primary: oklch(0.21 0.006 285.885);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.967 0.001 286.375);
  --sidebar-accent-foreground: oklch(0.21 0.006 285.885);
  --sidebar-border: oklch(0.92 0.004 286.32);
  --sidebar-ring: oklch(0.705 0.015 286.067);
}

.dark {
  --background: oklch(0.141 0.005 285.823);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.21 0.006 285.885);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.21 0.006 285.885);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.92 0.004 286.32);
  --primary-foreground: oklch(0.21 0.006 285.885);
  --secondary: oklch(0.274 0.006 286.033);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.274 0.006 286.033);
  --muted-foreground: oklch(0.705 0.015 286.067);
  --accent: oklch(0.274 0.006 286.033);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.552 0.016 285.938);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.21 0.006 285.885);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.274 0.006 286.033);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.552 0.016 285.938);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}


============================================================
FILE_PATH: src\app\layout.tsx
============================================================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { Providers } from "@/providers/Providers";
import { Toaster } from "sonner";
const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <Providers>{children}</Providers>
        <Toaster richColors position="top-center" />
      </body>
    </html>
  );
}


============================================================
FILE_PATH: src\app\not-found.tsx
============================================================
"use client"; // üëà Importante para que funcionen los eventos onClick

import Link from "next/link";
import { useRouter } from "next/navigation"; // Hook de navegaci√≥n de Next.js
import { Button } from "@/components/ui/button";
import { MoveLeft, Home, FileQuestion } from "lucide-react";

export default function NotFound() {
  const router = useRouter();

  return (
    <div className="flex h-screen w-full flex-col items-center justify-center bg-background px-4 text-center">
      {/* Icono Decorativo */}
      <div className="flex h-20 w-20 items-center justify-center rounded-full bg-muted shadow-sm animate-in zoom-in duration-300">
        <FileQuestion className="h-10 w-10 text-primary" />
      </div>

      {/* Texto Principal */}
      <h1 className="mt-6 text-5xl font-extrabold tracking-tight text-foreground sm:text-7xl">
        404
      </h1>

      <h2 className="mt-4 text-2xl font-semibold tracking-tight text-foreground">
        P√°gina no encontrada
      </h2>

      <p className="mt-2 max-w-md text-muted-foreground">
        Lo sentimos, no pudimos encontrar la p√°gina que est√°s buscando. Verifica
        la URL o regresa al inicio.
      </p>

      <p className="mt-12 text-sm text-muted-foreground">
        C√≥digo de error: 404
      </p>
    </div>
  );
}


============================================================
FILE_PATH: src\app\page.tsx
============================================================
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Loader2, AlertCircle } from "lucide-react";
import { systemSupabase } from "@/lib/supabase/client";
import { toast } from "sonner";

export default function LoginPage() {
  const router = useRouter();

  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [isSignUp, setIsSignUp] = useState(false); // Toggle entre Login y Registro

  const handleAuth = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);

    try {
      if (isSignUp) {
        // --- L√≥gica de REGISTRO ---
        const { error } = await systemSupabase.auth.signUp({
          email,
          password,
          options: {
            emailRedirectTo: `${location.origin}/auth/callback`,
          },
        });
        if (error) throw error;
        toast.success("¬°Cuenta creada con √©xito!", {
          description: "Por favor, revisa tu email para confirmar tu cuenta.",
          duration: 5000, // Dura un poco m√°s para que lean
        });
      } else {
        // --- L√≥gica de LOGIN ---
        const { error } = await systemSupabase.auth.signInWithPassword({
          email,
          password,
        });
        if (error) throw error;
        toast.success("¬°Bienvenido de nuevo!", {
          description: "Iniciando sesi√≥n...",
        });
        router.push("/gallery"); // Redirigir al √©xito
        router.refresh();
      }
    } catch (err: any) {
      console.error(err); // √ötil para depurar en consola
      toast.error("Ocurri√≥ un error", {
        description: err.message || "No se pudo completar la solicitud.",
      });
    } finally {
      setIsLoading(false);
    }
  };
  /* 
  const handleGithubLogin = async () => {
    setIsLoading(true);
    const { error } = await systemSupabase.auth.signInWithOAuth({
      provider: "github",
      options: {
        redirectTo: `${location.origin}/auth/callback`,
      },
    });
    if (error) setError(error.message);
    // No set false isLoading aqu√≠ porque redirige
  }; */

  return (
    <div className="flex items-center justify-center min-h-screen p-4">
      <Card className="w-full max-w-md shadow-lg">
        <CardHeader className="space-y-1">
          <CardTitle className="text-2xl font-bold text-center">
            {isSignUp ? "Crear cuenta" : "Bienvenido de nuevo"}
          </CardTitle>
          <CardDescription className="text-center">
            {isSignUp
              ? "Ingresa tus datos para registrarte en la plataforma"
              : "Ingresa tu email y contrase√±a para acceder"}
          </CardDescription>
        </CardHeader>

        <CardContent className="space-y-4">
          <form onSubmit={handleAuth} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                type="email"
                placeholder="nombre@ejemplo.com"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                disabled={isLoading}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="password">Contrase√±a</Label>
              <Input
                id="password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                disabled={isLoading}
              />
            </div>

            <Button className="w-full" type="submit" disabled={isLoading}>
              {isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              {isSignUp ? "Registrarse" : "Iniciar Sesi√≥n"}
            </Button>
          </form>
        </CardContent>

        <CardFooter className="justify-center">
          <Button
            variant="link"
            className="text-sm text-muted-foreground"
            onClick={() => setIsSignUp(!isSignUp)}
          >
            {isSignUp
              ? "¬øYa tienes cuenta? Inicia sesi√≥n"
              : "¬øNo tienes cuenta? Reg√≠strate"}
          </Button>
        </CardFooter>
      </Card>
    </div>
  );
}


============================================================
FILE_PATH: src\app\auth\callback\route.ts
============================================================
import { NextResponse } from "next/server";
import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url);

  // El flujo PKCE devuelve un 'code'
  const code = searchParams.get("code");

  // "next" es a donde redirigir despu√©s (por defecto /gallery)
  const next = searchParams.get("next") ?? "/gallery";

  if (code) {
    const cookieStore = await cookies();

    const supabase = createServerClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      {
        cookies: {
          getAll() {
            return cookieStore.getAll();
          },
          setAll(cookiesToSet) {
            try {
              cookiesToSet.forEach(({ name, value, options }) =>
                cookieStore.set(name, value, options)
              );
            } catch {
              // El m√©todo setAll fue llamado desde un Server Component.
              // Esto puede ignorarse si tienes middleware refrescando sesiones.
            }
          },
        },
      }
    );

    // Intercambiamos el c√≥digo por la sesi√≥n del usuario
    const { error } = await supabase.auth.exchangeCodeForSession(code);

    if (!error) {
      // Login exitoso: redirigir a la app
      return NextResponse.redirect(`${origin}${next}`);
    }
  }

  // Si no hay c√≥digo o hubo error, mandar a error
  return NextResponse.redirect(`${origin}/auth/auth-code-error`);
}


============================================================
FILE_PATH: src\app\dashboard\[dashboardId]\layout.tsx
============================================================
"use client";

import { ReactNode } from "react";
import { SidebarProvider } from "@/components/ui/sidebar";
import {
  DashboardHeader,
  DashboardSidebar,
  LoadingIndicator,
  useDashboard,
} from "@/features/dashboard";

export default function DashboardLayout({ children }: { children: ReactNode }) {
  const {
    currentPage,
    loadingId,
    handlePublicToggle,
    handleOpenView,
    handleOpenSettings,
  } = useDashboard();

  return (
    <SidebarProvider>
      <DashboardSidebar />
      <main className="grid h-screen w-full min-w-0 grid-rows-[60px_1fr] overflow-hidden transition-[width] duration-300 ease-linear">
        <DashboardHeader
          currentPage={currentPage}
          onPublicToggle={handlePublicToggle}
          onOpenView={handleOpenView}
          onSettings={handleOpenSettings}
        />
        <div className="w-full overflow-auto bg-background">{children}</div>
      </main>
      <LoadingIndicator loadingId={loadingId} />
    </SidebarProvider>
  );
}


============================================================
FILE_PATH: src\app\dashboard\[dashboardId]\page.tsx
============================================================
export default function Dashboard() {
  return <div className="w-full h-full"></div>;
}


============================================================
FILE_PATH: src\app\dashboard\[dashboardId]\page\[pageId]\page.tsx
============================================================
"use client";

import { ComponentEditorModal } from "@/components/custom/Modals/CreateComponentModal";
import { DynamicComponent } from "@/components/DynamicComponents/DynamicComponent";
import { Loader2, Settings } from "lucide-react";
import { usePageViewer } from "../../../../../features/page/hooks/usePageViewer";
import { Button } from "@/components/ui/button";

export default function Page() {
  const {
    componentStruct,
    page,
    handleConfigure,
    handleOnCloseEditor,
    isLoading,
    isEditing,
    handleOnOpenEditor, // Asumo que lo usas en el modal si es necesario
    onSave,
    isSaving,
  } = usePageViewer();

  return (
    <>
      <div className="w-full h-full relative">
        {isLoading ? (
          <div className="absolute inset-0 z-50 flex flex-col items-center justify-center gap-2 bg-background/80 backdrop-blur-sm animate-in fade-in">
            <Loader2 className="h-10 w-10 animate-spin text-primary" />
            <p className="text-sm text-muted-foreground">
              Procesando cambios...
            </p>
          </div>
        ) : null}
        {!isEditing && !isLoading && (
          <>
            {componentStruct ? (
              <DynamicComponent
                data={componentStruct}
                context={componentStruct.context}
              />
            ) : (
              /* Estado Vac√≠o */
              <div className="w-full min-h-full flex justify-center items-center">
                <Button
                  onClick={handleConfigure}
                  variant="outline"
                  className="w-40 h-40 flex flex-col gap-2 text-lg"
                >
                  <Settings className="size-8 mb-2" />
                  Configurar P√°gina
                  <span className="text-xs text-muted-foreground font-normal">
                    {page?.name || "Sin t√≠tulo"}
                  </span>
                </Button>
              </div>
            )}
          </>
        )}
      </div>
      <ComponentEditorModal
        id={"213123123_editor_modal"}
        onClose={handleOnCloseEditor}
        onOpen={handleOnOpenEditor}
        onSave={onSave}
        isSaving={isSaving}
      />
    </>
  );
}


============================================================
FILE_PATH: src\app\gallery\page.tsx
============================================================
"use client";

import {
  DashboardGrid,
  GalleryHeader,
  GalleryModals,
  GallerySearchBar,
  useDashboardGallery,
} from "@/features/gallery";

export default function DashboardGallery() {
  const {
    results,
    query,
    onChange,
    onClick,
    onAdd,
    onDelete,
    onConfirmDelete,
    onConfirm,
    onEdit,
    addFormId,
    editFormId,
    confirmId,
    loadingModalId,
    onConfirmEdit,
    onSignOut,
  } = useDashboardGallery();

  return (
    <div className="p-8 flex flex-col min-h-screen">
      <GalleryHeader onSignOut={onSignOut} />
      <div className="w-full flex-1">
        <GallerySearchBar query={query} onChange={onChange} onAdd={onAdd} />
        <DashboardGrid
          dashboards={results}
          onClick={onClick}
          onEdit={onEdit}
          onDelete={onDelete}
        />
        <GalleryModals
          addFormId={addFormId}
          editFormId={editFormId}
          confirmId={confirmId}
          loadingModalId={loadingModalId}
          onConfirm={onConfirm}
          onConfirmEdit={onConfirmEdit}
          onConfirmDelete={onConfirmDelete}
        />
      </div>
    </div>
  );
}


============================================================
FILE_PATH: src\app\login\page.tsx
============================================================
"use client";
import { Card, CardContent, CardFooter } from "@/components/ui/card";
import { AuthButtons, AuthHeader, LoginForm, useAuth } from "@/features/auth";

export default function LoginPage() {
  const state = useAuth();

  return (
    <div className="flex items-center justify-center min-h-screen p-4">
      <Card className="w-full max-w-md shadow-lg">
        <AuthHeader isSignUp={state.isSignUp} />
        <CardContent className="space-y-4">
          <LoginForm {...state} />
        </CardContent>
        <CardFooter className="justify-center">
          <AuthButtons
            isSignUp={state.isSignUp}
            setIsSignUp={state.setIsSignUp}
          />
        </CardFooter>
      </Card>
    </div>
  );
}


============================================================
FILE_PATH: src\app\view\[pageId]\page.tsx
============================================================
// app/view/[pageId]/page.tsx
"use client";

import { DynamicComponent } from "@/components/DynamicComponents/DynamicComponent";
import { notFound } from "next/navigation";
import { Loader2 } from "lucide-react";
import { usePublicPageViewer } from "./usePublicPageViewer";

export default function PublicPageView() {
  const { componentStruct, isLoading, isAccessDenied } = usePublicPageViewer();

  if (isAccessDenied) {
    notFound();
  }

  if (isLoading) {
    return (
      <div className="flex h-screen w-full items-center justify-center bg-background">
        <Loader2 className="h-10 w-10 animate-spin text-primary" />
      </div>
    );
  }

  return (
    // CAMBIO 1: Usamos 'h-screen' (altura fija de ventana) en lugar de min-h-screen
    // CAMBIO 2: Agregamos 'flex flex-col' para controlar el layout de los hijos
    <div className="w-full h-screen bg-background flex flex-col overflow-hidden">
      {componentStruct ? (
        // CAMBIO 3: Envolvemos el componente en un div con 'flex-1'
        // Esto fuerza al div a ocupar todo el espacio vertical sobrante
        <div className="w-full flex-1 relative overflow-auto">
          <DynamicComponent
            data={componentStruct}
            context={componentStruct.context}
            // Opcional: Si DynamicComponent soporta className, p√°sale h-full tambi√©n
            // className="w-full h-full"
          />
        </div>
      ) : (
        <div className="flex h-full items-center justify-center text-muted-foreground">
          La p√°gina no gener√≥ contenido.
        </div>
      )}
    </div>
  );
}


============================================================
FILE_PATH: src\app\view\[pageId]\usePublicPageViewer.ts
============================================================
// hooks/usePublicPageViewer.ts
import { useState, useEffect, useRef } from "react";
import { useParams } from "next/navigation";
import { useAppDispatch } from "@/lib/redux/hooks";
import { fetchPageWithConfig } from "@/lib/redux/features/pageSlice";
import { runScript } from "@/lib/runScript/runScript";
import { Component } from "@/lib/ComponentBuilders/Component";
import { useScriptActions } from "@/hooks/useScriptActions";
import { useScriptConnectionActions } from "@/hooks/useScriptConnectionActions";

export const usePublicPageViewer = () => {
  const params = useParams();
  const dispatch = useAppDispatch();
  const pageId = params.pageId as string;

  const { ConectionConfig } = useScriptConnectionActions();
  const scriptContext = useScriptActions();
  const scriptContextRef = useRef(scriptContext);

  const [componentStruct, setComponentStruct] = useState<Component | null>(
    null
  );
  const [isLoading, setIsLoading] = useState(true);
  const [isAccessDenied, setIsAccessDenied] = useState(false);

  useEffect(() => {
    scriptContextRef.current = scriptContext;
  }, [scriptContext]);

  useEffect(() => {
    let isMounted = true;

    const loadPublicPage = async () => {
      // Reiniciamos estados al cambiar de p√°gina
      setIsAccessDenied(false);
      setComponentStruct(null);

      if (!pageId) return;

      try {
        setIsLoading(true);

        const actionResult = await dispatch(fetchPageWithConfig(pageId));

        // Verificamos si la petici√≥n fall√≥ t√©cnicamente
        if (actionResult.meta.requestStatus === "rejected") {
          throw new Error("Error t√©cnico al obtener la p√°gina");
        }

        const data = actionResult.payload as any;

        // --- VALIDACI√ìN DE ACCESO ---
        // Si data es null (gracias a maybeSingle), significa Privado o No Existe.
        if (!data) {
          if (isMounted) setIsAccessDenied(true);
          return; // Salimos silenciosamente, sin lanzar Error
        }

        const { js_script, sql_script, dashboard_config } = data;

        // 2. Conectar a la Base de Datos del Cliente
        if (dashboard_config && dashboard_config.type) {
          // Pasamos false para no intentar guardar en Redux del Dashboard inexistente
          await ConectionConfig(dashboard_config, false);
        }

        // 3. Ejecutar el Script
        if (js_script) {
          const { result } = await runScript(
            js_script,
            sql_script || "",
            scriptContextRef.current
          );

          if (isMounted) {
            setComponentStruct(result);
          }
        }
      } catch (error) {
        // Solo logueamos errores reales de ejecuci√≥n, no bloqueos de acceso
        console.error("Error ejecutando p√°gina p√∫blica:", error);
      } finally {
        if (isMounted) setIsLoading(false);
      }
    };

    loadPublicPage();

    return () => {
      isMounted = false;
    };
    // IMPORTANTE: Agregamos las dependencias correctas para que recargue si cambia el ID
  }, []);

  return {
    componentStruct,
    isLoading,
    isAccessDenied,
  };
};


============================================================
FILE_PATH: src\components\custom\DynamicForm.tsx
============================================================
/* eslint-disable react-hooks/exhaustive-deps */
/* eslint-disable @typescript-eslint/no-explicit-any */
"use client";

import {
  ControllerRenderProps,
  useForm,
  UseFormSetError,
} from "react-hook-form";
import { z } from "zod";
import { zodResolver } from "@hookform/resolvers/zod";
import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";

import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { memo, useEffect, useState } from "react";
import { IconPicker } from "./IconPicker";

export type FieldConfig = {
  name: string;
  label: string;
  type: "text" | "number" | "email" | "select" | "date" | "icon";
  placeholder?: string;
  options?: { label: string; value: string }[]; // Solo para selects
  className?: string; // Para controlar el ancho (col-span-1, etc.)
};

export interface DynamicFormProps {
  schema: z.ZodType<any, any>; // El esquema de validaci√≥n Zod
  defaultValues?: any; // Los datos iniciales
  fields?: FieldConfig[]; // La lista de campos a dibujar
  type?: "new" | "update";
  confirmName?: string;
  submitLabel?: string;
  onSubmit?: (data: any, setError: UseFormSetError<any>) => void;
  className?: string;
  hideWhenEmpty?: boolean;
}

const FormDynamicInput = memo(
  ({
    field,
    fieldConfig,
  }: {
    field: ControllerRenderProps<any, string>;
    fieldConfig: FieldConfig;
  }) => {
    switch (fieldConfig.type) {
      case "icon":
        return (
          <IconPicker
            value={field.value}
            onChange={field.onChange}
            placeholder={fieldConfig.placeholder}
          />
        );
      case "select":
        return (
          <Select onValueChange={field.onChange} value={field.value ?? ""}>
            <FormControl>
              <SelectTrigger>
                <SelectValue placeholder={fieldConfig.placeholder} />
              </SelectTrigger>
            </FormControl>
            <SelectContent>
              {fieldConfig.options?.map((opt) => (
                <SelectItem key={opt.value} value={opt.value}>
                  {opt.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        );
      default:
        return (
          <Input
            {...field}
            value={field.value ?? ""}
            type={fieldConfig.type}
            placeholder={fieldConfig.placeholder}
            // Truco para inputs num√©ricos en react-hook-form
            onChange={(e) => {
              const val =
                fieldConfig.type === "number"
                  ? e.target.value == ""
                    ? ""
                    : Number(e.target.value)
                  : e.target.value;
              field.onChange(val);
            }}
          />
        );
    }
  }
);
FormDynamicInput.displayName = "FormDynamicInput";

export function DynamicForm({
  schema,
  defaultValues = {},
  fields = [],
  onSubmit,
  submitLabel,
  confirmName,
  className,
  hideWhenEmpty,
}: DynamicFormProps) {
  const [show, setShow] = useState(false);

  const form = useForm({
    resolver: schema ? zodResolver(schema) : undefined,
    defaultValues: defaultValues,
    mode: "onChange",
  });

  const defaultValuesJson = JSON.stringify(defaultValues);

  useEffect(() => {
    if (defaultValues) {
      form.reset(defaultValues);
    }
  }, [defaultValuesJson, form]);

  const handleOnChange = () => {
    setShow(JSON.stringify(form.getValues()) != JSON.stringify(defaultValues));
  };

  const handleReset = (e: React.MouseEvent<HTMLButtonElement>) => {
    e.preventDefault();
    form.reset(defaultValues);
    setShow(false);
  };
  const handleSubmitWrapper = (data: any) => {
    if (onSubmit) {
      onSubmit(data, form.setError);
    }
  };
  return (
    <Form {...form}>
      <form
        onSubmit={form.handleSubmit(handleSubmitWrapper)}
        onChange={handleOnChange}
        className="space-y-6"
      >
        {/* GRID DIN√ÅMICO */}
        <div className={`grid grid-cols-1 ${className} gap-4`}>
          {fields.map((fieldConfig) => (
            <FormField
              key={fieldConfig.name}
              control={form.control}
              name={fieldConfig.name}
              render={({ field }) => (
                <FormItem className={fieldConfig.className || "col-span-1"}>
                  <FormLabel>{fieldConfig.label}</FormLabel>
                  <FormControl>
                    <FormDynamicInput field={field} fieldConfig={fieldConfig} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          ))}
        </div>
        {(show || !hideWhenEmpty) && (
          <div className="flex w-full gap-4">
            <Button
              type="button"
              variant="outline"
              className=" md:w-auto"
              onClick={handleReset}
            >
              Cancelar
            </Button>
            <Button type="submit" className=" md:w-auto">
              {submitLabel} {confirmName}
            </Button>
          </div>
        )}
      </form>
    </Form>
  );
}


============================================================
FILE_PATH: src\components\custom\DynamicIcon.tsx
============================================================
import { AlertCircle, icons } from "lucide-react";
import { LucideProps } from "lucide-react";

export type IconName = keyof typeof icons;
interface DynamicIconProps extends LucideProps {
  name: IconName;
}

export const DynamicIcon = ({ name, ...props }: DynamicIconProps) => {
  // 1. Buscamos el icono en el objeto 'icons' usando el string
  const LucideIcon = icons[name];

  // 2. Si el icono no existe (ej: error de tipeo en BD), devolvemos null o un icono por defecto
  if (!LucideIcon) {
    // Opcional: Retorna un icono de "alerta" o nada
    return <AlertCircle />;
  }

  return <LucideIcon {...props} />;
};


============================================================
FILE_PATH: src\components\custom\IconPicker.tsx
============================================================
import { Check, ChevronsUpDown } from "lucide-react";
import { icons } from "lucide-react"; // Importamos todos los iconos
import { cn } from "@/lib/utils";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command";

import { useState } from "react";
import { Button } from "../ui/button";

export const IconPicker = ({
  value,
  onChange,
  placeholder = "Seleccionar icono...",
}: {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
}) => {
  const [open, setOpen] = useState(false);

  // Convertimos el objeto 'icons' en un array para poder mapearlo
  // NOTA: Esto carga todos los iconos, ten cuidado con el bundle size en producci√≥n.
  const iconList = Object.keys(icons) as (keyof typeof icons)[];

  // Componente para renderizar el icono seleccionado din√°micamente
  const SelectedIcon = value ? icons[value as keyof typeof icons] : null;

  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          role="combobox"
          aria-expanded={open}
          className="w-full justify-between"
        >
          {value ? (
            <div className="flex items-center gap-2">
              {/* Renderizamos el icono visualmente si existe */}
              {SelectedIcon && <SelectedIcon className="h-4 w-4" />}
              <span>{value}</span>
            </div>
          ) : (
            <span className="text-muted-foreground">{placeholder}</span>
          )}
          <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-[200px] p-0" align="start">
        <Command>
          <CommandInput placeholder="Buscar icono..." />
          <CommandList>
            <CommandEmpty>No se encontr√≥ el icono.</CommandEmpty>
            <CommandGroup>
              {/* Limitamos a los primeros 50 o 100 para no congelar la UI si hay demasiados, 
                  o usamos virtualizaci√≥n si es necesario. Aqu√≠ renderizo todos simplificado */}
              {iconList.map((iconName) => {
                const IconComponent = icons[iconName];
                return (
                  <CommandItem
                    key={iconName}
                    value={iconName}
                    onSelect={(currentValue) => {
                      // Shadcn command a veces devuelve lowercase, aseguramos el valor correcto
                      onChange(currentValue === value ? "" : iconName);
                      setOpen(false);
                    }}
                  >
                    <Check
                      className={cn(
                        "mr-2 h-4 w-4",
                        value === iconName ? "opacity-100" : "opacity-0"
                      )}
                    />
                    <div className="flex items-center gap-2">
                      <IconComponent className="h-4 w-4 text-muted-foreground" />
                      <span>{iconName}</span>
                    </div>
                  </CommandItem>
                );
              })}
            </CommandGroup>
          </CommandList>
        </Command>
      </PopoverContent>
    </Popover>
  );
};


============================================================
FILE_PATH: src\components\custom\Modal.tsx
============================================================
"use client";

import { ReactNode, useEffect, useLayoutEffect } from "react";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { useModals } from "../../providers/ModalProvider";

export interface ModalProps {
  id: string; // EL ID ES OBLIGATORIO Y √öNICO
  triggerText?: string;
  title?: string;
  description?: string;
  className?: string;
  children?: ReactNode; // Aqu√≠ inyectaremos los inputs
  disableOutside?: boolean;
  disableEscape?: boolean;
  onOpen?: () => void;
  onClose?: () => void;
}

export function Modal({
  triggerText,
  title,
  children,
  id,
  description,
  className,
  disableEscape,
  disableOutside,
  onClose,
  onOpen,
}: ModalProps) {
  const { isModalOpen, closeModal, registerModal, unregisterModal } =
    useModals();

  // Obtenemos el estado actual desde el contexto
  const isOpen = isModalOpen(id);

  // EFECTO DE REGISTRO
  useLayoutEffect(() => {
    // 1. Al montar: Registrar ID
    registerModal(id);

    // 2. Al desmontar: Eliminar ID (y cerrar si estaba abierto)
    return () => {
      unregisterModal(id);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [id]); // S

  useEffect(() => {
    if (isOpen) {
      // Si isOpen pasa a true, ejecutamos onOpen
      onOpen?.();
    }
    // No necesitamos un else para onClose aqu√≠, porque ese ya lo manejas
    // en el onOpenChange o cuando isOpen cambia a false externamente
  }, [isOpen, onOpen]);

  const openChange = (open: boolean) => {
    if (!open) {
      onClose?.();
      closeModal(id);
      return;
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={openChange}>
      <DialogPortal>
        {triggerText && (
          <DialogTrigger asChild>
            <Button>{triggerText}</Button>
          </DialogTrigger>
        )}

        <DialogContent
          className={"sm:max-w-106.25 " + className}
          onEscapeKeyDown={(e) => {
            if (disableEscape) e.preventDefault();
          }}
          onInteractOutside={(e) => {
            if (disableOutside) e.preventDefault();
          }}
        >
          <DialogHeader className="">
            <DialogTitle>{title}</DialogTitle>
          </DialogHeader>

          <DialogDescription className={!description ? "sr-only" : ""}>
            {description}
          </DialogDescription>

          <div className="mt-4">{children}</div>
        </DialogContent>
      </DialogPortal>
    </Dialog>
  );
}


============================================================
FILE_PATH: src\components\custom\ComponentEditor\ComponentEditor.tsx
============================================================
"use client";
import { ButtonGroup } from "@/components/ui/button-group";
import { Tap } from "./Tap";
import { ScriptEditor } from "./ScriptEditor";
import { useEffect, useRef, useState } from "react";
import { useCodeDefinitions } from "../../../features/editor/hooks/useCodeDefinitions";
import { DynamicComponent } from "@/components/DynamicComponents/DynamicComponent";
import { runScript } from "@/lib/runScript/runScript";
import { useScriptActions } from "@/hooks/useScriptActions";
import { Button } from "@/components/ui/button";
import { Loader2, Save } from "lucide-react";
import { TabContainer } from "./TabContainer";
import { useScriptEditor } from "@/features/editor/hooks/useScriptEditor";

interface ScriptEditorProps {
  initialSql?: string;
  initialScript?: string;
  onChangeJs?: (value: string) => void;
  onChangeSql?: (value: string) => void;
  onSave?: () => void;
  isSaving?: boolean;
}

export const ComponentEditor = ({
  onChangeJs,
  onChangeSql,
  onSave,
  isSaving,
}: ScriptEditorProps) => {
  const {
    jsCode,
    sqlCode,
    logs,
    addExecutionLogs,
    setJsCode,
    setSqlCode,
    clearConsole,
  } = useScriptEditor();

  const [uiState, setUiState] = useState({
    showEditor: true,
    showPreview: true,
  });

  const [liveComponent, setLiveComponent] = useState<any>(null);
  const hasRunInitialScript = useRef(false);
  const [renderKey, setRenderKey] = useState(0);
  const scriptContext = useScriptActions();
  const { definitions } = useCodeDefinitions({ sqlCode });

  const onExecuteScript = async () => {
    try {
      const response = await runScript(jsCode, sqlCode, scriptContext);

      setLiveComponent(response.result);
      /*       const sanitizedResult = sanitizeForRedux(response.result); */
      addExecutionLogs(response.logs);
      setRenderKey((prev) => prev + 1);
    } catch (error: any) {
      setLiveComponent(null);
      addExecutionLogs([{ message: "Error cr√≠tico:", data: error.message }]);
    }
  };

  const handleChangeJs = (v) => {
    onChangeJs?.(v);
    setJsCode(v || "");
  };
  const handleChangeSql = (v) => {
    onChangeSql?.(v);
    setSqlCode(v || "");
  };
  // 3. NUEVO EFFECT: Ejecutar al montar (o cuando llegue el c√≥digo)
  useEffect(() => {
    // Si ya corri√≥ la primera vez, no hacemos nada (evita loop infinito al escribir)
    if (hasRunInitialScript.current) return;

    // "Siempre y cuando la pagina este cargada":
    // Verificamos si hay c√≥digo JS para ejecutar.
    if (jsCode && jsCode.trim() !== "") {
      // eslint-disable-next-line react-hooks/set-state-in-effect
      onExecuteScript();
      hasRunInitialScript.current = true; // Marcamos como ejecutado
    }
  }, [jsCode]);

  const handleOnSave = () => {
    onExecuteScript();
    onSave?.();
  };

  const onTab = (name: string) => {
    if (name == "Script") {
      if (uiState.showEditor && !uiState.showPreview) {
        setUiState({
          ...uiState,
          showEditor: !uiState.showEditor,
          showPreview: true,
        });
        return;
      }
      setUiState({ ...uiState, showEditor: !uiState.showEditor });
      return;
    }
    if (name == "Preview") {
      if (!uiState.showEditor && uiState.showPreview) {
        setUiState({
          ...uiState,
          showPreview: !uiState.showPreview,
          showEditor: true,
        });
        return;
      }
      setUiState({ ...uiState, showPreview: !uiState.showPreview });
      return;
    }
  };

  return (
    <div className="w-full h-full grid grid-rows-[45px_1fr]">
      <div className="w-full h-12 flex gap-3">
        <ButtonGroup>
          <Tap
            name="Script"
            onClick={() => onTab("Script")}
            active={uiState.showEditor}
          />
          <Tap
            name="Preview"
            onClick={() => onTab("Preview")}
            active={uiState.showPreview}
          />
        </ButtonGroup>
        <Button variant="outline" onClick={handleOnSave}>
          {isSaving ? (
            // Spinner
            <Loader2 className="size-5 animate-spin" />
          ) : (
            // Icono Normal
            <Save className="size-5" />
          )}
        </Button>
      </div>
      <div className="w-full h-full flex min-h-0 max-h-[80vh] overflow-hidden gap-4">
        <TabContainer show={uiState.showEditor}>
          <ScriptEditor
            sqlValue={sqlCode}
            onChangeSql={handleChangeSql}
            jsValue={jsCode}
            onChangeJs={handleChangeJs}
            logs={logs}
            onClean={clearConsole}
            onPlay={onExecuteScript}
            onSave={handleOnSave}
            definitions={definitions}
          />
        </TabContainer>
        <TabContainer show={uiState.showPreview}>
          <DynamicComponent
            key={renderKey}
            data={liveComponent}
            context={liveComponent?.context}
          />
        </TabContainer>
      </div>
    </div>
  );
};


============================================================
FILE_PATH: src\components\custom\ComponentEditor\Console.tsx
============================================================
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  Brush,
  ChevronDown,
  ChevronRight,
  Copy,
  Check,
  Search,
  ArrowDownToLine,
  Ban,
} from "lucide-react";
import { useEffect, useRef, useState, useMemo } from "react";
import { cn } from "@/lib/utils"; // Aseg√∫rate de tener esta utilidad de shadcn, si no, usa template strings

// Interfaces
export interface ILog {
  message: string;
  data?: any;
  type?: "info" | "error" | "success" | "warning"; // Nuevo campo opcional
  timestamp?: number;
}

// Sub-componente para visualizar JSON con bot√≥n de copiar
const JsonViewer = ({ data }: { data: any }) => {
  const [copied, setCopied] = useState(false);

  const handleCopy = () => {
    navigator.clipboard.writeText(JSON.stringify(data, null, 2));
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  return (
    <div className="relative group mt-1">
      <div className="absolute right-2 top-2 opacity-0 group-hover:opacity-100 transition-opacity">
        <Button
          variant="ghost"
          size="icon"
          className="h-6 w-6 bg-muted/50 hover:bg-muted"
          onClick={handleCopy}
        >
          {copied ? (
            <Check className="w-3 h-3 text-green-500" />
          ) : (
            <Copy className="w-3 h-3" />
          )}
        </Button>
      </div>
      <pre className="text-[10px] leading-tight text-muted-foreground bg-black/20 p-2 rounded-md overflow-x-auto border border-border/30">
        {JSON.stringify(data, null, 2)}
      </pre>
    </div>
  );
};

// Componente de fila individual memoizado
const LogItem = ({ log }: { log: ILog }) => {
  const [isExpanded, setIsExpanded] = useState(true);

  // Determinar color basado en el mensaje o tipo
  const getLogStyle = () => {
    const msg = log.message.toLowerCase();
    if (log.type === "error" || msg.includes("error") || msg.includes("fail"))
      return "text-red-400 border-l-2 border-red-500 bg-red-500/5";
    if (
      log.type === "success" ||
      msg.includes("success") ||
      msg.includes("done")
    )
      return "text-green-400 border-l-2 border-green-500 bg-green-500/5";
    if (log.type === "warning" || msg.includes("warn"))
      return "text-yellow-400 border-l-2 border-yellow-500 bg-yellow-500/5";
    return "text-blue-300 border-l-2 border-transparent hover:bg-white/5";
  };

  // Normalizar data a array
  const dataItems = useMemo(() => {
    if (!log.data) return [];
    const d = Array.isArray(log.data) ? log.data : [log.data];
    return d.filter(Boolean); // Eliminar nulls/undefined
  }, [log.data]);

  const hasData = dataItems.length > 0;
  const time = log.timestamp
    ? new Date(log.timestamp).toLocaleTimeString()
    : new Date().toLocaleTimeString();

  return (
    <div
      className={cn(
        "py-1 px-2 mb-[1px] text-xs font-mono transition-colors",
        getLogStyle()
      )}
    >
      <div className="flex items-start gap-2">
        <span className="text-gray-600 select-none shrink-0 text-[10px] mt-[2px]">
          {time}
        </span>

        <div className="flex-1 min-w-0">
          <div
            className="flex items-center gap-1 cursor-pointer group"
            onClick={() => hasData && setIsExpanded(!isExpanded)}
          >
            {hasData && (
              <span className="text-muted-foreground">
                {isExpanded ? (
                  <ChevronDown className="w-3 h-3" />
                ) : (
                  <ChevronRight className="w-3 h-3" />
                )}
              </span>
            )}
            <span className="font-semibold break-all">
              {log.message || "Log entry"}
            </span>
          </div>

          {isExpanded && hasData && (
            <div className="pl-4 mt-1 space-y-2">
              {dataItems.map((item, idx) => (
                <JsonViewer key={idx} data={item} />
              ))}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export const Console = ({
  logs = [],
  onClean,
}: {
  logs?: ILog[];
  onClean?: () => void;
}) => {
  const [searchTerm, setSearchTerm] = useState("");
  const [autoScroll, setAutoScroll] = useState(true);
  const endRef = useRef<HTMLDivElement>(null);

  const filteredLogs = useMemo(() => {
    if (!searchTerm) return logs;
    return logs.filter(
      (l) =>
        l.message.toLowerCase().includes(searchTerm.toLowerCase()) ||
        JSON.stringify(l.data).toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [logs, searchTerm]);

  // Auto-scroll effect
  useEffect(() => {
    if (autoScroll && endRef.current) {
      // Un peque√±o timeout ayuda a que el ScrollArea recalcule la altura antes de hacer scroll
      setTimeout(() => {
        endRef.current?.scrollIntoView({ behavior: "smooth", block: "end" });
      }, 100);
    }
  }, [logs, autoScroll, filteredLogs.length]);

  return (
    <div className="h-full min-h-0 flex flex-col  bg-[#0c0c0c] border-t border-border overflow-hidden rounded-b-lg">
      {/* Toolbar */}
      <div className="flex justify-between items-center px-2 py-1.5 bg-muted/40 border-b border-border gap-2">
        <div className="flex items-center gap-2 flex-1 max-w-sm">
          <div className="relative w-full">
            <Search className="absolute left-2 top-1/2 -translate-y-1/2 w-3 h-3 text-muted-foreground" />
            <Input
              className="h-7 text-xs pl-7 bg-black/20 border-border/50 focus-visible:ring-1 focus-visible:ring-offset-0"
              placeholder="Filter logs..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
            />
          </div>
        </div>

        <div className="flex items-center gap-1">
          <Button
            variant={autoScroll ? "default" : "ghost"}
            size="icon"
            className={cn(
              "h-6 w-6",
              autoScroll && "bg-blue-600 hover:bg-blue-700"
            )}
            onClick={() => setAutoScroll(!autoScroll)}
            title="Toggle Auto-scroll"
          >
            <ArrowDownToLine className="w-3 h-3" />
          </Button>
          <Button
            variant="ghost"
            size="icon"
            className="h-6 w-6 hover:bg-red-900/20 hover:text-red-400"
            onClick={onClean}
            title="Clear Console"
          >
            <Ban className="w-3 h-3" />
          </Button>
        </div>
      </div>

      {/* 2. Reemplazamos el div con overflow nativo por ScrollArea */}
      <ScrollArea className="flex-1 bg-black/10 max-h-[94%]">
        <div className="p-2 flex flex-col min-h-full">
          {filteredLogs.length === 0 ? (
            <div className="flex-1 flex flex-col items-center justify-center text-muted-foreground/40 italic text-xs gap-2 py-10">
              <span>Waiting for output...</span>
            </div>
          ) : (
            <div className="flex flex-col">
              {filteredLogs.map((log, index) => (
                <LogItem key={index} log={log} />
              ))}
              <div ref={endRef} className="h-px w-full" />
            </div>
          )}
        </div>
      </ScrollArea>
    </div>
  );
};


============================================================
FILE_PATH: src\components\custom\ComponentEditor\ScriptEditor.tsx
============================================================
import { Button } from "@/components/ui/button";
import { ButtonGroup } from "@/components/ui/button-group";
import { Editor, OnMount } from "@monaco-editor/react";
import { Console, ILog } from "./Console";
import { useEffect, useState } from "react";
import { Play } from "lucide-react";
import {
  useMonacoTypings,
  TypeDefinition,
} from "@/features/editor/hooks/useMonacoTypings";

export interface CustomEditorProps {
  onPlay?: () => void;
  logs?: ILog[];
  onClean?: () => void;
  onlyJs?: boolean;
  onMount?: OnMount;
  jsValue?: string;
  onChangeJs?: (value?: string) => void;
  sqlValue?: string;
  onChangeSql?: (value?: string) => void;
  disableConsole?: boolean;
  onSave?: () => void;
  globalDefinitions?: string;
  alwaysOpenConsole?: boolean;
  definitions?: TypeDefinition[];
}

export const ScriptEditor = ({
  onPlay,
  logs,
  onClean,
  onlyJs,
  disableConsole,
  jsValue,
  onChangeJs,
  onChangeSql,
  sqlValue,
  onSave,
  alwaysOpenConsole,
  definitions = [],
}: CustomEditorProps) => {
  const { handleEditorDidMount } = useMonacoTypings({
    definitions: definitions,
  });

  const [isJs, setIsJs] = useState(true);
  const [openConsole, setOpenConsole] = useState(false);

  const onTab = (name: string) => {
    if (name == "js") setIsJs(true);
    else setIsJs(false);
  };

  const onToggleConsole = () => {
    setOpenConsole(!openConsole);
  };

  const editorOptions = {
    minimap: { enabled: false },
    fontSize: 15,
    padding: { top: 10 },
    automaticLayout: true,
    scrollBeyondLastLine: false,
  };

  const handleOnPlay = () => {
    onPlay?.();
  };

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Verifica si se presiona Ctrl (Win/Linux) o Meta (Mac) junto con la tecla 's'
      if ((e.ctrlKey || e.metaKey) && (e.key === "s" || e.key === "S")) {
        e.preventDefault(); // üõë Importante: Bloquea el "Guardar p√°gina" del navegador

        if (onSave) {
          onSave();
        }
      }
    };

    // Agregamos el listener a la ventana global
    window.addEventListener("keydown", handleKeyDown);

    // Limpiamos el listener cuando el componente se desmonta
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, [onSave]); // Se vuelve a crear si la funci√≥n onSave cambia
  const showHeader = !(onlyJs && disableConsole);
  return (
    // CAMBIO 1: Usamos flex flex-col en lugar de grid. h-full es cr√≠tico.
    <div className="flex flex-col h-full w-full rounded-lg overflow-hidden bg-background">
      {/* Header: Usamos flex-none para que no se encoja ni crezca */}
      {showHeader && (
        <div className="flex-none h-[45px] w-full bg-accent flex gap-3 items-center px-3 border-b border-border">
          {!onlyJs && (
            <ButtonGroup>
              <Button
                className="h-8 transition-none duration-0"
                variant={isJs ? "default" : "outline"}
                onClick={() => onTab("js")}
              >
                JS
              </Button>
              <Button
                className="h-8 transition-none duration-0"
                variant={!isJs ? "default" : "outline"}
                onClick={() => onTab("sql")}
              >
                SQL
              </Button>
            </ButtonGroup>
          )}

          {!disableConsole && (
            <>
              {!alwaysOpenConsole && (
                <Button
                  className="h-8 transition-none duration-0"
                  variant={openConsole ? "default" : "outline"}
                  onClick={onToggleConsole}
                >
                  Console
                </Button>
              )}

              <Button
                className="h-8 transition-none duration-0"
                variant="outline"
                onClick={handleOnPlay}
              >
                <Play />
              </Button>
            </>
          )}
        </div>
      )}

      {/* CAMBIO 2: √Årea de contenido
          flex-1: Toma todo el espacio restante.
          min-h-0: CRUCIAL. Permite que flexbox reduzca el tama√±o del hijo si el contenido interno (ScrollArea) es muy grande.
          overflow-hidden: Asegura que nada se salga visualmente.
      */}
      <div className="flex-1 min-h-0 flex w-full overflow-hidden">
        {(!openConsole || alwaysOpenConsole) && (
          <div className="flex-1 min-w-0 h-full relative">
            {isJs || onlyJs ? (
              <Editor
                key={"js"}
                theme="vs-dark"
                onMount={handleEditorDidMount}
                value={jsValue}
                onChange={onChangeJs}
                language="javascript"
                options={editorOptions}
                className="absolute inset-0" // Forzamos al editor a llenar su contenedor
              />
            ) : (
              <Editor
                key={"sql"}
                theme="vs-dark"
                language="sql"
                value={sqlValue}
                onChange={onChangeSql}
                options={editorOptions}
                className="absolute inset-0"
              />
            )}
          </div>
        )}

        {(openConsole || alwaysOpenConsole) && (
          <div className="flex-1 min-w-0 h-full border-l border-border relative">
            {/* El Console ahora vivir√° dentro de este contenedor flex estrictamente */}
            <div className="absolute inset-0">
              <Console logs={logs} onClean={onClean} />
            </div>
          </div>
        )}
      </div>
    </div>
  );
};


============================================================
FILE_PATH: src\components\custom\ComponentEditor\TabContainer.tsx
============================================================
import { ReactNode } from "react";

export const TabContainer = ({
  show,
  children,
}: {
  show?: boolean;
  children?: ReactNode;
}) => {
  // Si no se debe mostrar, no renderizamos nada (m√°s limpio que el Fragment)
  if (!show) return null;

  return (
    <div className="flex-1 h-full min-w-0 rounded-lg overflow-hidden border border-border bg-background relative transition-all">
      {children}
    </div>
  );
};


============================================================
FILE_PATH: src\components\custom\ComponentEditor\Tap.tsx
============================================================
import { Button } from "@/components/ui/button";

export const Tap = ({
  onClick,
  name,
  active,
}: {
  onClick?: (name: string) => void;
  name: string;
  active?: boolean;
}) => {
  const onClickTab = () => {
    onClick?.(name);
  };
  return (
    <Button
      variant={active ? "default" : "outline"}
      onClick={onClickTab}
      className="uppercase min-w-20 transition-none duration-0"
    >
      {name}
    </Button>
  );
};


============================================================
FILE_PATH: src\components\custom\Modals\ConfigConnectionModal.tsx
============================================================
import { ScriptEditor } from "@/components/custom/ComponentEditor/ScriptEditor";
import { useCodeDefinitions } from "@/features/editor/hooks/useCodeDefinitions";
import { Modal, ModalProps } from "@/components/custom/Modal";
/* import { useDashboardStore } from "@/features/dashboard/hooks/useDashboards"; */
import { useScriptEditor } from "@/features/editor/hooks/useScriptEditor";

import { runScript } from "@/lib/runScript/runScript";
import { useEffect } from "react";
import { useModals } from "@/providers/ModalProvider";
import { useScriptConnectionActions } from "@/hooks/useScriptConnectionActions";
import { useDashboardStore } from "@/features/dashboard/store/useDashboardStore";

type ConfigConnectionModalProps = ModalProps & {};
export const ConfigConnectionModal = (props: ConfigConnectionModalProps) => {
  const { jsCode, setJsCode, clearConsole, logs } = useScriptEditor();

  const { setConfigScript, getConfigScript } = useDashboardStore();

  const scriptContext = useScriptConnectionActions();
  const { definitions } = useCodeDefinitions({ contextType: "DBConfig" });
  const { isModalOpen } = useModals();
  const isOpen = isModalOpen(props.id);

  const onConnect = async () => {
    if (!jsCode) return;

    await runScript(jsCode, "", scriptContext);
    setConfigScript(jsCode);
  };

  const handleChangeJs = (v) => {
    setJsCode(v || "");
  };

  const onClean = () => {
    clearConsole();
  };

  useEffect(() => {
    if (isOpen) {
      setJsCode(getConfigScript());
    } else {
      onClean();
    }
  }, [isOpen]);

  return (
    <Modal
      {...props}
      className="min-w-[80vw] min-h-[70vh] grid grid-rows-[10px_auto_1fr]"
      disableEscape
      disableOutside
    >
      <div className="w-full h-full grid grid-rows-[1fr] gap-2">
        <ScriptEditor
          onChangeJs={handleChangeJs}
          jsValue={jsCode ?? ""}
          onSave={onConnect}
          definitions={definitions}
          onPlay={onConnect}
          logs={logs}
          onlyJs
          alwaysOpenConsole
          onClean={onClean}
        />
      </div>
    </Modal>
  );
};


============================================================
FILE_PATH: src\components\custom\Modals\ConfirmModal.tsx
============================================================
import { useModals } from "@/providers/ModalProvider";
import { Modal, ModalProps } from "../Modal";
import { Button } from "@/components/ui/button";

type ConfirmModalProps = ModalProps & {
  onConfirm?: () => void;
  onCancel?: () => void;
  confirmName?: string;
};

export const ConfirmModal = (props: ConfirmModalProps) => {
  const { closeModal } = useModals();
  const onCancel = () => {
    closeModal(props.id);
    props.onCancel?.();
  };
  const onConfirm = () => {
    closeModal(props.id);
    props.onConfirm?.();
  };

  return (
    <Modal {...props} className={"w-80 " + props.className}>
      <div className="w-full  flex gap-10 justify-center">
        <Button variant="outline" onClick={onCancel}>
          Cancelar
        </Button>
        <Button variant="default" onClick={onConfirm}>
          {props.confirmName ?? "Confirmar"}
        </Button>
      </div>
    </Modal>
  );
};


============================================================
FILE_PATH: src\components\custom\Modals\CreateComponentModal.tsx
============================================================
import { ComponentEditor } from "@/components/custom/ComponentEditor/ComponentEditor";
import { Modal, ModalProps } from "@/components/custom/Modal";
import { useScriptEditor } from "@/features/editor/hooks/useScriptEditor";

type CreateComponentModalProps = Omit<ModalProps, "title"> & {
  isSaving?: boolean;
  onSave?: () => void;
};

export const ComponentEditorModal = (props: CreateComponentModalProps) => {
  /*   const { isSaving, savePage } = usePageEditor(); */
  const { clearConsole } = useScriptEditor();

  /*   const onSave = () => {
    savePage(jsCode, sqlCode);
  };
 */
  const onClose = () => {
    props.onClose?.();

    clearConsole();
  };

  return (
    <Modal
      {...props}
      onClose={onClose}
      disableEscape
      disableOutside
      title="Create Component"
      className="min-w-[95%] min-h-[95%] max-h-[85%] grid grid-rows-[35px_1fr] gap-0"
    >
      <ComponentEditor
        /*         initialSql={sqlCode}
        initialScript={jsCode} */
        /*         onChangeJs={setJsTemp} // Asumiendo que ComponentEditor usa onChangeJs
        onChangeSql={setSqlTemp} // Asumiendo que ComponentEditor usa onChangeSql */
        onSave={props.onSave}
        isSaving={props.isSaving}
      />
    </Modal>
  );
};


============================================================
FILE_PATH: src\components\custom\Modals\FormModal.tsx
============================================================
import { useModals } from "@/providers/ModalProvider";
import { DynamicForm, DynamicFormProps } from "../DynamicForm";
import { Modal, ModalProps } from "../Modal";

type FormModalProps = ModalProps &
  Omit<DynamicFormProps, "className"> & { classNameForm?: string };

export const FormModal = (props: FormModalProps) => {
  const { closeModal } = useModals();
  const handleSummit = (data, error) => {
    props.onSubmit?.(data, error);
    closeModal(props.id);
  };
  return (
    <Modal {...props}>
      <DynamicForm
        {...props}
        onSubmit={handleSummit}
        className={props.classNameForm}
      />
    </Modal>
  );
};


============================================================
FILE_PATH: src\components\custom\Modals\LoadingModal.tsx
============================================================
"use client";
import { Modal, ModalProps } from "@/components/custom/Modal";
import { Loader2 } from "lucide-react";
import { cn } from "@/lib/utils";
import { useModals } from "@/providers/ModalProvider";

// Definimos la estructura de datos que este modal espera recibir
interface LoadingModalData {
  message?: string;
  subMessage?: string;
}

// Ya no recibe message/subMessage por props, sino por el Contexto
type LoadingModalProps = ModalProps & {
  // Puedes mantener className o id aqu√≠ si los necesitas
};

export const LoadingModal = ({ className, ...props }: LoadingModalProps) => {
  const { getModalData } = useModals();

  // Recuperamos la data espec√≠fica para este ID de modal
  // Si no hay data, usamos un objeto vac√≠o por defecto
  const data = getModalData<LoadingModalData>(props.id) || {};

  // Valores por defecto si no se manda nada en la data
  const message = data.message || "Cargando...";
  const subMessage = data.subMessage;

  return (
    <Modal
      {...props}
      disableEscape
      disableOutside
      className={cn(
        "min-w-[300px] w-auto h-auto p-8 flex flex-col items-center justify-center outline-none",
        className
      )}
    >
      <div className="flex flex-col items-center justify-center space-y-4">
        {/* Spinner */}
        <div className="relative flex h-12 w-12 items-center justify-center rounded-full bg-primary/10">
          <Loader2 className="h-7 w-7 animate-spin text-primary" />
        </div>

        {/* Textos Din√°micos desde el Provider */}
        <div className="text-center space-y-1">
          <h3 className="text-lg font-semibold text-foreground">{message}</h3>
          {subMessage && (
            <p className="text-sm text-muted-foreground animate-pulse">
              {subMessage}
            </p>
          )}
        </div>
      </div>
    </Modal>
  );
};


============================================================
FILE_PATH: src\components\DynamicComponents\DynamicComponent.tsx
============================================================
/* eslint-disable react-hooks/immutability */
import { Component, Context } from "@/lib/ComponentBuilders/Component";
import { COMPONENTS } from "./Components";
import { ReactNode, memo, useId } from "react";
import { v4 as uuid } from "uuid";

// OPTIMIZACI√ìN: Memoizar el componente recursivo
export const DynamicComponent = memo(
  ({ data, context }: { data?: Component; context?: Context }) => {
    // 1. Hook incondicional al inicio
    if (!data) return null;

    const TargetComponent = COMPONENTS[data.type] as
      | (({}: any) => ReactNode)
      | undefined;

    if (!TargetComponent) return null;

    // 2. Inicializamos el ID del componente ACTUAL si no existe
    // eslint-disable-next-line react-hooks/immutability
    if (!data.id) {
      // eslint-disable-next-line react-hooks/immutability
      data.id = uuid();
    }

    if (data.config) {
      if (typeof data.config.style == "string") {
        data.config.style = undefined;
      }
    }

    return (
      <TargetComponent {...data} context={context}>
        {data.subComponents &&
          (Array.isArray(data.subComponents) ? (
            data.subComponents.map((item, index) => {
              // 3. Inicializamos el ID del SUB-COMPONENTE si no existe
              // Usamos el ID del padre + el √≠ndice para garantizar unicidad sin romper reglas de hooks
              if (!item.id) {
                // eslint-disable-next-line react-hooks/immutability
                item.id = uuid();
              }

              return (
                <DynamicComponent
                  data={item}
                  // Ahora item.id siempre existe, as√≠ que la key es segura
                  key={item.id}
                  context={context}
                />
              );
            })
          ) : (
            // Caso de un solo subComponente (no array)
            <DynamicComponent data={data.subComponents} context={context} />
          ))}
      </TargetComponent>
    );
  }
);

DynamicComponent.displayName = "DynamicComponent";


============================================================
FILE_PATH: src\components\DynamicComponents\useComponentRegistration.ts
============================================================
/* eslint-disable react-hooks/immutability */
import { Context } from "@/lib/ComponentBuilders/Component";
import { useEffect, useLayoutEffect } from "react";

export const useComponentRegistration = <TMethods extends Record<string, any>>(
  context: Context | undefined,
  group: string,
  id: string,
  methods: TMethods
) => {
  useLayoutEffect(() => {
    if (!context || !id) return;

    // 1. Asegurar estructura (Defensive Programming)
    // Usamos 'any' para permitir acceso din√°mico a claves como 'btn', 'input', etc.
    const compRegistry = context.comp as any;

    if (!compRegistry) {
      context.comp = {} as any;
    }

    if (!context.comp[group as keyof typeof context.comp]) {
      (context.comp as any)[group] = {};
    }

    // 2. Registrar los m√©todos
    // Al asignar methods directamente, mantenemos la referencia actualizada.
    (context.comp as any)[group][id] = methods;

    // 3. Cleanup: Eliminar del contexto al desmontar
    return () => {
      const currentGroup = (context.comp as any)[group];
      if (currentGroup && currentGroup[id]) {
        delete currentGroup[id];
      }
    };
  }, [context, group, id, methods]);
};


============================================================
FILE_PATH: src\components\DynamicComponents\useDynamicValue.ts
============================================================
import { useScriptError } from "@/hooks/useScriptError";
import {
  Context,
  DynamicFunction,
  DynamicValue,
  IComponentData,
} from "@/lib/ComponentBuilders/Component";
import { useEffect, useRef, useState, useCallback } from "react";

// Cache Global (WeakMap)
const globalDataCache = new WeakMap<object, any>();

function isComponentDataWrapper<T>(
  value: any
): value is { data: T; keepData: boolean } {
  return (
    value !== null &&
    typeof value === "object" &&
    "data" in value &&
    "keepData" in value
  );
}

export const useDynamicValue = <T>(
  context: Context,
  _value: IComponentData<DynamicValue<T>> | undefined,
  defaultValue: T
) => {
  const execute = useScriptError();

  // Funci√≥n interna para leer cach√© inicial s√≠ncronamente
  const getInitialValue = (): T => {
    if (
      _value &&
      isComponentDataWrapper(_value) &&
      _value.keepData &&
      globalDataCache.has(_value)
    ) {
      return globalDataCache.get(_value) as T;
    }
    return defaultValue;
  };

  const [value, setStateValue] = useState<T>(getInitialValue);
  const valueRef = useRef<T>(getInitialValue());
  const hasExecuted = useRef(false);

  // --- NUEVO: Control de Recarga ---
  const [reloadVersion, setReloadVersion] = useState(0); // Disparador del Effect
  const ignoreCacheOnce = useRef(false); // Flag para saltar cach√©

  const setValue = (newValue: T) => {
    if (valueRef.current === newValue) return;
    valueRef.current = newValue;
    setStateValue(newValue);
  };

  // Esta es la funci√≥n que devolveremos al componente
  const reload = useCallback(() => {
    ignoreCacheOnce.current = true; // 1. Orden: Ignorar cach√© en la pr√≥xima vuelta
    hasExecuted.current = false; // 2. Orden: Permitir ejecuci√≥n local
    setReloadVersion((v) => v + 1); // 3. Disparar: Ejecutar Effect
  }, []);

  useEffect(() => {
    let isMounted = true;

    const resolveValue = async () => {
      if (_value === undefined || _value === null) return;

      let source: DynamicValue<T>;
      let shouldKeepData = false;
      let cacheKey: object | null = null;

      if (isComponentDataWrapper<DynamicValue<T>>(_value)) {
        source = _value.data;
        shouldKeepData = _value.keepData;
        cacheKey = _value;
      } else {
        source = _value as DynamicValue<T>;
      }

      // --- L√ìGICA DE CACH√â ACTUALIZADA ---

      // A. Si ya se ejecut√≥ en este montaje Y NO se pidi√≥ recargar, salir.
      if (shouldKeepData && hasExecuted.current && !ignoreCacheOnce.current) {
        return;
      }

      // B. Revisar cach√© global (SOLO SI ignoreCacheOnce ES FALSO)
      if (
        shouldKeepData &&
        cacheKey &&
        globalDataCache.has(cacheKey) &&
        !ignoreCacheOnce.current // <--- Aqu√≠ est√° la clave
      ) {
        const cachedVal = globalDataCache.get(cacheKey);
        setValue(cachedVal);
        hasExecuted.current = true;
        return;
      }

      // 3. Ejecuci√≥n Real (Fetching)
      if (typeof source === "function") {
        try {
          const func = source as DynamicFunction<T>;
          const result = await execute<T>(func, context);

          if (isMounted && result !== undefined) {
            setValue(result);
            hasExecuted.current = true;

            // Guardar en cach√© global
            if (shouldKeepData && cacheKey) {
              globalDataCache.set(cacheKey, result);
            }
          }
        } catch (error) {
          console.error("Error resolving dynamic value:", error);
        }
      } else {
        // Valor est√°tico
        if (isMounted) {
          setValue(source as T);
          hasExecuted.current = true;
        }
      }

      // Limpiamos el flag de forzar recarga despu√©s de intentar resolver
      if (ignoreCacheOnce.current) {
        ignoreCacheOnce.current = false;
      }
    };

    resolveValue();

    return () => {
      isMounted = false;
    };
    // Agregamos reloadVersion a las dependencias para que el effect corra al cambiarlo
  }, [_value, context, reloadVersion]);

  // Retornamos 4 valores: ref, setter manual, valor estado, y funci√≥n reload
  return [valueRef, setValue, value, reload] as const;
};


============================================================
FILE_PATH: src\components\DynamicComponents\Components\Button.tsx
============================================================
/* eslint-disable react-hooks/immutability */
import { Button } from "@/components/ui/button";
import { useDynamicValue } from "@/components/DynamicComponents/useDynamicValue";
import { Component, Context } from "@/lib/ComponentBuilders/Component";
import { useMemo } from "react";
import { useComponentRegistration } from "../useComponentRegistration";
import { useScriptError } from "@/hooks/useScriptError";
import { DynamicIcon } from "@/components/custom/DynamicIcon";

export const DynamicButton = ({
  config,
  events,
  context,
  id,
  data,
}: Component & { context: Context }) => {
  const [labelRef, setLabel, label] = useDynamicValue(context, data.label, "");
  const execute = useScriptError();

  const handleOnClick = (e: any) => {
    execute(events.onClick, e, context);
  };

  const exposedMethods = useMemo(
    () => ({
      setLabel: (value: string) => setLabel(value),
      getLabel: () => labelRef.current,
    }),
    [setLabel, labelRef]
  ); // Dependencias estables

  // 2. Usamos el Hook para registrar en context.comp.btn[id]
  useComponentRegistration(context, "btn", id, exposedMethods);
  console.log(config.icon);
  return (
    <Button {...config} onClick={handleOnClick}>
      {config.icon && <DynamicIcon name={config.icon} />}
      {label}
    </Button>
  );
};


============================================================
FILE_PATH: src\components\DynamicComponents\Components\ConfirmModal.tsx
============================================================
import { ConfirmModal } from "@/components/custom/Modals/ConfirmModal";
import { useScriptError } from "@/hooks/useScriptError";
import { Component, Context } from "@/lib/ComponentBuilders/Component";

export const DynamicConfirmModal = ({
  config,
  events,
  id,
  context,
}: Component & { context: Context }) => {
  const execute = useScriptError();
  const handleOnConfirm = () => {
    execute(events.onConfirm, undefined, context);
  };

  const handleOnCancel = () => {
    execute(events.onCancel, undefined, context);
  };

  return (
    <ConfirmModal
      {...config}
      title={config?.title ?? ""}
      id={id}
      onConfirm={handleOnConfirm}
      onCancel={handleOnCancel}
    />
  );
};


============================================================
FILE_PATH: src\components\DynamicComponents\Components\Form.tsx
============================================================
import {
  Component,
  Context,
  DynamicValue,
  IComponentData,
} from "@/lib/ComponentBuilders/Component";
import { useScriptError } from "@/hooks/useScriptError";
import { useDynamicValue } from "../useDynamicValue";
import { useCallback, useEffect } from "react";
import { DynamicForm as Form } from "@/components/custom/DynamicForm";

type DynamicFormProps = Component & {
  context: Context;
  data: {
    schema?: any;
    fields?: any[];
    defaultValues: IComponentData<DynamicValue<any>>;
  };
  config: {
    className?: string;
    classNameForm?: string;
    title?: string;
    description?: string;
    confirmName?: string;
    cancelName?: string;
  };
};

export const DynamicForm = ({
  config,
  events,
  context,
  data,
}: DynamicFormProps) => {
  const execute = useScriptError();
  const [_, __, defaultValues, reload] = useDynamicValue(
    context,
    data.defaultValues,
    {}
  );

  const handleOnSubmit = (formData: any) => {
    execute(events.onSubmit, formData, context);
  };

  return (
    <Form
      {...config} // Pasa title, description, classNames
      schema={data.schema}
      fields={data.fields}
      defaultValues={defaultValues}
      onSubmit={handleOnSubmit}
    />
  );
};


============================================================
FILE_PATH: src\components\DynamicComponents\Components\FormModal.tsx
============================================================
import {
  Component,
  Context,
  DynamicValue,
  IComponentData,
} from "@/lib/ComponentBuilders/Component";
import { FormModal } from "@/components/custom/Modals/FormModal";
import { useScriptError } from "@/hooks/useScriptError";
import { useDynamicValue } from "../useDynamicValue";
import { useCallback, useEffect } from "react";
import { useModals } from "@/providers/ModalProvider";

type DynamicFormModalProps = Component & {
  context: Context;
  data: {
    schema?: any;
    fields?: any[];
    defaultValues: IComponentData<DynamicValue<any>>;
  };
  config: {
    className?: string;
    classNameForm?: string;
    title?: string;
    description?: string;
    confirmName?: string;
    cancelName?: string;
  };
};

export const DynamicFormModal = ({
  config,
  events,
  context,
  id,
  data,
}: DynamicFormModalProps) => {
  const execute = useScriptError();
  const [_, __, defaultValues, reload] = useDynamicValue(
    context,
    data.defaultValues,
    {}
  );

  const { isModalOpen } = useModals();

  const handleOnSubmit = (formData: any) => {
    execute(events.onSubmit, formData, context);
  };

  const isOpen = isModalOpen(id);
  useEffect(() => {
    if (isOpen) {
      reload();
    }
  }, [isOpen, reload]);

  return (
    <FormModal
      id={id}
      {...config} // Pasa title, description, classNames
      schema={data.schema}
      fields={data.fields}
      defaultValues={defaultValues}
      onSubmit={handleOnSubmit}
    />
  );
};


============================================================
FILE_PATH: src\components\DynamicComponents\Components\Fragment.tsx
============================================================
import { Component, Context } from "@/lib/ComponentBuilders/Component";
import { DynamicComponent } from "../DynamicComponent"; // Aseg√∫rate de que la ruta sea correcta
import { useMemo } from "react";

// El Fragment no suele tener config visual compleja ni data,
// su principal funci√≥n es renderizar 'subComponents'.
type FragmentProps = Component & {
  context: Context;
};

export const DynamicFragment = ({ context, subComponents }: FragmentProps) => {
  // Normalizamos para asegurar que siempre sea un array
  const childrenToRender = useMemo(() => {
    if (!subComponents) return [];
    return Array.isArray(subComponents) ? subComponents : [subComponents];
  }, [subComponents]);

  // Si no hay hijos, no renderizamos nada
  if (childrenToRender.length === 0) return null;

  return (
    <>
      {childrenToRender.map((childComponent) => (
        <DynamicComponent
          key={childComponent.id}
          data={childComponent}
          context={context}
        />
      ))}
    </>
  );
};


============================================================
FILE_PATH: src\components\DynamicComponents\Components\Gallery.tsx
============================================================
/* eslint-disable react-hooks/immutability */
import { Component, Context } from "@/lib/ComponentBuilders/Component";
import { useDynamicValue } from "@/components/DynamicComponents/useDynamicValue";
import { useCallback, useMemo, useState } from "react";
import { useComponentRegistration } from "../useComponentRegistration";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button"; // Nuevo
import { Card } from "@/components/ui/card";
import { ScrollArea } from "@/components/ui/scroll-area";
import { useScriptError } from "@/hooks/useScriptError";
import { v4 as uuid } from "uuid";

// Iconos disponibles
import {
  Search,
  Trash,
  Edit,
  Copy,
  Eye,
  Plus,
  MoreHorizontal,
  Settings,
} from "lucide-react";

import {
  ContextMenu,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuTrigger,
  ContextMenuSeparator,
} from "@/components/ui/context-menu";

// Mapeo de iconos por nombre (string)
const ICON_MAP: Record<string, any> = {
  Trash,
  Edit,
  Copy,
  Eye,
  Plus,
  Settings,
  More: MoreHorizontal,
};

type GalleryProps = Component & {
  context: Context;
  data: {
    items: any;
  };
  config: {
    className?: string;
    searchable?: boolean;
    cardSize?: string;
    height?: string;
    style?: {
      gallery?: Record<string, any>;
      title?: Record<string, any>;
      description?: Record<string, any>;
      img?: Record<string, any>;
      card?: Record<string, any>;
    };
    // Configuraciones nuevas
    addButton?: {
      label: string;
      icon?: string;
      variant?: "outline" | "default";
    };
    contextMenu?: Array<{
      label: string;
      icon?: string;
      variant?: "default" | "destructive";
      separator?: boolean;
    }>;
  };
};

export const DynamicGallery = ({
  config,
  events,
  context,
  id,
  data,
}: GalleryProps) => {
  const [itemsRef, setItems, items, reloadItems] = useDynamicValue(
    context,
    data.items,
    []
  );
  const [searchTerm, setSearchTerm] = useState("");
  const execute = useScriptError();

  const handleCardClick = (item: any) => {
    if (events.onCardClick) {
      execute(events.onCardClick, item, context);
    }
  };

  // Ejecuta la acci√≥n del bot√≥n "Agregar"
  const handleAddClick = useCallback(() => {
    if (events.onAddClick) {
      execute(events.onAddClick, null, context);
    }
  }, [execute, context, events.onAddClick]);

  // Ejecuta una acci√≥n espec√≠fica del men√∫ contextual por √≠ndice
  const handleContextAction = useCallback(
    (index: number, item: any) => {
      const eventName = `onContextAction_${index}`;
      if (events[eventName]) {
        execute(events[eventName], item, context);
      }
    },
    [context, events, execute]
  );

  const filteredItems = useMemo(() => {
    if (!Array.isArray(items)) return [];
    if (!searchTerm)
      return items
        .filter(Boolean)
        .map((item) => ({ ...item, id: item.id ?? uuid() }));
    return items
      .filter((item) =>
        item.title.toLowerCase().includes(searchTerm.toLowerCase())
      )
      .filter(Boolean)
      .map((item) => ({ ...item, id: item.id ?? uuid() }));
  }, [items, searchTerm]);

  const exposedMethods = useMemo(
    () => ({
      setItems: (newItems: any[]) => setItems(newItems),
      getItems: () => itemsRef.current,
      reload: () => reloadItems(),
    }),
    [setItems, itemsRef, reloadItems]
  );

  useComponentRegistration(context, "gallery", id, exposedMethods);

  const sizeClass = config.cardSize || "w-[20rem] h-[11rem]";
  const containerHeight = config.height || "h-full";

  return (
    <div
      className={`flex flex-col gap-6 min-h-0 overflow-hidden ${containerHeight} ${
        config.className || ""
      }`}
      style={
        typeof config.style?.gallery == "object"
          ? config.style.gallery
          : undefined
      }
    >
      {/* --- HEADER: Buscador + Bot√≥n Agregar --- */}
      {(config.searchable !== false || config.addButton) && (
        <div className="flex-none flex justify-center items-center gap-2 w-full px-5 pt-6">
          {/* Barra de b√∫squeda */}
          {config.searchable !== false && (
            <div className="relative w-full max-w-125">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
              <Input
                placeholder="Buscar..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="pl-9 bg-background/50 border-muted-foreground/20 focus:border-primary transition-colors"
              />
            </div>
          )}

          {/* Bot√≥n de Agregar (Configurable) */}
          {config.addButton && (
            <Button
              onClick={handleAddClick}
              className="gap-2 shrink-0"
              variant={config.addButton.variant}
            >
              {config.addButton.icon &&
                ICON_MAP[config.addButton.icon] &&
                (() => {
                  const Icon = ICON_MAP[config.addButton.icon];
                  return <Icon className="h-4 w-4" />;
                })()}
              {!config.addButton.icon && <Plus className="h-4 w-4" />}
              <span className="hidden sm:inline">{config.addButton.label}</span>
            </Button>
          )}
        </div>
      )}

      {/* --- ScrollArea --- */}
      <ScrollArea className="flex-1 h-full w-full rounded-md border border-border/40 bg-background/50">
        <div className="p-6 mb-25">
          <div className="flex flex-wrap gap-5 content-start justify-center sm:justify-start">
            {filteredItems.map((item) => (
              <ContextMenu key={item.id}>
                <ContextMenuTrigger asChild>
                  <Card
                    className={`
                      group relative flex flex-row items-center justify-center overflow-hidden px-3
                      border border-border/50 bg-card 
                      hover:shadow-xl hover:border-primary/20 
                      transition-all duration-300 ease-in-out cursor-pointer
                      flex-none shrink-0 
                      ${sizeClass}
                    `}
                    style={
                      typeof config.style?.card == "object"
                        ? config.style.card
                        : undefined
                    }
                    onClick={() => handleCardClick(item)}
                  >
                    {/* ... (Contenido de la card igual que antes) ... */}
                    <div className="relative overflow-hidden bg-muted flex place-content-center shrink-0 rounded-md">
                      {item.imageUrl && (
                        <img
                          src={item.imageUrl}
                          alt={item.title}
                          style={
                            typeof item.style?.img == "object"
                              ? item.style.img
                              : undefined
                          }
                          className="size-[8rem] object-cover transition-transform duration-500 group-hover:scale-110 rounded-md"
                        />
                      )}
                    </div>
                    <div className="p-4 flex flex-col justify-center bg-card z-10 flex-1 min-w-0">
                      <h3
                        className="font-semibold text-base leading-tight truncate text-foreground group-hover:text-primary transition-colors"
                        title={item.title}
                        style={
                          typeof config.style?.title == "object"
                            ? config.style.title
                            : undefined
                        }
                      >
                        {item.title}
                      </h3>
                      {item.description && (
                        <p
                          style={
                            typeof config.style?.description == "object"
                              ? config.style.description
                              : undefined
                          }
                          className="text-sm text-muted-foreground mt-1 line-clamp-3 leading-snug break-words"
                        >
                          {item.description}
                        </p>
                      )}
                    </div>
                  </Card>
                </ContextMenuTrigger>

                {/* MEN√ö CONTEXTUAL DIN√ÅMICO */}
                {config.contextMenu && config.contextMenu.length > 0 && (
                  <ContextMenuContent className="w-48">
                    {config.contextMenu.map((menuItem, index) => {
                      if (menuItem.separator) {
                        return <ContextMenuSeparator key={index} />;
                      }

                      const IconComp = menuItem.icon
                        ? ICON_MAP[menuItem.icon]
                        : null;
                      const isDestructive = menuItem.variant === "destructive";

                      return (
                        <ContextMenuItem
                          key={index}
                          className={`cursor-pointer ${
                            isDestructive
                              ? "text-red-600 focus:text-red-600 focus:bg-red-100/10"
                              : ""
                          }`}
                          onClick={(e) => {
                            e.stopPropagation();
                            handleContextAction(index, item);
                          }}
                        >
                          {IconComp && <IconComp className="mr-2 h-4 w-4" />}
                          <span>{menuItem.label}</span>
                        </ContextMenuItem>
                      );
                    })}
                  </ContextMenuContent>
                )}
              </ContextMenu>
            ))}

            {/* Empty State */}
            {filteredItems.length === 0 && (
              <div className="w-full flex flex-col items-center justify-center py-12 text-muted-foreground border-2 border-dashed rounded-lg">
                <Search className="h-8 w-8 mb-2 opacity-50" />
                <p>No se encontraron resultados.</p>
              </div>
            )}
          </div>
        </div>
      </ScrollArea>
    </div>
  );
};


============================================================
FILE_PATH: src\components\DynamicComponents\Components\index.tsx
============================================================
import { DynamicButton } from "./Button";
import { DynamicConfirmModal } from "./ConfirmModal";
import { DynamicLayout } from "./Layout";
import { DynamicGallery } from "./Gallery";
import { DynamicNavigation } from "./Navigation";
import { DynamicTable } from "./Table";
import { DynamicText } from "./Text";
import { DynamicLoadingModal } from "./LoadingModal";
import { DynamicFormModal } from "./FormModal";
import { DynamicFragment } from "./Fragment";
import { DynamicForm } from "./Form";

export const COMPONENTS = {
  Button: DynamicButton,
  ConfirmModal: DynamicConfirmModal,
  Layout: DynamicLayout,
  Gallery: DynamicGallery,
  Navigation: DynamicNavigation,
  Table: DynamicTable,
  Text: DynamicText,
  LoadingModal: DynamicLoadingModal,
  FormModal: DynamicFormModal,
  Fragment: DynamicFragment,
  Form: DynamicForm,
};


============================================================
FILE_PATH: src\components\DynamicComponents\Components\Layout.tsx
============================================================
import { Component, Context } from "@/lib/ComponentBuilders/Component";
import { ReactNode } from "react";

export const DynamicLayout = ({
  config,
  children,
}: Component & { context: Context; children: ReactNode }) => {
  return <div {...config}>{children}</div>;
};


============================================================
FILE_PATH: src\components\DynamicComponents\Components\LoadingModal.tsx
============================================================
import { Component, Context } from "@/lib/ComponentBuilders/Component";
import { LoadingModal } from "@/components/custom/Modals/LoadingModal";
import { useScriptError } from "@/hooks/useScriptError";

type DynamicLoadingModalProps = Component & {
  context: Context;
  config: {
    className?: string;
  };
};

export const DynamicLoadingModal = ({
  config,
  context,
  events,
  id,
}: DynamicLoadingModalProps) => {
  /*   const { openModal, closeModal } = useModals(); */

  // 1. Exponemos los m√©todos open/close al contexto
  /*   const exposedMethods = useMemo(
    () => ({
      open: (data?: { message?: string; subMessage?: string }) =>
        openModal(id, data),
      close: () => closeModal(id),
    }),
    [openModal, closeModal, id]
  );

  useComponentRegistration(context, "loading", id, exposedMethods); */
  const execute = useScriptError();
  const onOpen = async () => {
    await execute(events.onOpen, undefined, context);
  };
  const onClose = async () => {
    await execute(events.onClose, undefined, context);
  };
  // 2. Renderizamos el componente UI base
  return <LoadingModal id={id} {...config} onOpen={onOpen} onClose={onClose} />;
};


============================================================
FILE_PATH: src\components\DynamicComponents\Components\Navigation.tsx
============================================================
/* eslint-disable react-hooks/immutability */
import { Component, Context } from "@/lib/ComponentBuilders/Component";
import { useEffect, useMemo, useState } from "react";
import { useComponentRegistration } from "../useComponentRegistration";
import { cn } from "@/lib/utils";
import { v4 as uuid } from "uuid";

import {
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPage,
} from "@/components/ui/breadcrumb";
import { Button } from "@/components/ui/button";
import { ChevronRight } from "lucide-react";
import { DynamicComponent } from "../DynamicComponent";

type RouteDef = {
  id: string;
  label: string;
  icon?: string;
  children?: any[];
  subRoutes?: RouteDef[];
};

type NavigationProps = Component & {
  context: Context;
  data: { routes: RouteDef[] };
  config: {
    className?: string;
    homeLabel?: string;
    showTabs?: boolean;
    showBreadcrumb?: boolean;
  };
};

// 1. Helper: Encuentra el array de objetos (trail)
const findRouteTrail = (
  allRoutes: RouteDef[],
  pathString: string
): RouteDef[] => {
  if (!pathString) return [];
  const ids = pathString.split("/");
  const trail: RouteDef[] = [];
  let currentLevel = allRoutes;

  for (const id of ids) {
    const found = currentLevel.find((r) => r.id === id);
    if (!found) break;
    trail.push(found);
    if (found.subRoutes) {
      currentLevel = found.subRoutes;
    } else {
      break;
    }
  }
  return trail;
};

// 2. Helper NUEVO: Resuelve la ruta efectiva (Drill-down recursivo)
// Si le das "settings" y settings no tiene contenido pero tiene hijos, devuelve "settings/profile"
const resolveEffectivePath = (
  allRoutes: RouteDef[],
  inputPath: string
): string => {
  const trail = findRouteTrail(allRoutes, inputPath);

  // Si la ruta no existe, devolvemos string vac√≠o para ir al home
  if (trail.length === 0) return "";

  let lastNode = trail[trail.length - 1];
  let effectivePath = inputPath;

  // Mientras el nodo no tenga contenido visual PERO s√≠ tenga subrutas...
  while (
    (!lastNode.children || lastNode.children.length === 0) &&
    lastNode.subRoutes &&
    lastNode.subRoutes.length > 0
  ) {
    const firstChild = lastNode.subRoutes[0];
    effectivePath = `${effectivePath}/${firstChild.id}`;
    lastNode = firstChild;
    trail.push(firstChild);
  }

  return effectivePath;
};

export const DynamicNavigation = ({
  config,
  events,
  context,
  id,
  data,
}: NavigationProps) => {
  data.routes ??= [];
  // 3. Estado Inicial Inteligente
  const [currentPath, setCurrentPath] = useState<string>(() => {
    if (typeof window !== "undefined") {
      const hash = window.location.hash.replace("#", "");

      // A. Si hay hash, intentamos resolver la ruta completa (incluyendo redirecciones autom√°ticas)
      if (hash) {
        const effective = resolveEffectivePath(data.routes, hash);
        if (effective) {
          // Si el usuario escribi√≥ #settings pero lo correcto es #settings/profile,
          // actualizamos la URL autom√°ticamente sin recargar.
          if (effective !== hash) {
            window.history.replaceState(null, "", `#${effective}`);
          }
          return effective;
        }
      }
    }
    // B. Si no hay hash o es inv√°lido, resolvemos la ruta por defecto (el primer item y sus hijos)
    const defaultRoute = data.routes[0];
    const defaultEffective = resolveEffectivePath(
      data.routes,
      defaultRoute?.id || ""
    );
    return defaultEffective;
  });

  const [routeData, setRouteData] = useState<any>(() => {
    if (typeof window !== "undefined") return window.history.state || null;
    return null;
  });

  const activeTrail = useMemo(
    () => findRouteTrail(data.routes, currentPath),
    [data.routes, currentPath]
  );

  const activeNode = activeTrail[activeTrail.length - 1];

  // 4. Navigate (actualizado para usar el helper)
  const navigateTo = (
    route: RouteDef,
    parentPath: string = "",
    extraData: any = null
  ) => {
    const targetPath = parentPath ? `${parentPath}/${route.id}` : route.id;

    // Usamos el helper para calcular si debemos ir m√°s profundo autom√°ticamente
    const effectivePath = resolveEffectivePath(data.routes, targetPath);

    if (
      effectivePath === currentPath &&
      JSON.stringify(extraData) === JSON.stringify(routeData)
    )
      return;

    window.history.pushState(extraData, "", `#${effectivePath}`);
    setCurrentPath(effectivePath);
    setRouteData(extraData);
    events.onNavigate?.(effectivePath, context);
  };

  // 5. Listener de Historial (actualizado para usar el helper)
  useEffect(() => {
    const handleLocationChange = (e?: PopStateEvent | HashChangeEvent) => {
      const hash = window.location.hash.replace("#", "");

      // Resolvemos la ruta real (manejando drill-down si el usuario borr√≥ parte de la url a mano)
      const effective = resolveEffectivePath(data.routes, hash);

      if (effective) {
        setCurrentPath(effective);
        if (e && "state" in e) {
          setRouteData(e.state);
        } else {
          setRouteData(window.history.state);
        }
      } else if (!hash && data.routes.length > 0) {
        // Fallback al inicio
        const defaultEffective = resolveEffectivePath(
          data.routes,
          data.routes[0].id
        );
        setCurrentPath(defaultEffective);
        setRouteData(null);
      }
    };

    window.addEventListener("popstate", handleLocationChange);
    window.addEventListener("hashchange", handleLocationChange);

    return () => {
      window.removeEventListener("popstate", handleLocationChange);
      window.removeEventListener("hashchange", handleLocationChange);
    };
  }, [data.routes]);

  useComponentRegistration(
    context,
    "nav",
    id,
    useMemo(
      () => ({
        // CORRECCI√ìN: Renombramos 'data' a 'payload' para no chocar con 'data.routes'
        navigate: (path: string, payload?: any) => {
          // Ahora 'data.routes' se refiere correctamente a las props del componente
          const effective = resolveEffectivePath(data.routes, path);

          if (effective) {
            // Usamos 'payload' para el estado del historial
            window.history.pushState(payload || null, "", `#${effective}`);
            setCurrentPath(effective);
            setRouteData(payload || null);
          }
        },
        getCurrentPath: () => currentPath,
        getRouteData: () => routeData,
      }),
      [currentPath, routeData, data.routes]
    )
  );

  const navigationLayers = useMemo(() => {
    const layers = [data.routes];
    activeTrail.forEach((node) => {
      if (node.subRoutes && node.subRoutes.length > 0) {
        layers.push(node.subRoutes);
      }
    });
    return layers;
  }, [data.routes, activeTrail]);

  const activeContent = useMemo(() => {
    if (!activeNode?.children) return null;
    return (
      <div
        key={currentPath}
        className="animate-in fade-in zoom-in-95 duration-200 h-full"
      >
        {activeNode?.children.map((item) => {
          item.id ??= uuid();
          return (
            <DynamicComponent data={item} key={item.id} context={context} />
          );
        })}
      </div>
    );
  }, [activeNode, currentPath, DynamicComponent, context]);

  return (
    <div className={cn("flex flex-col gap-4 w-full h-full", config.className)}>
      {/* HEADER */}
      {!(config.showBreadcrumb == false && config.showTabs == false) && (
        <div className="flex flex-col gap-3 border-b pb-4 bg-background/95 backdrop-blur sticky top-0 z-20 px-1 pt-2">
          {/* Breadcrumb */}
          {config.showBreadcrumb !== false && (
            <Breadcrumb>
              <BreadcrumbList>
                <BreadcrumbItem>
                  <BreadcrumbLink
                    className="cursor-pointer hover:text-primary transition-colors"
                    onClick={() => navigateTo(data.routes[0])}
                  >
                    {config.homeLabel || "Inicio"}
                  </BreadcrumbLink>
                </BreadcrumbItem>

                {activeTrail.map((node, index) => {
                  const isLast = index === activeTrail.length - 1;
                  const pathUntilHere = activeTrail
                    .slice(0, index + 1)
                    .map((n) => n.id)
                    .join("/");

                  return (
                    <div
                      key={node.id}
                      className="flex items-center gap-1.5 text-muted-foreground/60"
                    >
                      <ChevronRight className="h-4 w-4" />
                      <BreadcrumbItem>
                        {isLast ? (
                          <BreadcrumbPage className="font-semibold text-primary">
                            {node.label}
                          </BreadcrumbPage>
                        ) : (
                          <BreadcrumbLink
                            className="cursor-pointer hover:text-foreground transition-colors"
                            onClick={() => {
                              window.history.pushState(
                                null,
                                "",
                                `#${pathUntilHere}`
                              );
                              setCurrentPath(pathUntilHere);
                              setRouteData(null);
                            }}
                          >
                            {node.label}
                          </BreadcrumbLink>
                        )}
                      </BreadcrumbItem>
                    </div>
                  );
                })}
              </BreadcrumbList>
            </Breadcrumb>
          )}

          {/* Tabs */}
          {config.showTabs !== false && (
            <div className="flex flex-col gap-2">
              {navigationLayers.map((layerRoutes, layerIndex) => {
                const isRoot = layerIndex === 0;
                const parentPath = activeTrail
                  .slice(0, layerIndex)
                  .map((n) => n.id)
                  .join("/");

                return (
                  <div
                    key={layerIndex}
                    className={cn(
                      "flex flex-wrap gap-2 transition-all animate-in slide-in-from-left-2 duration-300",
                      !isRoot && "pl-2 border-l-2 border-border/50 ml-1"
                    )}
                  >
                    {layerRoutes.map((route) => {
                      const isActive = activeTrail[layerIndex]?.id === route.id;
                      return (
                        <Button
                          key={route.id}
                          variant={
                            isActive
                              ? isRoot
                                ? "default"
                                : "secondary"
                              : "ghost"
                          }
                          size={isRoot ? "default" : "sm"}
                          onClick={() => navigateTo(route, parentPath, null)}
                          className={cn(
                            "transition-all",
                            !isRoot && "h-7 text-xs",
                            isActive && "shadow-sm"
                          )}
                        >
                          {route.label}
                        </Button>
                      );
                    })}
                  </div>
                );
              })}
            </div>
          )}
        </div>
      )}

      <div className="flex-1 min-h-0 overflow-auto relative">
        {activeContent}
      </div>
    </div>
  );
};


============================================================
FILE_PATH: src\components\DynamicComponents\Components\Table.tsx
============================================================
/* eslint-disable react-hooks/immutability */
import { Component, Context } from "@/lib/ComponentBuilders/Component";
import { useDynamicValue } from "@/components/DynamicComponents/useDynamicValue";
import { useMemo, useState } from "react";
import { useComponentRegistration } from "../useComponentRegistration";
import { cn } from "@/lib/utils";

import {
  useReactTable,
  getCoreRowModel,
  getPaginationRowModel,
  getSortedRowModel,
  flexRender,
  SortingState,
  ColumnDef,
} from "@tanstack/react-table";

import {
  Table as UITable,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import {
  ChevronLeft,
  ChevronRight,
  ArrowUpDown,
  Download,
  Trash2,
  Pencil,
} from "lucide-react";

type TableProps = Component & {
  context: Context;
  data: {
    // Recibimos los wrappers din√°micos
    columns: any;
    items: any;
  };
  config: {
    className?: string;
    pageSize?: number;
    enableRowSelection?: boolean;
    enableExport?: boolean;
  };
};

export const DynamicTable = ({
  config,
  events,
  context,
  id,
  data,
}: TableProps) => {
  // 1. Hook para ITEMS (Data) -> Obtenemos reloadItems
  const [itemsRef, setItems, tableData, reloadItems] = useDynamicValue(
    context,
    data.items,
    []
  );

  // 2. Hook para COLUMNAS (Nuevo) -> Las columnas ahora son din√°micas
  const [colsRef, setCols, tableColumns] = useDynamicValue(
    context,
    data.columns,
    []
  );

  const [sorting, setSorting] = useState<SortingState>([]);
  const [rowSelection, setRowSelection] = useState({});
  const [pagination, setPagination] = useState({
    pageIndex: 0,
    pageSize: config.pageSize || 5,
  });

  // --- L√ìGICA DE EXPORTACI√ìN ---
  const handleExport = () => {
    if (!Array.isArray(tableData) || tableData.length === 0) return;

    // Usamos tableColumns en lugar de data.columns est√°tico
    const headers = tableColumns.map((c: any) => c.header).join(",");
    const keys = tableColumns.map((c: any) => c.accessorKey);

    const rows = tableData
      .map((row) =>
        keys.map((k: any) => JSON.stringify(row[k] || "")).join(",")
      )
      .join("\n");

    const csvContent = "data:text/csv;charset=utf-8," + headers + "\n" + rows;
    const encodedUri = encodeURI(csvContent);
    const link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", `export_${id}_${Date.now()}.csv`);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // --- CONSTRUCCI√ìN DE COLUMNAS ---
  const columns = useMemo<ColumnDef<any>[]>(() => {
    const baseCols: ColumnDef<any>[] = [];

    // Columna de Checkbox
    if (config.enableRowSelection) {
      baseCols.push({
        id: "select",
        header: ({ table }) => (
          <Checkbox
            checked={table.getIsAllPageRowsSelected()}
            onCheckedChange={(value) =>
              table.toggleAllPageRowsSelected(!!value)
            }
            aria-label="Select all"
          />
        ),
        cell: ({ row }) => (
          <Checkbox
            checked={row.getIsSelected()}
            onCheckedChange={(value) => row.toggleSelected(!!value)}
            aria-label="Select row"
            onClick={(e) => e.stopPropagation()}
          />
        ),
        enableSorting: false,
        enableHiding: false,
        size: 40,
      });
    }

    // Columnas de Datos (Usamos tableColumns resuelto por el hook)
    const dataCols = (Array.isArray(tableColumns) ? tableColumns : []).map(
      (col: any) => ({
        accessorKey: col.accessorKey,
        header: ({ column }: any) => {
          if (col.enableSorting) {
            return (
              <Button
                variant="ghost"
                onClick={() =>
                  column.toggleSorting(column.getIsSorted() === "asc")
                }
                className="-ml-4 h-8 data-[state=open]:bg-accent"
              >
                {col.header}
                <ArrowUpDown className="ml-2 h-4 w-4" />
              </Button>
            );
          }
          return col.header;
        },
      })
    );
    baseCols.push(...dataCols);

    // Columna de Acciones
    if (events.onEdit || events.onDelete) {
      baseCols.push({
        id: "actions",
        header: "Acciones",
        cell: ({ row }) => {
          return (
            <div className="flex items-center gap-2">
              {events.onEdit && (
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-8 w-8 text-blue-600 hover:text-blue-800"
                  onClick={(e) => {
                    e.stopPropagation();
                    events.onEdit?.(row.original, context);
                  }}
                >
                  <Pencil className="h-4 w-4" />
                </Button>
              )}
              {events.onDelete && (
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-8 w-8 text-red-500 hover:text-red-700 hover:bg-red-50"
                  onClick={(e) => {
                    e.stopPropagation();
                    events.onDelete?.(row.original, context);
                  }}
                >
                  <Trash2 className="h-4 w-4" />
                </Button>
              )}
            </div>
          );
        },
      });
    }

    return baseCols;
  }, [tableColumns, config.enableRowSelection, events, context]); // Dependemos de tableColumns

  const table = useReactTable({
    data: Array.isArray(tableData) ? tableData : [],
    columns,
    getCoreRowModel: getCoreRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    getSortedRowModel: getSortedRowModel(),
    onSortingChange: setSorting,
    onPaginationChange: setPagination,
    onRowSelectionChange: setRowSelection,
    state: {
      sorting,
      pagination,
      rowSelection,
    },
  });

  const selectedRows = table.getFilteredSelectedRowModel().rows;

  const exposedMethods = useMemo(
    () => ({
      setData: (newData: any[]) => {
        setItems(newData);
        setRowSelection({});
      },
      getData: () => itemsRef.current,
      getSelectedRows: () =>
        table.getSelectedRowModel().rows.map((r) => r.original),
      // 3. Exponemos el reload (recarga principalmente los items)
      reload: () => reloadItems(),
    }),
    [setItems, itemsRef, table, reloadItems]
  );

  useComponentRegistration(context, "table", id, exposedMethods);

  // Renderizado (Igual que antes, solo aseg√∫rate de usar tableColumns si necesitas leer headers manualmente en export)
  return (
    <div className={cn("w-full flex flex-col gap-4", config.className)}>
      {/* ... El resto del JSX se mantiene igual ... */}
      {/* Solo aseg√∫rate de copiar el JSX del archivo anterior completo aqu√≠ */}
      <div className="flex items-center justify-between min-h-[40px]">
        <div className="flex items-center gap-2">
          {selectedRows.length > 0 && events.onBulkDelete && (
            <div className="flex items-center gap-2 animate-in fade-in slide-in-from-left-2 duration-300">
              <span className="text-sm text-muted-foreground border-r pr-3 mr-1">
                {selectedRows.length} seleccionados
              </span>
              <Button
                variant="destructive"
                size="sm"
                onClick={() => {
                  const items = selectedRows.map((r) => r.original);
                  events.onBulkDelete?.(items, context);
                  setRowSelection({});
                }}
              >
                <Trash2 className="mr-2 h-4 w-4" />
                Eliminar Selecci√≥n
              </Button>
            </div>
          )}
        </div>

        {config.enableExport !== false && (
          <Button variant="outline" size="sm" onClick={handleExport}>
            <Download className="mr-2 h-4 w-4" />
            Exportar CSV
          </Button>
        )}
      </div>

      <div className="rounded-md border bg-card">
        <UITable>
          <TableHeader>
            {table.getHeaderGroups().map((headerGroup) => (
              <TableRow key={headerGroup.id}>
                {headerGroup.headers.map((header) => (
                  <TableHead key={header.id}>
                    {header.isPlaceholder
                      ? null
                      : flexRender(
                          header.column.columnDef.header,
                          header.getContext()
                        )}
                  </TableHead>
                ))}
              </TableRow>
            ))}
          </TableHeader>
          <TableBody>
            {table.getRowModel().rows?.length ? (
              table.getRowModel().rows.map((row) => (
                <TableRow
                  key={row.id}
                  data-state={row.getIsSelected() && "selected"}
                  className={
                    events.onRowClick ? "cursor-pointer hover:bg-muted/50" : ""
                  }
                  onClick={() => events.onRowClick?.(row.original, context)}
                >
                  {row.getVisibleCells().map((cell) => (
                    <TableCell key={cell.id}>
                      {flexRender(
                        cell.column.columnDef.cell,
                        cell.getContext()
                      )}
                    </TableCell>
                  ))}
                </TableRow>
              ))
            ) : (
              <TableRow>
                <TableCell
                  colSpan={columns.length}
                  className="h-24 text-center"
                >
                  No hay resultados.
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </UITable>
      </div>

      <div className="flex items-center justify-end space-x-2">
        <div className="text-sm text-muted-foreground">
          P√°gina {table.getState().pagination.pageIndex + 1} de{" "}
          {table.getPageCount()}
        </div>
        <div className="space-x-2">
          <Button
            variant="outline"
            size="sm"
            onClick={() => table.previousPage()}
            disabled={!table.getCanPreviousPage()}
          >
            <ChevronLeft className="h-4 w-4" />
          </Button>
          <Button
            variant="outline"
            size="sm"
            onClick={() => table.nextPage()}
            disabled={!table.getCanNextPage()}
          >
            <ChevronRight className="h-4 w-4" />
          </Button>
        </div>
      </div>
    </div>
  );
};


============================================================
FILE_PATH: src\components\DynamicComponents\Components\Text.tsx
============================================================
/* eslint-disable react-hooks/immutability */
import { Component, Context } from "@/lib/ComponentBuilders/Component";
import { useDynamicValue } from "@/components/DynamicComponents/useDynamicValue";
import { JSX, useMemo } from "react";
import { useComponentRegistration } from "../useComponentRegistration";
import { cn } from "@/lib/utils";

type TextProps = Component & {
  context: Context;
  data: {
    content: any; // DynamicValue<string>
  };
  config: {
    className?: string;
    variant?:
      | "h1"
      | "h2"
      | "h3"
      | "h4"
      | "p"
      | "blockquote"
      | "lead"
      | "large"
      | "small"
      | "muted";
    align?: "left" | "center" | "right" | "justify";
    style: Record<string, any>;
  };
};

// Mapa de variantes a etiquetas HTML
const TagMap: Record<string, string> = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  p: "p",
  blockquote: "blockquote",
  lead: "p",
  large: "div",
  small: "small",
  muted: "p",
};

// Mapa de variantes a clases de Tailwind (Tipograf√≠a Shadcn)
const ClassMap: Record<string, string> = {
  h1: "scroll-m-20 text-4xl font-extrabold tracking-tight lg:text-5xl",
  h2: "scroll-m-20 border-b pb-2 text-3xl font-semibold tracking-tight first:mt-0",
  h3: "scroll-m-20 text-2xl font-semibold tracking-tight",
  h4: "scroll-m-20 text-xl font-semibold tracking-tight",
  p: "leading-7 [&:not(:first-child)]:mt-6",
  blockquote: "mt-6 border-l-2 pl-6 italic",
  lead: "text-xl text-muted-foreground",
  large: "text-lg font-semibold",
  small: "text-sm font-medium leading-none",
  muted: "text-sm text-muted-foreground",
};

const AlignMap: Record<string, string> = {
  left: "text-left",
  center: "text-center",
  right: "text-right",
  justify: "text-justify",
};

export const DynamicText = ({
  config,
  events,
  context,
  id,
  data,
}: TextProps) => {
  // 1. Manejo din√°mico del contenido
  const [contentRef, setContent, content] = useDynamicValue(
    context,
    data.content,
    ""
  );

  // 2. Exponer m√©todos
  const exposedMethods = useMemo(
    () => ({
      setText: (text: string) => setContent(text),
      getText: () => contentRef.current,
    }),
    [setContent, contentRef]
  );

  useComponentRegistration(context, "text", id, exposedMethods);

  // 3. Determinar etiqueta y clases
  const variant = config.variant || "p";
  const Tag = (TagMap[variant] as keyof JSX.IntrinsicElements) || "p";
  const alignClass = AlignMap[config.align || "left"];
  const variantClass = ClassMap[variant] || ClassMap["p"];

  return (
    <Tag
      className={cn(
        variantClass,
        alignClass,
        events.onClick && "cursor-pointer hover:opacity-80 transition-opacity", // Feedback visual si es clickeable
        config.className
      )}
      onClick={() => events.onClick?.(null, context)}
      style={config.style}
    >
      {content}
    </Tag>
  );
};


============================================================
FILE_PATH: src\components\ui\BottomTabs.tsx
============================================================
"use client";

import React, { useEffect, useState, useRef } from "react";
import { Plus, X } from "lucide-react";
import { cn } from "@/lib/utils";
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragEndEvent,
} from "@dnd-kit/core";
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  useSortable,
  horizontalListSortingStrategy,
} from "@dnd-kit/sortable";
import { CSS } from "@dnd-kit/utilities";
import { restrictToHorizontalAxis } from "@dnd-kit/modifiers";

// --- Tipos ---

export interface TabData {
  id: string;
  label: string;
}

interface TabsProps {
  initialTabs?: TabData[];
  onSelect?: (tabId: string) => void;
  onDelete?: (tabId: string) => void;
  onAdd?: (newTab: TabData) => void;
  onRename?: (tabId: string, newLabel: string) => void;
  onReorder?: (newOrder: TabData[]) => void;

  /** * BLOQUEADOR: Si se provee, se ejecutar√° antes de eliminar.
   * @param tabId El ID de la pesta√±a a eliminar.
   * @param confirmDelete La funci√≥n que DEBE llamarse para proceder con la eliminaci√≥n.
   */
  onDeleteRequest?: (tabId: string, confirmDelete: () => void) => void;
}

// --- Componente Individual (Sin cambios) ---

interface SortableTabProps {
  tab: TabData;
  isActive: boolean;
  onClick: () => void;
  onClose: (e: React.MouseEvent) => void;
  onRename: (id: string, newName: string) => void;
}

const SortableTab = ({
  tab,
  isActive,
  onClick,
  onClose,
  onRename,
}: SortableTabProps) => {
  const { attributes, listeners, setNodeRef, transform, transition } =
    useSortable({ id: tab.id });

  const [isEditing, setIsEditing] = useState(false);
  const [editValue, setEditValue] = useState(tab.label);
  const inputRef = useRef<HTMLInputElement>(null);

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
  };

  useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [isEditing]);

  const handleFinishEdit = () => {
    setIsEditing(false);
    if (editValue.trim() !== "") {
      onRename(tab.id, editValue);
    } else {
      setEditValue(tab.label);
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter") handleFinishEdit();
    if (e.key === "Escape") {
      setIsEditing(false);
      setEditValue(tab.label);
    }
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      {...attributes}
      {...listeners}
      onClick={onClick}
      className={cn(
        "group flex min-w-[120px] max-w-[200px] cursor-pointer select-none items-center justify-between border-r px-4 py-1.5 text-sm transition-colors shrink-0",
        isActive
          ? "bg-background font-medium text-foreground z-10 shadow-[inset_0_-2px_0_0_hsl(var(--primary))]"
          : "bg-muted/50 hover:bg-muted text-muted-foreground"
      )}
    >
      {isEditing ? (
        <input
          ref={inputRef}
          value={editValue}
          onChange={(e) => setEditValue(e.target.value)}
          onBlur={handleFinishEdit}
          onKeyDown={handleKeyDown}
          onPointerDown={(e) => e.stopPropagation()}
          className="h-5 w-full min-w-0 max-w-20 bg-transparent outline-none focus:border-b focus:border-primary text-foreground"
        />
      ) : (
        <span
          className="truncate w-full"
          onDoubleClick={() => setIsEditing(true)}
          title="Doble click para renombrar"
        >
          {tab.label}
        </span>
      )}

      <button
        onClick={onClose}
        onPointerDown={(e) => e.stopPropagation()}
        className={cn(
          "ml-2 rounded-full p-0.5 hover:bg-red-200 hover:text-red-700 opacity-0 transition-all",
          (isActive || "group-hover:opacity-100") && "opacity-100"
        )}
      >
        <X className="size-3" />
      </button>
    </div>
  );
};

// --- Componente Principal ---

export function Tabs({
  initialTabs,
  onSelect,
  onDelete,
  onAdd,
  onRename,
  onReorder,
  onDeleteRequest, // <--- Nueva prop recibida
}: TabsProps) {
  const [isMounted, setIsMounted] = useState(false);
  const [activeTabId, setActiveTabId] = useState("sheet1");

  const [tabs, setTabs] = useState<TabData[]>(
    initialTabs || [
      { id: "sheet1", label: "Hoja 1" },
      { id: "sheet2", label: "Hoja 2" },
    ]
  );

  useEffect(() => {
    // eslint-disable-next-line react-hooks/set-state-in-effect
    setIsMounted(true);
  }, []);

  const sensors = useSensors(
    useSensor(PointerSensor, { activationConstraint: { distance: 8 } }),
    useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })
  );

  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;
    if (over && active.id !== over.id) {
      setTabs((items) => {
        const oldIndex = items.findIndex((i) => i.id === active.id);
        const newIndex = items.findIndex((i) => i.id === over.id);
        const newOrder = arrayMove(items, oldIndex, newIndex);
        if (onReorder) onReorder(newOrder);
        return newOrder;
      });
    }
  };

  const handleAddTab = () => {
    const newId = `sheet-${Date.now()}`;
    const num = tabs.length + 1;
    const newTab: TabData = { id: newId, label: `Hoja ${num}` };
    const updatedTabs = [...tabs, newTab];
    setTabs(updatedTabs);
    setActiveTabId(newId);
    if (onAdd) onAdd(newTab);
    if (onSelect) onSelect(newId);
  };

  // --- L√ìGICA DE ELIMINACI√ìN MODIFICADA ---
  const handleCloseTab = (e: React.MouseEvent, id: string) => {
    e.stopPropagation();
    if (tabs.length <= 1) return;

    // 1. Definimos la acci√≥n real de eliminar
    const executeDelete = () => {
      // Nota: Usamos setTabs con callback para asegurar el estado m√°s fresco
      setTabs((currentTabs) => {
        const targetIndex = currentTabs.findIndex((t) => t.id === id);
        const newTabs = currentTabs.filter((t) => t.id !== id);

        // Ajustar tab activa si borramos la que estaba seleccionada
        if (activeTabId === id) {
          const newActiveIndex = Math.max(0, targetIndex - 1);
          // Verificar que existe una pesta√±a remanente
          if (newTabs[newActiveIndex]) {
            const newActiveId = newTabs[newActiveIndex].id;
            setActiveTabId(newActiveId);
            if (onSelect) onSelect(newActiveId);
          }
        }
        return newTabs;
      });

      // Notificar eliminaci√≥n exitosa
      if (onDelete) onDelete(id);
    };

    // 2. Comprobamos si hay un interceptor (onDeleteRequest)
    if (onDeleteRequest) {
      // Pasamos el ID y la funci√≥n para ejecutar la eliminaci√≥n
      onDeleteRequest(id, executeDelete);
    } else {
      // Si no hay interceptor, eliminamos directamente
      executeDelete();
    }
  };

  const handleTabClick = (id: string) => {
    setActiveTabId(id);
    if (onSelect) onSelect(id);
  };

  const handleRename = (id: string, newLabel: string) => {
    const updatedTabs = tabs.map((t) =>
      t.id === id ? { ...t, label: newLabel } : t
    );
    setTabs(updatedTabs);
    if (onRename) onRename(id, newLabel);
  };

  if (!isMounted) return <div className="h-10 border-t bg-muted/30" />;

  return (
    <div className="flex h-12 w-full items-start pt-1 border-t bg-muted/30">
      <div className="flex flex-1 overflow-x-auto overflow-y-hidden pb-1 [&::-webkit-scrollbar]:h-2 [&::-webkit-scrollbar-thumb]:rounded-full [&::-webkit-scrollbar-thumb]:bg-muted-foreground/20 hover:[&::-webkit-scrollbar-thumb]:bg-muted-foreground/40 [&::-webkit-scrollbar-track]:bg-transparent">
        <DndContext
          sensors={sensors}
          collisionDetection={closestCenter}
          onDragEnd={handleDragEnd}
          modifiers={[restrictToHorizontalAxis]}
        >
          <SortableContext
            items={tabs.map((t) => t.id)}
            strategy={horizontalListSortingStrategy}
          >
            <div className="flex h-full min-w-max items-center">
              {tabs.map((tab) => (
                <SortableTab
                  key={tab.id}
                  tab={tab}
                  isActive={activeTabId === tab.id}
                  onClick={() => handleTabClick(tab.id)}
                  onClose={(e) => handleCloseTab(e, tab.id)}
                  onRename={handleRename}
                />
              ))}
            </div>
          </SortableContext>
        </DndContext>
      </div>

      <button
        onClick={handleAddTab}
        className="flex h-full w-10 shrink-0 items-center justify-center border-l hover:bg-muted transition-colors text-muted-foreground z-20 bg-muted/30"
        title="Nueva hoja"
      >
        <Plus className="size-5" />
      </button>
    </div>
  );
}


============================================================
FILE_PATH: src\components\ui\breadcrumb.tsx
============================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

function Breadcrumb({ ...props }: React.ComponentProps<"nav">) {
  return <nav aria-label="breadcrumb" data-slot="breadcrumb" {...props} />
}

function BreadcrumbList({ className, ...props }: React.ComponentProps<"ol">) {
  return (
    <ol
      data-slot="breadcrumb-list"
      className={cn(
        "text-muted-foreground flex flex-wrap items-center gap-1.5 text-sm break-words sm:gap-2.5",
        className
      )}
      {...props}
    />
  )
}

function BreadcrumbItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-item"
      className={cn("inline-flex items-center gap-1.5", className)}
      {...props}
    />
  )
}

function BreadcrumbLink({
  asChild,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
}) {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      data-slot="breadcrumb-link"
      className={cn("hover:text-foreground transition-colors", className)}
      {...props}
    />
  )
}

function BreadcrumbPage({ className, ...props }: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-page"
      role="link"
      aria-disabled="true"
      aria-current="page"
      className={cn("text-foreground font-normal", className)}
      {...props}
    />
  )
}

function BreadcrumbSeparator({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-separator"
      role="presentation"
      aria-hidden="true"
      className={cn("[&>svg]:size-3.5", className)}
      {...props}
    >
      {children ?? <ChevronRight />}
    </li>
  )
}

function BreadcrumbEllipsis({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-ellipsis"
      role="presentation"
      aria-hidden="true"
      className={cn("flex size-9 items-center justify-center", className)}
      {...props}
    >
      <MoreHorizontal className="size-4" />
      <span className="sr-only">More</span>
    </span>
  )
}

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}


============================================================
FILE_PATH: src\components\ui\button-group.tsx
============================================================
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { Separator } from "@/components/ui/separator"

const buttonGroupVariants = cva(
  "flex w-fit items-stretch [&>*]:focus-visible:z-10 [&>*]:focus-visible:relative [&>[data-slot=select-trigger]:not([class*='w-'])]:w-fit [&>input]:flex-1 has-[select[aria-hidden=true]:last-child]:[&>[data-slot=select-trigger]:last-of-type]:rounded-r-md has-[>[data-slot=button-group]]:gap-2",
  {
    variants: {
      orientation: {
        horizontal:
          "[&>*:not(:first-child)]:rounded-l-none [&>*:not(:first-child)]:border-l-0 [&>*:not(:last-child)]:rounded-r-none",
        vertical:
          "flex-col [&>*:not(:first-child)]:rounded-t-none [&>*:not(:first-child)]:border-t-0 [&>*:not(:last-child)]:rounded-b-none",
      },
    },
    defaultVariants: {
      orientation: "horizontal",
    },
  }
)

function ButtonGroup({
  className,
  orientation,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof buttonGroupVariants>) {
  return (
    <div
      role="group"
      data-slot="button-group"
      data-orientation={orientation}
      className={cn(buttonGroupVariants({ orientation }), className)}
      {...props}
    />
  )
}

function ButtonGroupText({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"div"> & {
  asChild?: boolean
}) {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      className={cn(
        "bg-muted flex items-center gap-2 rounded-md border px-4 text-sm font-medium shadow-xs [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function ButtonGroupSeparator({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="button-group-separator"
      orientation={orientation}
      className={cn(
        "bg-input relative !m-0 self-stretch data-[orientation=vertical]:h-auto",
        className
      )}
      {...props}
    />
  )
}

export {
  ButtonGroup,
  ButtonGroupSeparator,
  ButtonGroupText,
  buttonGroupVariants,
}


============================================================
FILE_PATH: src\components\ui\button.tsx
============================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
        "icon-sm": "size-8",
        "icon-lg": "size-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant = "default",
  size = "default",
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      data-variant={variant}
      data-size={size}
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }


============================================================
FILE_PATH: src\components\ui\card.tsx
============================================================
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-2 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}


============================================================
FILE_PATH: src\components\ui\checkbox.tsx
============================================================
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { CheckIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="grid place-content-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}

export { Checkbox }


============================================================
FILE_PATH: src\components\ui\command.tsx
============================================================
"use client"

import * as React from "react"
import { Command as CommandPrimitive } from "cmdk"
import { SearchIcon } from "lucide-react"

import { cn } from "@/lib/utils"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"

function Command({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive>) {
  return (
    <CommandPrimitive
      data-slot="command"
      className={cn(
        "bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md",
        className
      )}
      {...props}
    />
  )
}

function CommandDialog({
  title = "Command Palette",
  description = "Search for a command to run...",
  children,
  className,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof Dialog> & {
  title?: string
  description?: string
  className?: string
  showCloseButton?: boolean
}) {
  return (
    <Dialog {...props}>
      <DialogHeader className="sr-only">
        <DialogTitle>{title}</DialogTitle>
        <DialogDescription>{description}</DialogDescription>
      </DialogHeader>
      <DialogContent
        className={cn("overflow-hidden p-0", className)}
        showCloseButton={showCloseButton}
      >
        <Command className="[&_[cmdk-group-heading]]:text-muted-foreground **:data-[slot=command-input-wrapper]:h-12 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

function CommandInput({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Input>) {
  return (
    <div
      data-slot="command-input-wrapper"
      className="flex h-9 items-center gap-2 border-b px-3"
    >
      <SearchIcon className="size-4 shrink-0 opacity-50" />
      <CommandPrimitive.Input
        data-slot="command-input"
        className={cn(
          "placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        {...props}
      />
    </div>
  )
}

function CommandList({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.List>) {
  return (
    <CommandPrimitive.List
      data-slot="command-list"
      className={cn(
        "max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto",
        className
      )}
      {...props}
    />
  )
}

function CommandEmpty({
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Empty>) {
  return (
    <CommandPrimitive.Empty
      data-slot="command-empty"
      className="py-6 text-center text-sm"
      {...props}
    />
  )
}

function CommandGroup({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Group>) {
  return (
    <CommandPrimitive.Group
      data-slot="command-group"
      className={cn(
        "text-foreground [&_[cmdk-group-heading]]:text-muted-foreground overflow-hidden p-1 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium",
        className
      )}
      {...props}
    />
  )
}

function CommandSeparator({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Separator>) {
  return (
    <CommandPrimitive.Separator
      data-slot="command-separator"
      className={cn("bg-border -mx-1 h-px", className)}
      {...props}
    />
  )
}

function CommandItem({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Item>) {
  return (
    <CommandPrimitive.Item
      data-slot="command-item"
      className={cn(
        "data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function CommandShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="command-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}


============================================================
FILE_PATH: src\components\ui\context-menu.tsx
============================================================
"use client"

import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function ContextMenu({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Root>) {
  return <ContextMenuPrimitive.Root data-slot="context-menu" {...props} />
}

function ContextMenuTrigger({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Trigger>) {
  return (
    <ContextMenuPrimitive.Trigger data-slot="context-menu-trigger" {...props} />
  )
}

function ContextMenuGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Group>) {
  return (
    <ContextMenuPrimitive.Group data-slot="context-menu-group" {...props} />
  )
}

function ContextMenuPortal({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Portal>) {
  return (
    <ContextMenuPrimitive.Portal data-slot="context-menu-portal" {...props} />
  )
}

function ContextMenuSub({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Sub>) {
  return <ContextMenuPrimitive.Sub data-slot="context-menu-sub" {...props} />
}

function ContextMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioGroup>) {
  return (
    <ContextMenuPrimitive.RadioGroup
      data-slot="context-menu-radio-group"
      {...props}
    />
  )
}

function ContextMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <ContextMenuPrimitive.SubTrigger
      data-slot="context-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto" />
    </ContextMenuPrimitive.SubTrigger>
  )
}

function ContextMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubContent>) {
  return (
    <ContextMenuPrimitive.SubContent
      data-slot="context-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

function ContextMenuContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Content>) {
  return (
    <ContextMenuPrimitive.Portal>
      <ContextMenuPrimitive.Content
        data-slot="context-menu-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-context-menu-content-available-height) min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </ContextMenuPrimitive.Portal>
  )
}

function ContextMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <ContextMenuPrimitive.Item
      data-slot="context-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function ContextMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.CheckboxItem>) {
  return (
    <ContextMenuPrimitive.CheckboxItem
      data-slot="context-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.CheckboxItem>
  )
}

function ContextMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioItem>) {
  return (
    <ContextMenuPrimitive.RadioItem
      data-slot="context-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.RadioItem>
  )
}

function ContextMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <ContextMenuPrimitive.Label
      data-slot="context-menu-label"
      data-inset={inset}
      className={cn(
        "text-foreground px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function ContextMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Separator>) {
  return (
    <ContextMenuPrimitive.Separator
      data-slot="context-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function ContextMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="context-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}


============================================================
FILE_PATH: src\components\ui\dialog.tsx
============================================================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 outline-none sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}


============================================================
FILE_PATH: src\components\ui\dropdown-menu.tsx
============================================================
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}


============================================================
FILE_PATH: src\components\ui\form.tsx
============================================================
"use client"

import * as React from "react"
import type * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  useFormState,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState } = useFormContext()
  const formState = useFormState({ name: fieldContext.name })
  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

function FormItem({ className, ...props }: React.ComponentProps<"div">) {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div
        data-slot="form-item"
        className={cn("grid gap-2", className)}
        {...props}
      />
    </FormItemContext.Provider>
  )
}

function FormLabel({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  const { error, formItemId } = useFormField()

  return (
    <Label
      data-slot="form-label"
      data-error={!!error}
      className={cn("data-[error=true]:text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
}

function FormControl({ ...props }: React.ComponentProps<typeof Slot>) {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      data-slot="form-control"
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
}

function FormDescription({ className, ...props }: React.ComponentProps<"p">) {
  const { formDescriptionId } = useFormField()

  return (
    <p
      data-slot="form-description"
      id={formDescriptionId}
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function FormMessage({ className, ...props }: React.ComponentProps<"p">) {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : props.children

  if (!body) {
    return null
  }

  return (
    <p
      data-slot="form-message"
      id={formMessageId}
      className={cn("text-destructive text-sm", className)}
      {...props}
    >
      {body}
    </p>
  )
}

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}


============================================================
FILE_PATH: src\components\ui\input.tsx
============================================================
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }


============================================================
FILE_PATH: src\components\ui\label.tsx
============================================================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }


============================================================
FILE_PATH: src\components\ui\popover.tsx
============================================================
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  )
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }


============================================================
FILE_PATH: src\components\ui\scroll-area.tsx
============================================================
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }


============================================================
FILE_PATH: src\components\ui\select.tsx
============================================================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "item-aligned",
  align = "center",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        align={align}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span
        data-slot="select-item-indicator"
        className="absolute right-2 flex size-3.5 items-center justify-center"
      >
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}


============================================================
FILE_PATH: src\components\ui\separator.tsx
============================================================
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }


============================================================
FILE_PATH: src\components\ui\sheet.tsx
============================================================
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}


============================================================
FILE_PATH: src\components\ui\sidebar.tsx
============================================================
/* eslint-disable react-hooks/purity */
"use client";

import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import { PanelLeftIcon } from "lucide-react";

import { useIsMobile } from "@/hooks/use-mobile";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Separator } from "@/components/ui/separator";
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet";
import { Skeleton } from "@/components/ui/skeleton";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

const SIDEBAR_COOKIE_NAME = "sidebar_state";
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;
const SIDEBAR_WIDTH = "16rem";
const SIDEBAR_WIDTH_MOBILE = "18rem";
const SIDEBAR_WIDTH_ICON = "3rem";
const SIDEBAR_KEYBOARD_SHORTCUT = "b";

type SidebarContextProps = {
  state: "expanded" | "collapsed";
  open: boolean;
  setOpen: (open: boolean) => void;
  openMobile: boolean;
  setOpenMobile: (open: boolean) => void;
  isMobile: boolean;
  toggleSidebar: () => void;
};

const SidebarContext = React.createContext<SidebarContextProps | null>(null);

function useSidebar() {
  const context = React.useContext(SidebarContext);
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.");
  }

  return context;
}

function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  defaultOpen?: boolean;
  open?: boolean;
  onOpenChange?: (open: boolean) => void;
}) {
  const isMobile = useIsMobile();
  const [openMobile, setOpenMobile] = React.useState(false);

  // This is the internal state of the sidebar.
  // We use openProp and setOpenProp for control from outside the component.
  const [_open, _setOpen] = React.useState(defaultOpen);
  const open = openProp ?? _open;
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === "function" ? value(open) : value;
      if (setOpenProp) {
        setOpenProp(openState);
      } else {
        _setOpen(openState);
      }

      // This sets the cookie to keep the sidebar state.
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`;
    },
    [setOpenProp, open]
  );

  // Helper to toggle the sidebar.
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open);
  }, [isMobile, setOpen, setOpenMobile]);

  // Adds a keyboard shortcut to toggle the sidebar.
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (
        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
        (event.metaKey || event.ctrlKey)
      ) {
        event.preventDefault();
        toggleSidebar();
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [toggleSidebar]);

  // We add a state so that we can do data-state="expanded" or "collapsed".
  // This makes it easier to style the sidebar with Tailwind classes.
  const state = open ? "expanded" : "collapsed";

  const contextValue = React.useMemo<SidebarContextProps>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
  );

  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          data-slot="sidebar-wrapper"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH,
              "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn(
            "group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full",
            className
          )}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  );
}

function Sidebar({
  side = "left",
  variant = "sidebar",
  collapsible = "offcanvas",
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  side?: "left" | "right";
  variant?: "sidebar" | "floating" | "inset";
  collapsible?: "offcanvas" | "icon" | "none";
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar();

  if (collapsible === "none") {
    return (
      <div
        data-slot="sidebar"
        className={cn(
          "bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col",
          className
        )}
        {...props}
      >
        {children}
      </div>
    );
  }

  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-slot="sidebar"
          data-mobile="true"
          className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <SheetHeader className="sr-only">
            <SheetTitle>Sidebar</SheetTitle>
            <SheetDescription>Displays the mobile sidebar.</SheetDescription>
          </SheetHeader>
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    );
  }

  return (
    <div
      className="group peer text-sidebar-foreground hidden md:block"
      data-state={state}
      data-collapsible={state === "collapsed" ? collapsible : ""}
      data-variant={variant}
      data-side={side}
      data-slot="sidebar"
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        data-slot="sidebar-gap"
        className={cn(
          "relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear",
          "group-data-[collapsible=offcanvas]:w-0",
          "group-data-[side=right]:rotate-180",
          variant === "floating" || variant === "inset"
            ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon)"
        )}
      />
      <div
        data-slot="sidebar-container"
        className={cn(
          "fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex",
          side === "left"
            ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
            : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          variant === "floating" || variant === "inset"
            ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l",
          className
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          data-slot="sidebar-inner"
          className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
        >
          {children}
        </div>
      </div>
    </div>
  );
}

function SidebarTrigger({
  className,
  onClick,
  classNameIcon,
  ...props
}: React.ComponentProps<typeof Button> & { classNameIcon?: string }) {
  const { toggleSidebar } = useSidebar();

  return (
    <Button
      data-sidebar="trigger"
      data-slot="sidebar-trigger"
      variant="ghost"
      size="icon"
      className={cn("size-7", className)}
      onClick={(event) => {
        onClick?.(event);
        toggleSidebar();
      }}
      {...props}
    >
      <PanelLeftIcon className={classNameIcon} />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  );
}

function SidebarRail({ className, ...props }: React.ComponentProps<"button">) {
  const { toggleSidebar } = useSidebar();

  return (
    <button
      data-sidebar="rail"
      data-slot="sidebar-rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex",
        "in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  );
}

function SidebarInset({ className, ...props }: React.ComponentProps<"main">) {
  return (
    <main
      data-slot="sidebar-inset"
      className={cn(
        "bg-background relative flex w-full flex-1 flex-col",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2",
        className
      )}
      {...props}
    />
  );
}

function SidebarInput({
  className,
  ...props
}: React.ComponentProps<typeof Input>) {
  return (
    <Input
      data-slot="sidebar-input"
      data-sidebar="input"
      className={cn("bg-background h-8 w-full shadow-none", className)}
      {...props}
    />
  );
}

function SidebarHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-header"
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  );
}

function SidebarFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-footer"
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  );
}

function SidebarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="sidebar-separator"
      data-sidebar="separator"
      className={cn("bg-sidebar-border mx-2 w-auto", className)}
      {...props}
    />
  );
}

function SidebarContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-content"
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  );
}

function SidebarGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group"
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  );
}

function SidebarGroupLabel({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"div"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "div";

  return (
    <Comp
      data-slot="sidebar-group-label"
      data-sidebar="group-label"
      className={cn(
        "text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  );
}

function SidebarGroupAction({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "button";

  return (
    <Comp
      data-slot="sidebar-group-action"
      data-sidebar="group-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  );
}

function SidebarGroupContent({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group-content"
      data-sidebar="group-content"
      className={cn("w-full text-sm", className)}
      {...props}
    />
  );
}

function SidebarMenu({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu"
      data-sidebar="menu"
      className={cn("flex w-full min-w-0 flex-col gap-1", className)}
      {...props}
    />
  );
}

function SidebarMenuItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-item"
      data-sidebar="menu-item"
      className={cn("group/menu-item relative", className)}
      {...props}
    />
  );
}

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = "default",
  size = "default",
  tooltip,
  className,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean;
  isActive?: boolean;
  tooltip?: string | React.ComponentProps<typeof TooltipContent>;
} & VariantProps<typeof sidebarMenuButtonVariants>) {
  const Comp = asChild ? Slot : "button";
  const { isMobile, state } = useSidebar();

  const button = (
    <Comp
      data-slot="sidebar-menu-button"
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  );

  if (!tooltip) {
    return button;
  }

  if (typeof tooltip === "string") {
    tooltip = {
      children: tooltip,
    };
  }

  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent
        side="right"
        align="center"
        hidden={state !== "collapsed" || isMobile}
        {...tooltip}
      />
    </Tooltip>
  );
}

function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean;
  showOnHover?: boolean;
}) {
  const Comp = asChild ? Slot : "button";

  return (
    <Comp
      data-slot="sidebar-menu-action"
      data-sidebar="menu-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0",
        className
      )}
      {...props}
    />
  );
}

function SidebarMenuBadge({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-menu-badge"
      data-sidebar="menu-badge"
      className={cn(
        "text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none",
        "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  );
}

function SidebarMenuSkeleton({
  className,
  showIcon = false,
  ...props
}: React.ComponentProps<"div"> & {
  showIcon?: boolean;
}) {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`;
  }, []);

  return (
    <div
      data-slot="sidebar-menu-skeleton"
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-(--skeleton-width) flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  );
}

function SidebarMenuSub({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu-sub"
      data-sidebar="menu-sub"
      className={cn(
        "border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  );
}

function SidebarMenuSubItem({
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-sub-item"
      data-sidebar="menu-sub-item"
      className={cn("group/menu-sub-item relative", className)}
      {...props}
    />
  );
}

function SidebarMenuSubButton({
  asChild = false,
  size = "md",
  isActive = false,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean;
  size?: "sm" | "md";
  isActive?: boolean;
}) {
  const Comp = asChild ? Slot : "a";

  return (
    <Comp
      data-slot="sidebar-menu-sub-button"
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  );
}

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
};


============================================================
FILE_PATH: src\components\ui\skeleton.tsx
============================================================
import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }


============================================================
FILE_PATH: src\components\ui\switch.tsx
============================================================
"use client"

import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }


============================================================
FILE_PATH: src\components\ui\table.tsx
============================================================
"use client"

import * as React from "react"

import { cn } from "@/lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}


============================================================
FILE_PATH: src\components\ui\tabs.tsx
============================================================
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }


============================================================
FILE_PATH: src\components\ui\tooltip.tsx
============================================================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-foreground text-background animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-foreground fill-foreground z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }


============================================================
FILE_PATH: src\features\auth\index.ts
============================================================
export { AuthButtons } from "./components/AuthButtons";
export { AuthHeader } from "./components/AuthHeader";
export { LoginForm } from "./components/LoginForm";
export { useAuth } from "./hooks/useAuth";


============================================================
FILE_PATH: src\features\auth\components\AuthButtons.tsx
============================================================
import { Button } from "@/components/ui/button";

export const AuthButtons = ({
  isSignUp,
  setIsSignUp,
}: {
  isSignUp: boolean;
  setIsSignUp: (value: boolean) => void;
}) => (
  <Button
    variant="link"
    className="text-sm text-muted-foreground"
    onClick={() => setIsSignUp(!isSignUp)}
  >
    {isSignUp
      ? "¬øYa tienes cuenta? Inicia sesi√≥n"
      : "¬øNo tienes cuenta? Reg√≠strate"}
  </Button>
);


============================================================
FILE_PATH: src\features\auth\components\AuthHeader.tsx
============================================================
import { CardDescription, CardHeader, CardTitle } from "@/components/ui/card";

export const AuthHeader = ({ isSignUp }: { isSignUp: boolean }) => (
  <CardHeader className="space-y-1">
    <CardTitle className="text-2xl font-bold text-center">
      {isSignUp ? "Crear cuenta" : "Bienvenido de nuevo"}
    </CardTitle>
    <CardDescription className="text-center">
      {isSignUp
        ? "Ingresa tus datos para registrarte en la plataforma"
        : "Ingresa tu email y contrase√±a para acceder"}
    </CardDescription>
  </CardHeader>
);


============================================================
FILE_PATH: src\features\auth\components\LoginForm.tsx
============================================================
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Loader2 } from "lucide-react";

export const LoginForm = ({
  email,
  setEmail,
  password,
  setPassword,
  onSubmit,
  isLoading,
  isSignUp,
}: {
  email: string;
  setEmail: (value: string) => void;
  password: string;
  setPassword: (value: string) => void;
  onSubmit: (e: React.FormEvent) => Promise<void>;
  isLoading: boolean;
  isSignUp?: boolean;
}) => (
  <form onSubmit={onSubmit} className="space-y-4">
    <div className="space-y-2">
      <Label htmlFor="email">Email</Label>
      <Input
        id="email"
        type="email"
        placeholder="nombre@ejemplo.com"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        required
        disabled={isLoading}
      />
    </div>
    <div className="space-y-2">
      <Label htmlFor="password">Contrase√±a</Label>
      <Input
        id="password"
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        required
        disabled={isLoading}
      />
    </div>

    <Button className="w-full" type="submit" disabled={isLoading}>
      {isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
      {isSignUp ? "Crear cuenta" : "Iniciar sesi√≥n"}
    </Button>
  </form>
);


============================================================
FILE_PATH: src\features\auth\hooks\useAuth.ts
============================================================
import { useRouter } from "next/navigation";
import { useState } from "react";
import { toast } from "sonner";
import { systemSupabase } from "@/lib/supabase/client";

export const useAuth = () => {
  const router = useRouter();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [isSignUp, setIsSignUp] = useState(false);

  const handleAuth = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);

    try {
      if (isSignUp) {
        const { error } = await systemSupabase.auth.signUp({
          email,
          password,
          options: {
            emailRedirectTo: `${location.origin}/auth/callback`,
          },
        });
        if (error) throw error;
        toast.success("¬°Cuenta creada con √©xito!", {
          description: "Por favor, revisa tu email para confirmar tu cuenta.",
          duration: 5000, // Dura un poco m√°s para que lean
        });
      } else {
        const { error } = await systemSupabase.auth.signInWithPassword({
          email,
          password,
        });

        if (error) throw error;
        toast.success("¬°Bienvenido de nuevo!", {
          description: "Iniciando sesi√≥n...",
        });
        router.push("/gallery");
        router.refresh();
      }
    } catch (err: any) {
      /*  console.error(err); */
      toast.error("Ocurri√≥ un error", {
        description: err.message || "No se pudo completar la solicitud.",
      });
    } finally {
      setIsLoading(false);
    }
  };

  return {
    isSignUp,
    password,
    setPassword,
    setEmail,
    email,
    isLoading,
    setIsLoading,
    setIsSignUp,
    onSubmit: handleAuth,
  };
};


============================================================
FILE_PATH: src\features\dashboard\index.tsx
============================================================
export { useDashboard } from "./hooks/useDashboard";
export { DashboardHeader } from "./components/DashboardHeader";
export { LoadingIndicator } from "./components/LoadingIndicator";
export { DashboardSidebar } from "./components/sidebar";


============================================================
FILE_PATH: src\features\dashboard\components\DashboardHeader.tsx
============================================================
import { SidebarTrigger } from "@/components/ui/sidebar";
import { Button } from "@/components/ui/button";
import { Label } from "@radix-ui/react-label";
import { Switch } from "@radix-ui/react-switch";
import { Globe, Lock, ExternalLink, Settings } from "lucide-react";
import { DashboardHeaderProps } from "../types/dashboard.types";

export const DashboardHeader = ({
  currentPage,
  onPublicToggle,
  onOpenView,
  onSettings,
}: DashboardHeaderProps) => {
  return (
    <div className="grid w-full grid-cols-[auto_1fr_auto] items-center p-2">
      <SidebarTrigger classNameIcon="size-6" className="p-5" />
      <div />
      <div className="flex items-center gap-4 px-2">
        {currentPage && (
          <div className="flex items-center gap-2 border-r pr-4 mr-2">
            <div className="flex items-center space-x-2">
              <Switch
                id="public-mode"
                checked={currentPage.isPublic || false}
                onCheckedChange={onPublicToggle}
                aria-label={currentPage.isPublic ? "P√∫blico" : "Privado"}
              />
              <Label
                htmlFor="public-mode"
                className="flex items-center gap-1 text-xs cursor-pointer select-none text-muted-foreground"
              >
                {currentPage.isPublic ? (
                  <Globe className="size-3" />
                ) : (
                  <Lock className="size-3" />
                )}
                {currentPage.isPublic ? "P√∫blico" : "Privado"}
              </Label>
            </div>
          </div>
        )}
        {currentPage && (
          <>
            <Button
              variant="ghost"
              size="icon"
              onClick={onOpenView}
              title="Abrir vista previa"
              aria-label="Abrir vista previa en nueva pesta√±a"
            >
              <ExternalLink className="size-5" />
            </Button>
            <Button
              variant="ghost"
              size="icon"
              onClick={onSettings}
              title="Configurar Scripts"
              aria-label="Configurar scripts de la p√°gina"
            >
              <Settings className="size-6" />
            </Button>
          </>
        )}
      </div>
    </div>
  );
};


============================================================
FILE_PATH: src\features\dashboard\components\LoadingIndicator.tsx
============================================================
import { LoadingModal } from "@/components/custom/Modals/LoadingModal";

interface LoadingIndicatorProps {
  loadingId: string;
}

export const LoadingIndicator = ({ loadingId }: LoadingIndicatorProps) => {
  return <LoadingModal id={loadingId} title="Cargando Dashboard" />;
};


============================================================
FILE_PATH: src\features\dashboard\components\sidebar\DashboardSidebar.tsx
============================================================
// components/custom/DashboardSidebar/DashboardSidebar.tsx
import {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
} from "@/components/ui/sidebar";
import { Button } from "@/components/ui/button";
import { LayoutDashboard, Plus, Settings } from "lucide-react";
import Link from "next/link";
import { useDashboardSidebar } from "./useDashboardSidebar";
import { SidebarPages } from "./SidebarPages";
import { DashboardSidebarModals } from "./DashboardSidebarModals";

export function DashboardSidebar() {
  const {
    status,
    pages,
    pageId,
    dashboardId,
    addPageId,
    editPageId,
    confirmDeleteId,
    confirmConnectionId,
    onAdd,
    onConfirmAdd,
    onDelete,
    onConfirmDelete,
    onEdit,
    onConfirmEdit,
    onSettings,
  } = useDashboardSidebar();

  return (
    <>
      <Sidebar className="select-none">
        <SidebarHeader>
          <Button asChild variant="outline" className="justify-center px-2">
            <Link href="/gallery" className="w-full flex items-center gap-2">
              <LayoutDashboard className="size-5" />
              <span>Gallery</span>
            </Link>
          </Button>
        </SidebarHeader>

        <SidebarContent>
          <SidebarGroup>
            <SidebarGroupLabel className="text-lg h-10">
              Pages
            </SidebarGroupLabel>
            <SidebarGroupAction
              title="Add Page"
              className="size-8"
              onClick={onAdd}
            >
              <Plus className="size-4" />
              <span className="sr-only">Add Page</span>
            </SidebarGroupAction>
            <SidebarGroupContent>
              <SidebarPages
                pages={pages}
                status={status}
                pageId={pageId}
                dashboardId={dashboardId}
                onEdit={onEdit}
                onDelete={onDelete}
              />
            </SidebarGroupContent>
          </SidebarGroup>
        </SidebarContent>

        <SidebarFooter>
          <Button
            asChild
            variant="ghost"
            onClick={onSettings}
            className="w-full justify-start cursor-pointer px-2"
          >
            <div className="flex items-center gap-2">
              <Settings className="size-5" />
              <span>Settings</span>
            </div>
          </Button>
        </SidebarFooter>
      </Sidebar>

      <DashboardSidebarModals
        addPageId={addPageId}
        editPageId={editPageId}
        confirmDeleteId={confirmDeleteId}
        confirmConnectionId={confirmConnectionId}
        onConfirmAdd={onConfirmAdd}
        onConfirmEdit={onConfirmEdit}
        onConfirmDelete={onConfirmDelete}
      />
    </>
  );
}


============================================================
FILE_PATH: src\features\dashboard\components\sidebar\DashboardSidebarModals.tsx
============================================================
// components/custom/DashboardSidebar/DashboardSidebarModals.tsx
import { FormModal } from "@/components/custom/Modals/FormModal";
import { ConfirmModal } from "@/components/custom/Modals/ConfirmModal";
import { ConfigConnectionModal } from "@/components/custom/Modals/ConfigConnectionModal";
import { FieldConfig } from "@/components/custom/DynamicForm";
import z from "zod";

const schema = z.object({
  name: z.string().min(4),
});

const fields: FieldConfig[] = [{ name: "name", label: "Nombre", type: "text" }];

interface DashboardSidebarModalsProps {
  addPageId: string;
  editPageId: string;
  confirmDeleteId: string;
  confirmConnectionId: string;
  onConfirmAdd: (data: Record<string, any>) => void;
  onConfirmEdit: (data: Record<string, string>) => void;
  onConfirmDelete: () => void;
}

export const DashboardSidebarModals: React.FC<DashboardSidebarModalsProps> = ({
  addPageId,
  editPageId,
  confirmDeleteId,
  confirmConnectionId,
  onConfirmAdd,
  onConfirmEdit,
  onConfirmDelete,
}) => {
  return (
    <>
      <FormModal
        className="gap-1"
        schema={schema}
        fields={fields}
        id={addPageId}
        title="Add Page"
        onSubmit={onConfirmAdd}
      />
      <FormModal
        className="gap-1"
        schema={schema}
        fields={fields}
        id={editPageId}
        title="Edit Page"
        onSubmit={onConfirmEdit}
      />
      <ConfirmModal
        onConfirm={onConfirmDelete}
        id={confirmDeleteId}
        description="Are you sure you want to delete this page?"
        title="Confirm Delete"
      />
      <ConfigConnectionModal
        id={confirmConnectionId}
        title="Config Connection"
        description="Set connection configuration"
      />
    </>
  );
};


============================================================
FILE_PATH: src\features\dashboard\components\sidebar\index.tsx
============================================================
export { DashboardSidebar } from "./DashboardSidebar";


============================================================
FILE_PATH: src\features\dashboard\components\sidebar\SidebarPages.tsx
============================================================
// components/custom/DashboardSidebar/SidebarPages.tsx
import { SidebarMenu, SidebarMenuItem } from "@/components/ui/sidebar";
import {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
} from "@/components/ui/dropdown-menu";
import { SidebarMenuButton, SidebarMenuAction } from "@/components/ui/sidebar";
import { DynamicIcon, IconName } from "@/components/custom/DynamicIcon";
import { MoreHorizontal, Pencil, Trash2 } from "lucide-react";
import Link from "next/link";

interface SidebarPagesProps {
  pages: any[];
  status: string;
  pageId: string | undefined;
  dashboardId: string;
  onEdit: (data: { id: string; name: string }) => void;
  onDelete: (data: { id: string }) => void;
}

export const SidebarPages: React.FC<SidebarPagesProps> = ({
  pages,
  status,
  pageId,
  dashboardId,
  onEdit,
  onDelete,
}) => {
  if (status === "loading") {
    return (
      <>
        {Array.from({ length: 3 }).map((_, i) => (
          <SidebarMenuItem key={i} className="px-2 py-2"></SidebarMenuItem>
        ))}
      </>
    );
  }

  return (
    <SidebarMenu>
      {pages?.map((item) => {
        const isActive = item.id === pageId;
        const href = `/dashboard/${dashboardId}/page/${item.id}`;

        return (
          <SidebarMenuItem key={item.id}>
            <SidebarMenuButton
              asChild
              isActive={isActive}
              className="select-none"
              tooltip={item.name}
            >
              <Link href={href}>
                <DynamicIcon name={item.icon as IconName} />
                <span className="truncate">{item.name}</span>
              </Link>
            </SidebarMenuButton>

            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <SidebarMenuAction showOnHover>
                  <MoreHorizontal />
                  <span className="sr-only">More</span>
                </SidebarMenuAction>
              </DropdownMenuTrigger>
              <DropdownMenuContent
                className="w-48 rounded-lg"
                side="right"
                align="start"
              >
                <DropdownMenuItem
                  onClick={() => onEdit({ id: item.id, name: item.name })}
                  className="cursor-pointer"
                >
                  <Pencil className="text-muted-foreground size-4 mr-2" />
                  <span>Rename Page</span>
                </DropdownMenuItem>
                <DropdownMenuItem
                  onClick={() => onDelete({ id: item.id })}
                  className="cursor-pointer text-destructive focus:text-destructive"
                >
                  <Trash2 className="size-4 mr-2" />
                  <span>Delete Page</span>
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </SidebarMenuItem>
        );
      })}
    </SidebarMenu>
  );
};


============================================================
FILE_PATH: src\features\dashboard\components\sidebar\useDashboardSidebar.tsx
============================================================
// hooks/useDashboardSidebar.ts
import { useCallback, useEffect, useId } from "react";
import { useAppDispatch, useAppSelector } from "@/lib/redux/hooks";
import { fetchPages } from "@/lib/redux/features/pageSlice";
import { useParams, useRouter } from "next/navigation";
import { useModals } from "@/providers/ModalProvider";
import { usePages } from "@/hooks/usePages";

export const useDashboardSidebar = () => {
  const dispatch = useAppDispatch();
  const status = useAppSelector((state) => state.pages.status);
  const router = useRouter();

  const params = useParams();
  const dashboardId = params.dashboardId as string;
  const pageId = params.pageId as string | undefined;

  const { pages, addPage, renamePage, deletePage } = usePages(dashboardId);
  const { openModal, closeModal, getModalData } = useModals();

  // IDs estables
  const addPageId = useId();
  const editPageId = useId();
  const confirmDeleteId = useId();
  const confirmConnectionId = useId();

  // 1. Efectos
  useEffect(() => {
    if (!dashboardId) {
      router.replace("/gallery");
    }
  }, [dashboardId, router]);

  useEffect(() => {
    if (status === "idle") {
      dispatch(fetchPages());
    }
  }, [status, dispatch]);

  // 2. Handlers Memoizados (Optimizacion)
  const onAdd = useCallback(() => {
    openModal(addPageId);
  }, [openModal, addPageId]);

  const onConfirmAdd = useCallback(
    (data: Record<string, any>) => {
      addPage(data.name, "LayoutDashboard");
      closeModal(addPageId);
    },
    [addPage, closeModal, addPageId]
  );

  const onDelete = useCallback(
    (data: Record<string, any>) => {
      openModal(confirmDeleteId, data);
    },
    [openModal, confirmDeleteId]
  );

  const onConfirmDelete = useCallback(() => {
    const data = getModalData(confirmDeleteId);
    if (data?.id) {
      deletePage(data.id);
      router.replace(`/dashboard/${dashboardId}`);
    }
  }, [getModalData, confirmDeleteId, deletePage, router, dashboardId]);

  const onEdit = useCallback(
    (data: Record<string, any>) => {
      openModal(editPageId, data);
    },
    [openModal, editPageId]
  );

  const onConfirmEdit = useCallback(
    (newData: Record<string, string>) => {
      const data = getModalData(editPageId);
      if (data?.id) {
        renamePage(data.id, newData.name);
        closeModal(editPageId);
      }
    },
    [getModalData, editPageId, renamePage, closeModal]
  );

  const onSettings = useCallback(() => {
    openModal(confirmConnectionId);
  }, [openModal, confirmConnectionId]);

  return {
    status,
    pages,
    pageId,
    dashboardId,
    addPageId,
    editPageId,
    confirmDeleteId,
    confirmConnectionId,
    onAdd,
    onConfirmAdd,
    onDelete,
    onConfirmDelete,
    onEdit,
    onConfirmEdit,
    onSettings,
  };
};


============================================================
FILE_PATH: src\features\dashboard\hooks\useDashboard.ts
============================================================
import { useEffect, useId, useRef, useCallback } from "react";
import { useParams } from "next/navigation";
import { toast } from "sonner";

// Stores y Hooks
import { useDashboardStore } from "@/features/dashboard/store/useDashboardStore";
import { usePageStore } from "@/features/page/store/usePageStore"; // Aseg√∫rate que la ruta sea correcta
import { useModals } from "@/providers/ModalProvider";
import { useScriptConnectionActions } from "@/hooks/useScriptConnectionActions";

// Tipos
import { DatabaseConfig } from "../types/dashboard.types";

export const useDashboard = () => {
  const params = useParams();
  const dashboardId = params?.dashboardId as string;
  const pageId = params?.pageId as string | undefined;

  const {
    dashboard: currentDashboard,
    status: dashboardStatus,
    refresh: fetchDashboards,
  } = useDashboardStore(dashboardId);

  const {
    status: pagesStatus,
    page: currentPage,
    updateSettings,
  } = usePageStore(pageId);

  // --- UTILS & REFS ---
  const { openModal, closeModal } = useModals();
  const { ConectionConfig } = useScriptConnectionActions();

  const loadingId = useId();
  const isModalOpenRef = useRef(false);
  const hasConnectedRef = useRef(false);

  // 1. Efecto: Cargar datos iniciales si el store est√° "idle"
  useEffect(() => {
    if (dashboardStatus === "idle") {
      fetchDashboards();
    }
  }, [dashboardStatus, fetchDashboards]);

  // 2. Efecto: Conectar a la base de datos cuando el dashboard carga
  useEffect(() => {
    const connectDatabase = async () => {
      // Validamos que exista dashboard, configuraci√≥n y que no hayamos conectado ya
      if (
        currentDashboard?.config &&
        currentDashboard.config.type &&
        !hasConnectedRef.current
      ) {
        try {
          hasConnectedRef.current = true;
          await ConectionConfig(currentDashboard.config as DatabaseConfig);

          toast.success("Base de datos conectada", {
            description: `Proveedor: ${currentDashboard.config.type}`,
            duration: 3000,
          });
        } catch (error) {
          console.error("Connection error:", error);
          toast.error("Error de conexi√≥n", {
            description: "No se pudo conectar a la base de datos configurada.",
          });
          // Permitimos reintentar si falla
          hasConnectedRef.current = false;
        }
      }
    };

    if (dashboardStatus === "succeeded") {
      connectDatabase();
    }
  }, [currentDashboard, dashboardStatus, ConectionConfig]);

  // 3. Efecto: Manejar el modal de carga (Loading Overlay)
  useEffect(() => {
    const isLoading = dashboardStatus === "loading";

    if (isLoading && !isModalOpenRef.current) {
      openModal(loadingId, {
        message: "Sincronizando...",
        subMessage: "Obteniendo configuraci√≥n y p√°ginas",
      });
      isModalOpenRef.current = true;
    } else if (!isLoading && isModalOpenRef.current) {
      // Peque√±o delay para evitar parpadeos r√°pidos
      const timer = setTimeout(() => {
        closeModal(loadingId);
        isModalOpenRef.current = false;
      }, 300);
      return () => clearTimeout(timer);
    }
  }, [pagesStatus, dashboardStatus, openModal, closeModal, loadingId]);

  // --- HANDLERS ---

  const handlePublicToggle = useCallback(
    async (checked: boolean) => {
      if (!currentPage || !updateSettings) return;

      try {
        await updateSettings({
          isPublic: checked,
        });

        toast.success(`P√°gina ahora es ${checked ? "P√∫blica" : "Privada"}`, {
          description: checked
            ? "Cualquiera con el enlace podr√° verla."
            : "Solo t√∫ puedes ver esta p√°gina.",
        });
      } catch (error) {
        toast.error("Error al actualizar privacidad");
        console.error("Toggle error:", error);
      }
    },
    [currentPage, updateSettings]
  );

  const handleOpenView = useCallback(() => {
    if (!currentPage) return;
    window.open(`/view/${currentPage.id}`, "_blank");
  }, [currentPage]);

  const handleOpenSettings = useCallback(() => {
    // Aseg√∫rate que este ID coincida con el registrado en tu ModalProvider
    openModal("213123123_editor_modal");
  }, [openModal]);

  return {
    loadingId,
    currentPage,
    currentDashboard, // √ötil devolverlo por si el componente lo necesita
    isLoading: dashboardStatus === "loading",
    handlePublicToggle,
    handleOpenView,
    handleOpenSettings,
  };
};


============================================================
FILE_PATH: src\features\dashboard\store\useDashboardStore.ts
============================================================
// useDashboardStore.ts
import { useMemo, useCallback } from "react";
import { useParams } from "next/navigation";
import { useUser } from "@/hooks/useUser";
import { Dashboard } from "@/types/types";
import { useStore } from "./useStore";

export const useDashboardStore = (id?: string) => {
  const { user } = useUser();
  const params = useParams();

  // Prioridad: ID pasado por prop > ID de la URL > undefined
  const dashboardId = id || (params?.dashboardId as string);

  // Selectores del Store (Zustand)
  const dashboardsMap = useStore((s) => s.dashboards);
  const status = useStore((s) => s.status);
  const error = useStore((s) => s.error);

  // Acciones del Store
  const addDashboardAction = useStore((s) => s.addDashboard);
  const deleteDashboardAction = useStore((s) => s.deleteDashboard);
  const updateDashboardAction = useStore((s) => s.updateDashboard);
  const fetchDashboardsAction = useStore((s) => s.fetchDashboards);

  // Datos Computados
  const dashboards = useMemo(
    () => Object.values(dashboardsMap),
    [dashboardsMap]
  );

  const currentDashboard = useMemo(
    () => (dashboardId ? dashboardsMap[dashboardId] : undefined),
    [dashboardsMap, dashboardId]
  );

  // --- Helpers internos ---

  // Validar si podemos editar (requiere dashboardId)
  const requireDashboardId = useCallback(() => {
    if (!dashboardId) {
      console.error("Operaci√≥n fallida: No hay un dashboard seleccionado.");
      return false;
    }
    return true;
  }, [dashboardId]);

  return {
    // --- Estado ---
    status,
    error,
    isLoading: status === "idle" || status === "loading",
    dashboards, // Lista completa
    dashboard: currentDashboard, // Dashboard actual (si existe ID)

    // --- Acciones de Ciclo de Vida ---
    refresh: fetchDashboardsAction,

    // --- Acciones CRUD B√°sicas ---

    addDashboard: async (name: string, userId: string) => {
      if (!user) {
        console.warn("Intento de crear Dashboard sin usuario autenticado");
        return;
      }
      await addDashboardAction(name, userId);
    },

    deleteDashboard: (targetId: string) => deleteDashboardAction(targetId),

    // Actualizaci√≥n gen√©rica (para cualquier propiedad)
    updateDashboard: async (targetId: string, updates: Partial<Dashboard>) => {
      await updateDashboardAction(targetId, updates);
    },

    renameDashboard: (targetId: string, name: string) =>
      updateDashboardAction(targetId, { name }),

    // --- Acciones de Configuraci√≥n (Espec√≠ficas del Dashboard Actual) ---

    setConfig: (config: Record<string, any>) => {
      if (requireDashboardId()) {
        updateDashboardAction(dashboardId, { config });
      }
    },

    setConfigScript: (script: string) => {
      if (requireDashboardId()) {
        updateDashboardAction(dashboardId, { configScript: script });
      }
    },

    getConfigScript: () => {
      return currentDashboard?.configScript || "";
    },

    // --- Acciones de Gesti√≥n de P√°ginas (pageIds) ---
    // Estas son cr√≠ticas para evitar l√≥gica compleja en tus componentes

    addPageId: async (pageId: string) => {
      if (!requireDashboardId() || !currentDashboard) return;

      // Evitar duplicados
      if (currentDashboard.pageIds.includes(pageId)) return;

      const newPageIds = [...currentDashboard.pageIds, pageId];
      await updateDashboardAction(dashboardId, { pageIds: newPageIds });
    },

    removePageId: async (pageId: string) => {
      if (!requireDashboardId() || !currentDashboard) return;

      const newPageIds = currentDashboard.pageIds.filter((id) => id !== pageId);
      await updateDashboardAction(dashboardId, { pageIds: newPageIds });
    },

    reorderPages: async (newPageIds: string[]) => {
      if (!requireDashboardId()) return;
      // Validar que no estemos perdiendo datos accidentalmente (opcional pero recomendado)
      // Aqu√≠ simplemente confiamos en el array que nos pasan
      await updateDashboardAction(dashboardId, { pageIds: newPageIds });
    },
  };
};


============================================================
FILE_PATH: src\features\dashboard\store\useStore.ts
============================================================
import { create } from "zustand";
import { systemSupabase } from "@/lib/supabase/client"; // Tu cliente existente
import { Dashboard } from "@/types/types"; // Aseg√∫rate de tener este tipo

interface DashboardState {
  dashboards: Record<string, Dashboard>; // Mapa por ID para acceso r√°pido (byId)
  status: "idle" | "loading" | "succeeded" | "failed";
  error: string | null;

  // Acciones
  fetchDashboards: () => Promise<void>;
  getDashboardById: (id: string) => Dashboard | undefined;
  addDashboard: (name: string, userId: string) => Promise<void>;
  deleteDashboard: (id: string) => Promise<void>;
  renameDashboard: (id: string, newName: string) => Promise<void>;
  updateDashboard: (id: string, updates: Partial<Dashboard>) => Promise<void>;
}

export const useStore = create<DashboardState>((set, get) => ({
  dashboards: {},
  status: "idle",
  error: null,

  fetchDashboards: async () => {
    set({ status: "loading" });
    try {
      const { data, error } = await systemSupabase
        .from("dashboards")
        .select("*");
      if (error) throw error;

      // Normalizamos array a objeto { [id]: data }
      const dashboardMap = (data || []).reduce((acc, curr) => {
        acc[curr.id] = curr;
        return acc;
      }, {} as Record<string, Dashboard>);

      set({ dashboards: dashboardMap, status: "succeeded" });
    } catch (err: any) {
      set({ status: "failed", error: err.message });
    }
  },

  getDashboardById: (id) => get().dashboards[id],

  addDashboard: async (name, userId) => {
    /*     const newDashboard: Dashboard = {
      id: newId,
      name,
      pageIds: [],
      config: {},
      configScript: "",
    }; */
    const { data, error } = await systemSupabase
      .from("dashboards")
      .insert({
        name,
        user_id: userId,
        config: {},
        config_script: "",
      })
      .select()
      .single();
    if (error) throw error;

    set((state) => ({
      dashboards: { ...state.dashboards, [data.id]: data },
    }));
  },

  deleteDashboard: async (id) => {
    set((state) => {
      const newDashboards = { ...state.dashboards };
      delete newDashboards[id];
      return { dashboards: newDashboards };
    });
    await systemSupabase.from("dashboards").delete().eq("id", id);
  },

  renameDashboard: async (id, name) => {
    // 1. Optimista
    set((state) => ({
      dashboards: {
        ...state.dashboards,
        [id]: { ...state.dashboards[id], name },
      },
    }));

    // 2. Persistir
    await systemSupabase.from("dashboards").update({ name }).eq("id", id);
  },
  updateDashboard: async (id, updates) => {
    // 1. Optimista
    set((state) => ({
      dashboards: {
        ...state.dashboards,
        [id]: { ...state.dashboards[id], ...updates },
      },
    }));

    // 2. Persistir en Supabase
    const { error } = await systemSupabase
      .from("dashboards")
      .update(updates)
      .eq("id", id);

    if (error) {
      console.error("Error updating dashboard:", error);
      // Opcional: Revertir estado si falla
    }
  },
}));


============================================================
FILE_PATH: src\features\dashboard\types\dashboard.types.ts
============================================================
export interface DatabaseConfig {
  type: string;
  url: string;
  key: string;
}

export interface LoadingState {
  pages: "idle" | "loading" | "succeeded" | "failed";
  dashboards: "idle" | "loading" | "succeeded" | "failed";
}

export interface DashboardHeaderProps {
  currentPage?: {
    id: string;
    isPublic?: boolean;
  } | null;
  onPublicToggle: (checked: boolean) => void;
  onOpenView: () => void;
  onSettings: () => void;
}

export interface ConnectionState {
  hasConnected: boolean;
  isModalOpen: boolean;
}


============================================================
FILE_PATH: src\features\editor\hooks\useCodeDefinitions.ts
============================================================
import { useMemo } from "react";
import { TypeBuilder } from "@/lib/monaco/TypeBuilder";
import { ActionsTypes } from "@/hooks/useScriptActions";
import {
  ComponentEventsTypes,
  ComponentsTypes,
} from "@/lib/ComponentBuilders/Builders";
import { ConnectionActionsTypes } from "./useScriptConnectionActions";

export const useCodeDefinitions = ({
  sqlCode,
  contextType = "default",
}: {
  sqlCode?: string;
  contextType?: "default" | "DBConfig";
}) => {
  const definitions = useMemo(() => {
    const defs: any[] = [];

    if (contextType == "DBConfig") {
      const globalBuilder = new TypeBuilder().addCustom(ConnectionActionsTypes);
      defs.push({
        path: "globals.d.ts",
        content: globalBuilder.build(),
      });
      return defs;
    }

    // 1. Core Libs (Siempre presentes)
    const coreBuilder = new TypeBuilder().addCore();
    defs.push({
      path: "core.d.ts",
      content: coreBuilder.build(),
    });

    // 2. Global Libs (Tus acciones, Componentes, etc)
    const globalBuilder = new TypeBuilder()
      .addCustom(ActionsTypes)
      .addCustom(ComponentEventsTypes)
      .addCustom(ComponentsTypes);

    defs.push({
      path: "globals.d.ts",
      content: globalBuilder.build(),
    });

    // 3. SQL Context (Din√°mico)
    if (sqlCode) {
      const sqlBuilder = new TypeBuilder().addSqlQueries(sqlCode);
      defs.push({
        path: "sql-generated.d.ts",
        content: sqlBuilder.build(),
      });
    }

    return defs;
  }, [sqlCode, contextType]);

  return { definitions };
};


============================================================
FILE_PATH: src\features\editor\hooks\useMonacoTypings.ts
============================================================
import { Monaco } from "@monaco-editor/react";
import { useEffect, useRef } from "react";

export interface TypeDefinition {
  /** Nombre del archivo virtual (ej: "libs/console.d.ts") */
  path: string;
  /** Contenido de la definici√≥n (declare const...) */
  content: string;
}

interface UseMonacoTypingsProps {
  /** Array de definiciones a inyectar */
  definitions: TypeDefinition[];
  /** Opciones de compilaci√≥n extra si las necesitas */
  compilerOptions?: any; // monaco.languages.typescript.CompilerOptions
}

export const useMonacoTypings = ({
  definitions,
  compilerOptions,
}: UseMonacoTypingsProps) => {
  const monacoRef = useRef<Monaco | null>(null);

  // Configuramos el compilador una sola vez
  const initCompiler = (monaco: Monaco) => {
    const defaults = monaco.languages.typescript.javascriptDefaults;
    defaults.setCompilerOptions({
      target: monaco.languages.typescript.ScriptTarget.ESNext,
      allowNonTsExtensions: true,
      moduleResolution: monaco.languages.typescript.ModuleResolutionKind.NodeJs,
      allowJs: true,
      checkJs: true,
      noLib: false, // Importante: usaremos nuestras propias libs
      ...compilerOptions,
      strict: false,
      alwaysStrict: false,
      strictNullChecks: false, // Ayuda si TS se queja de posibles 'undefined'
    });
  };

  const updateLibs = () => {
    if (!monacoRef.current) return;
    const defaults = monacoRef.current.languages.typescript.javascriptDefaults;

    // Inyectamos cada definici√≥n como una librer√≠a extra
    definitions.forEach((def) => {
      // "ts:filename/" es un prefijo est√°ndar para que Monaco lo trate como archivo local
      const uri = `ts:filename/${def.path}`;
      // addExtraLib retorna un disposable, pero Monaco maneja actualizaciones
      // autom√°ticamente si la URI es la misma.
      defaults.addExtraLib(def.content, uri);
    });
  };

  const handleEditorDidMount = (editor: any, monaco: Monaco) => {
    monacoRef.current = monaco;
    initCompiler(monaco);
    updateLibs();
  };

  // Actualizar cuando cambien las definiciones (din√°mico)
  useEffect(() => {
    updateLibs();
  }, [definitions]);

  return { handleEditorDidMount };
};


============================================================
FILE_PATH: src\features\editor\hooks\useScriptActions.ts
============================================================
import { useModals } from "@/providers/ModalProvider";
import { Context, createContext } from "@/lib/ComponentBuilders/Component";
import { v4 as uuid } from "uuid";
import { useScriptEditor } from "./useScriptEditor";
import { LogEntry } from "@/lib/runScript/runScript";
import { useScriptConnectionActions } from "./useScriptConnectionActions";
import { z } from "zod";

export const useScriptActions = () => {
  const { openModal, closeModal, getModalData } = useModals();
  const { addExecutionLogs, isEditing } = useScriptEditor();
  const { execQuery } = useScriptConnectionActions();
  const context: Context = createContext();

  const handleOpenModal = (id: string, data: any) => {
    openModal(id, data);
  };

  const handleCloseModal = (id: string) => {
    closeModal(id);
  };

  const handleGetModalData = (id: string) => {
    const data = getModalData(id);
    return data;
  };

  // Funci√≥n auxiliar para transformar funciones en strings legibles
  // y evitar errores de referencia circular
  const serializeWithFunctions = (item: any, seen = new WeakSet()): any => {
    // Si es una funci√≥n, retornamos su representaci√≥n en string
    if (typeof item === "function") {
      return `[Function: ${item.name || "anonymous"}]`;
    }

    // Si es primitivo o null, lo devolvemos tal cual
    if (item === null || typeof item !== "object") {
      return item;
    }

    // Manejo de referencias circulares para evitar crash
    if (seen.has(item)) {
      return "[Circular]";
    }
    seen.add(item);

    // Si es un array, procesamos cada elemento
    if (Array.isArray(item)) {
      return item.map((i) => serializeWithFunctions(i, seen));
    }

    // Si es un objeto, procesamos cada llave
    const result: any = {};
    for (const key in item) {
      if (Object.prototype.hasOwnProperty.call(item, key)) {
        result[key] = serializeWithFunctions(item[key], seen);
      }
    }
    return result;
  };

  const Editor = {
    log: (...args: any) => {
      if (isEditing) {
        const entry: LogEntry = { message: "" };

        // Filtramos los que NO son strings y aplicamos la serializaci√≥n
        // para preservar las funciones dentro de los objetos
        entry.data = args
          .filter((item) => typeof item != "string")
          .map((item) => serializeWithFunctions(item));

        entry.message = args
          .filter((item) => typeof item == "string")
          .join(",");

        addExecutionLogs([entry]);
      } else {
        console.log(...args);
      }
    },
  };

  return {
    execQuery,
    openModal: handleOpenModal,
    closeModal: handleCloseModal,
    getModalData: handleGetModalData,
    uuid,
    Editor,
    context,
    z,
  };
};

export const ActionsTypes = `
// --- Tipos existentes ---
declare function execQuery(query: string, context?: Record<string,any>): Promise<any[]>;
declare function openModal(id:string,data?:any):void;
declare function closeModal(id:string):void;
declare function getModalData(id:string):any;
declare const context: Context;
declare function uuid():string;
declare const Editor: { log:(...args:any[])=> void };

// --- Definici√≥n Simplificada de Zod ---

type ZodSafeParseReturnType<Output> = 
  | { success: true; data: Output } 
  | { success: false; error: { issues: any[]; message: string } };

interface ZodType<Output = any, Input = Output> {
  parse(data: unknown): Output;
  safeParse(data: unknown): ZodSafeParseReturnType<Output>;
  optional(): ZodType<Output | undefined, Input | undefined>;
  nullable(): ZodType<Output | null, Input | null>;
  or<T extends ZodType>(option: T): ZodType<Output | T["_output"], Input | T["_input"]>;
  and<T extends ZodType>(option: T): ZodType<Output & T["_output"], Input & T["_input"]>;
  _output: Output;
  _input: Input;
}

interface ZodString extends ZodType<string> {
  email(message?: string): ZodString;
  min(length: number, message?: string): ZodString;
  max(length: number, message?: string): ZodString;
  url(message?: string): ZodString;
  uuid(message?: string): ZodString;
  regex(regex: RegExp, message?: string): ZodString;
  nonempty:()=>ZodString
}

interface ZodNumber extends ZodType<number> {
  min(value: number, message?: string): ZodNumber;
  max(value: number, message?: string): ZodNumber;
  int(message?: string): ZodNumber;
  positive(message?: string): ZodNumber;
}

interface ZodArray<T extends ZodType> extends ZodType<T["_output"][], T["_input"][]> {
  element: T;
  min(length: number, message?: string): this;
  max(length: number, message?: string): this;
}

interface ZodObject<T extends Record<string, ZodType>> extends ZodType<
  { [K in keyof T]: T[K]["_output"] },
  { [K in keyof T]: T[K]["_input"] }
> {
  shape: T;
  extend<U extends Record<string, ZodType>>(augmentation: U): ZodObject<T & U>;
  pick<K extends keyof T>(mask: Record<K, true>): ZodObject<Pick<T, K>>;
  omit<K extends keyof T>(mask: Record<K, true>): ZodObject<Omit<T, K>>;
  partial(): ZodObject<{ [K in keyof T]: T[K] extends ZodType<infer O, infer I> ? ZodType<O | undefined, I | undefined> : never }>;
}

// Declaraci√≥n del objeto 'z' y sus m√©todos
declare const z: {
  string: (params?: { required_error?: string; invalid_type_error?: string }) => ZodString;
  number: (params?: { required_error?: string; invalid_type_error?: string }) => ZodNumber;
  boolean: (params?: { required_error?: string; invalid_type_error?: string }) => ZodType<boolean>;
  date: () => ZodType<Date>;
  any: () => ZodType<any>;
  unknown: () => ZodType<unknown>;
  null: () => ZodType<null>;
  undefined: () => ZodType<undefined>;
  literal: <T extends string | number | boolean>(value: T) => ZodType<T>;
  union: <T extends [ZodType, ...ZodType[]]>(options: T) => ZodType<T[number]["_output"]>;
  array: <T extends ZodType>(schema: T) => ZodArray<T>;
  object: <T extends Record<string, ZodType>>(shape: T) => ZodObject<T>;
  enum: <U extends string, T extends [U, ...U[]]>(values: T) => ZodType<T[number]>;
  nativeEnum: <T extends EnumLike>(enumObj: T) => ZodType<T[keyof T]>;
  
  // Utilidad para inferencia de tipos dentro del script
  infer: <T extends ZodType>(schema: T) => T["_output"];
};

// Hack para permitir "type MyType = z.infer<typeof schema>"
declare namespace z {
    export type infer<T extends ZodType> = T["_output"];
}

type EnumLike = { [k: string]: string | number; [k: number]: string };
`;


============================================================
FILE_PATH: src\features\editor\hooks\useScriptConnectionActions.ts
============================================================
import { useCallback } from "react";
/* import { useDashboardStore } from "../features/dashboard/hooks/useDashboards"; */
/* import { useAppDispatch } from "@/lib/redux/hooks"; */
import { addExecutionLogs } from "@/lib/redux/features/ScriptEditorSlice";
import { DatabaseAdapter } from "@/features/scriptConnection/lib/types";
import { SupabaseAdapter } from "@/features/scriptConnection/lib/SupabaseAdapter";
import { MockAdapter } from "@/features/scriptConnection/lib/MockAdapter";
import { processSqlTemplate } from "@/lib/runScript/runScript";
import { toast } from "sonner";
/* import { useDBConnection } from "./useDBConnection"; */
import { useDashboardStore } from "@/features/dashboard/store/useDashboardStore";
import { useScriptConnectionStore } from "@/features/scriptConnection/store/useScriptConnectionStore";

// 1. SINGLETON: Variable fuera del hook para compartir la conexi√≥n entre componentes
let activeAdapter: DatabaseAdapter | null = null;

export const useScriptConnectionActions = () => {
  const { setConfig } = useDashboardStore();
  const { setIsConnected } = useScriptConnectionStore();

  /*   const dispatch = useAppDispatch(); */

  // 2. Ejecutar Query (Usa la instancia global)
  const execQuery = useCallback(
    async (query: string, context?: Record<string, any>) => {
      if (!query) return [];
      if (!activeAdapter || !activeAdapter.isConnected()) {
        const errorMsg =
          "No hay una conexi√≥n activa. Verifica la configuraci√≥n.";

        // Notificaci√≥n visual de error
        toast.error("Error de Ejecuci√≥n", {
          description: errorMsg,
        });

        return [];
      }

      const processedQuery = context
        ? processSqlTemplate(query, context)
        : query;

      const start = performance.now();
      const result = await activeAdapter.execute(processedQuery);
      const end = performance.now();
      /* 
      dispatch(
        addExecutionLogs({
          logs: [
            {
              message: `Query Executed (${(end - start).toFixed(2)}ms)`,
              data: [
                processedQuery,
                result.message || `Rows: ${result.data?.length}`,
              ],
            },
          ],
        })
      );
 */
      if (result.error) {
        throw new Error(result.error);
      }

      return result.data || [];
    },
    [dispatch]
  );

  // 3. Conectar (Actualiza la instancia global)
  const ConectionConfig = useCallback(
    async (
      config: { url: string; key: string; type: string },
      shouldSave: boolean = true
    ) => {
      try {
        // Desconectar anterior si existe
        if (activeAdapter) {
          await activeAdapter.disconnect();
          setIsConnected(false);

          activeAdapter = null;
        }

        // Factory de adaptadores
        let newAdapter: DatabaseAdapter;
        switch (config.type?.toLowerCase()) {
          case "supabase":
            newAdapter = new SupabaseAdapter();
            break;
          case "mock":
            newAdapter = new MockAdapter();
            break;
          default:
            // Si no hay tipo, no lanzamos error cr√≠tico, solo no conectamos
            if (!config.type) return;
            throw new Error(
              `Tipo de base de datos no soportado: ${config.type}`
            );
        }

        // Conectar
        await newAdapter.connect(config);
        activeAdapter = newAdapter; // Guardar en variable global

        // Actualizar Redux
        if (shouldSave) {
          setConfig(config);
        }
        setIsConnected(true);
        /* 
        dispatch(
          addExecutionLogs({
            logs: [{ message: `System: Connected to ${newAdapter.name}` }],
          })
        ); */

        return true; // Retornamos true para saber que tuvo √©xito
      } catch (error: any) {
        /*         dispatch(
          addExecutionLogs({
            logs: [
              { message: "System: Connection Error", data: [error.message] },
            ],
          })
        ); */
        throw error;
      }
    },
    [dispatch, setConfig]
  );

  return {
    execQuery,
    ConectionConfig,
  };
};

export const ConnectionActionsTypes = `
declare function execQuery(query: string,context?:Record<string,any>): Promise<any[]>;
declare function ConectionConfig(config: { url: string, key: string, type: "supabase" | "mock" }): Promise<void>;
`;


============================================================
FILE_PATH: src\features\editor\hooks\useScriptEditor.ts
============================================================
import {
  addExecutionLogs,
  clearConsole,
  setIsEditing,
  setJsCode,
  setSqlCode,
} from "@/lib/redux/features/ScriptEditorSlice";
import { useAppDispatch, useAppSelector } from "@/lib/redux/hooks";
import { LogEntry } from "@/lib/runScript/runScript";
import { useCallback } from "react";

export const useScriptEditor = () => {
  const { jsCode, sqlCode, logs, isEditing } = useAppSelector(
    (state) => state.scriptEditor
  );
  const dispatch = useAppDispatch();

  const handleClearConsole = useCallback(() => {
    dispatch(clearConsole());
  }, [dispatch]);

  const handleSetJsCode = useCallback(
    (script: string) => {
      dispatch(setJsCode(script));
    },
    [dispatch]
  );

  const handleSetSqlCode = useCallback(
    (script: string) => {
      dispatch(setSqlCode(script));
    },
    [dispatch]
  );

  const handleAddExecutionLogs = useCallback(
    (logs: LogEntry[], result?: any) => {
      dispatch(addExecutionLogs({ logs, result }));
    },
    [dispatch]
  );
  const handleSetIsEditing = useCallback(
    (isEditing: boolean) => {
      dispatch(setIsEditing(isEditing));
    },
    [dispatch]
  );

  return {
    clearConsole: handleClearConsole,
    setJsCode: handleSetJsCode,
    setSqlCode: handleSetSqlCode,
    addExecutionLogs: handleAddExecutionLogs,
    setIsEditing: handleSetIsEditing,
    sqlCode,
    jsCode,
    logs,
    isEditing,
  };
};


============================================================
FILE_PATH: src\features\editor\hooks\useScriptError.ts
============================================================
import { useCallback } from "react";
import { useScriptEditor } from "../features/editor/hooks/useScriptEditor";
import { toast } from "sonner";

interface ErrorOptions {
  customMessage?: string;
  silent?: boolean; // Para no mostrar toast si falla
  rethrow?: boolean; // Por si quieres que el error siga subiendo
}

export const useScriptError = () => {
  const { addExecutionLogs, isEditing } = useScriptEditor();

  const execute = useCallback(
    async <T>(
      callback?: (...args: any) => Promise<T> | T,
      ...props: any[]
    ): Promise<T | undefined> => {
      if (!callback) return undefined;
      try {
        return await callback(...props);
      } catch (error: unknown) {
        // 1. Extraer el mensaje real del error
        const errorMessage =
          error instanceof Error ? error.message : String(error);
        const errorStack = error instanceof Error ? error.stack : undefined;

        if (isEditing) {
          // 2. Logging detallado para el editor
          addExecutionLogs([
            {
              message: "RUNTIME ERROR",
              // Guardamos objeto estructurado para mejor visualizaci√≥n en logs
              data: [
                {
                  message: errorMessage,
                  stack: errorStack,
                  original: error,
                },
              ],
            },
          ]);
        } else {
          // 3. Manejo en producci√≥n
          console.error("Script Error:", error);

          toast.error("Se produjo un error", {
            description: errorMessage, // Opcional: mostrar el detalle t√©cnico al usuario
          });
        }

        return undefined;
      }
    },
    [isEditing, addExecutionLogs]
  );

  return execute;
};


============================================================
FILE_PATH: src\features\editor\store\useEditorStore.ts
============================================================
// useScriptEditor.ts
import { useCallback } from "react";
import { useStore } from "./useStore";
import { useDashboardStore } from "@/features/dashboard/store/useDashboardStore";

export const useEditorStore = () => {
  // 1. Consumimos el estado del Editor (Zustand)
  const jsCode = useStore((s) => s.jsCode);
  const sqlCode = useStore((s) => s.sqlCode);
  const logs = useStore((s) => s.logs);
  const isEditing = useStore;
  // Acciones del Editor
  const setJsCode = useStore((s) => s.setJsCode);
  const setSqlCode = useStore((s) => s.setSqlCode);
  const clearConsole = useStore((s) => s.clearConsole);
  const addExecutionLogs = useStore((s) => s.addExecutionLogs);
  const setIsEditing = useStore((s) => s.setIsEditing);
  const resetEditor = useStore((s) => s.resetEditor);

  const {
    dashboard,
    setConfigScript,
    isLoading: isDashboardLoading,
  } = useDashboardStore();

  const loadScriptFromDashboard = useCallback(() => {
    if (dashboard?.configScript) {
      setJsCode(dashboard.configScript);
    }
  }, [dashboard, setJsCode]);

  const saveScriptToDashboard = useCallback(async () => {
    if (!dashboard) return;

    setConfigScript(jsCode);
    console.log("Script guardado en el dashboard:", dashboard.id);
  }, [dashboard, jsCode, setConfigScript]);

  return {
    // Estado
    jsCode,
    sqlCode,
    logs,
    isEditing,

    // Estado derivado
    hasUnsavedChanges: dashboard?.configScript !== jsCode,
    isReady: !isDashboardLoading && !!dashboard,

    // Acciones b√°sicas
    setJsCode,
    setSqlCode,
    clearConsole,
    addExecutionLogs,
    setIsEditing,
    resetEditor,

    // Acciones de Integraci√≥n
    loadScriptFromDashboard,
    saveScriptToDashboard,
  };
};


============================================================
FILE_PATH: src\features\editor\store\useStore.ts
============================================================
// useEditorStore.ts
import { create } from "zustand";

export interface LogEntry {
  message: string;
  data?: any;
  step?: string; // Agregado para consistencia con tu l√≥gica anterior
}

interface EditorState {
  // --- Estado ---
  sqlCode: string;
  jsCode: string;
  logs: LogEntry[];
  isEditing: boolean;

  // --- Acciones ---
  setJsCode: (code: string) => void;
  setSqlCode: (code: string) => void;
  clearConsole: () => void;
  setIsEditing: (isEditing: boolean) => void;

  // L√≥gica compleja migrada del reducer
  addExecutionLogs: (logs: LogEntry[], result?: any) => void;

  // Reset completo (√∫til al cambiar de dashboard)
  resetEditor: () => void;
}

const initialState = {
  sqlCode: "",
  jsCode: "",
  logs: [],
  isEditing: false,
};

export const useStore = create<EditorState>((set) => ({
  ...initialState,

  setJsCode: (code) => set({ jsCode: code }),

  setSqlCode: (code) => set({ sqlCode: code }),

  clearConsole: () => set({ logs: [] }),

  setIsEditing: (isEditing) => set({ isEditing }),

  addExecutionLogs: (logs, result) =>
    set((state) => {
      // 1. Logs internos del script (mapeo inmutable)
      const newLogs = logs.map((l) => ({ step: "JS", ...l }));

      // Creamos un nuevo array con los logs existentes + nuevos
      const updatedLogs = [...state.logs, ...newLogs];

      // 2. Log del return final
      if (result !== undefined) {
        updatedLogs.push({
          message: "Script finalizado. Return:",
          data: result,
        });
      }

      return { logs: updatedLogs };
    }),

  resetEditor: () => set(initialState),
}));


============================================================
FILE_PATH: src\features\engine\execQuery.ts
============================================================
import { useScriptConnectionStore } from "@/features/scriptConnection/store/useScriptConnectionStore";
import { toast } from "sonner";
import { processSqlTemplate } from "./processSqlTemplate";

export const useExecQuery = () => {
  const { setIsConnected, activeAdapter } = useScriptConnectionStore();

  return async (query: string, context?: Record<string, any>) => {
    if (!query) return [];

    if (!activeAdapter || !activeAdapter.isConnected()) {
      const errorMsg = "No hay una conexi√≥n activa. Verifica la configuraci√≥n.";
      toast.error("Error de Ejecuci√≥n", {
        description: errorMsg,
      });

      return [];
    }

    const processedQuery = context ? processSqlTemplate(query, context) : query;
  };
};

export const execQueryType = `
declare function execQuery(query: string,context?:Record<string,any>): Promise<any[]>;
`;


============================================================
FILE_PATH: src\features\engine\parseSqlScript.ts
============================================================
export function parseSqlScript(text) {
  const regex = /--\[(.*?)\]([\s\S]*?)(?=(?:--\[|$))/g;
  const queries = {};
  let match;
  while ((match = regex.exec(text)) !== null) {
    const key = match[1].trim();
    const query = match[2].trim();
    queries[key] = query;
  }
  return queries as Record<string, string>;
}


============================================================
FILE_PATH: src\features\engine\processSqlTemplate.ts
============================================================
export function processSqlTemplate(
  sql: string,
  variables: Record<string, any>
) {
  // Regex: Busca {{ seguido de cualquier espacio, captura el nombre, espacios y }}
  return sql.replace(/\{\{\s*([^}]+)\s*\}\}/g, (_match, key) => {
    const varName = key.trim(); // Quitamos espacios extra: " parentId " -> "parentId"
    const value = variables[varName];

    // 1. Si no existe la variable, devolvemos NULL o dejamos el tag (t√∫ decides)
    if (value === undefined) {
      console.warn(`Variable ${varName} no encontrada`);
      return "NULL";
    }

    // 2. Si es null
    if (value === null) return "NULL";

    // 3. Si es String, agregamos comillas simples para que sea SQL v√°lido
    // 4. Si es Array (√∫til para IN (...)), los unimos por comas
    if (Array.isArray(value)) {
      return value.join(", ");
    }

    // 5. N√∫meros y booleanos se devuelven directos
    return String(value);
  });
}


============================================================
FILE_PATH: src\features\engine\runScript.ts
============================================================
import { parseSqlScript } from "./parseSqlScript";
import { processSqlTemplate } from "./processSqlTemplate";

const AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;

export interface LogEntry {
  message: string;
  data?: any[]; // El '?' hace que la propiedad sea opcional
}

async function executeSafeScript(
  scriptCode: string,
  context: Record<string, any>,
  blockedList: string[]
) {
  let result;
  const allowedContext = {
    Math: Math,
    JSON: JSON,
    ...context,
  };
  try {
    const allowedKeys = Object.keys(allowedContext);
    const allowedValues = Object.values(allowedContext);
    const allArgNames = [...allowedKeys, ...blockedList];
    const allArgValues = [
      ...allowedValues,
      ...blockedList.map(() => undefined),
    ];
    const fn = new AsyncFunction(...allArgNames, scriptCode);
    result = await fn(...allArgValues);
  } catch (e: any) {
    /*     const logError = allowedContext.console
      ? allowedContext.console.error
      : console.error; */
    /*     logError("Error cr√≠tico de ejecuci√≥n: " + e.message); */
  }

  return { result };
}

export async function runScript(
  jsScript: string,
  sqlScript: string,
  scriptContext?: Record<string, any>
) {
  const queries = parseSqlScript(sqlScript);

  const blockedList = [
    "fetch",
    "XMLHttpRequest",
    "setInterval",
    "globalThis",
    "eval",
    "Function",
    "document",
    "window",
    "console",
  ];

  const handleExecQuery = async (
    query: string,
    context: Record<string, string> = {}
  ) => {
    query = processSqlTemplate(query, context);
    return scriptContext?.execQuery ? await scriptContext.execQuery(query) : [];
  };

  const { result } = await executeSafeScript(
    jsScript,
    {
      execQuery: handleExecQuery,
      QUERIES: queries,
      ...scriptContext,
    },
    blockedList
  );

  return { result };
}


============================================================
FILE_PATH: src\features\gallery\index.ts
============================================================
export { DashboardCard } from "./components/DashboardCard";
export { DashboardGrid } from "./components/DashboardGrid";
export { GalleryHeader } from "./components/GalleryHeader";
export { GalleryModals } from "./components/GalleryModals";
export { GallerySearchBar } from "./components/GallerySearchBar";
export { useDashboardGallery } from "./hooks/useDashboardGallery";


============================================================
FILE_PATH: src\features\gallery\components\DashboardCard.tsx
============================================================
import { Button } from "@/components/ui/button";
import { Card, CardHeader, CardContent } from "@/components/ui/card";
import { TrashIcon, Play, Edit } from "lucide-react";
import { DashboardCardProps } from "../types/gallery.types";

export const DashboardCard = ({
  name,
  onClick,
  onDelete,
  onEdit,
}: DashboardCardProps) => {
  return (
    <Card className="w-40 h-35 gap-4 items-center justify-center ">
      <CardHeader className="text-center  w-full text-2xl" title={name}>
        {name}
      </CardHeader>
      <CardContent className="flex gap-2">
        <Button variant="outline" size="icon" onClick={onDelete}>
          <TrashIcon className="h-4 w-4" />
        </Button>
        <Button variant="outline" size="icon" onClick={onEdit}>
          <Edit className="h-4 w-4" />
        </Button>
        <Button variant="outline" size="icon" onClick={onClick}>
          <Play className="h-4 w-4" />
        </Button>
      </CardContent>
    </Card>
  );
};


============================================================
FILE_PATH: src\features\gallery\components\DashboardGrid.tsx
============================================================
import { DashboardCardData } from "../types/gallery.types";
import { DashboardCard } from "./DashboardCard";

interface DashboardGridProps {
  dashboards: DashboardCardData[];
  onClick: (dashboardId: string) => void;
  onEdit: (dashboardId: string) => void;
  onDelete: (dashboardId: string) => void;
}

export const DashboardGrid = ({
  dashboards,
  onClick,
  onEdit,
  onDelete,
}: DashboardGridProps) => {
  if (dashboards.length === 0) {
    return (
      <div className="flex items-center justify-center p-8">
        <p className="text-muted-foreground text-lg">
          No se encontraron dashboards.
        </p>
      </div>
    );
  }

  return (
    <div className="flex flex-wrap gap-4">
      {dashboards.map((dashboard) => (
        <DashboardCard
          key={dashboard.id}
          name={dashboard.name}
          onClick={() => onClick(dashboard.id)}
          onEdit={() => onEdit(dashboard.id)}
          onDelete={() => onDelete(dashboard.id)}
        />
      ))}
    </div>
  );
};


============================================================
FILE_PATH: src\features\gallery\components\GalleryHeader.tsx
============================================================
import { Button } from "@/components/ui/button";
import { LogOut } from "lucide-react";

interface GalleryHeaderProps {
  onSignOut: () => void;
}

export const GalleryHeader = ({ onSignOut }: GalleryHeaderProps) => {
  return (
    <div className="mb-10 pt-2 flex justify-between items-center">
      <h1 className="text-3xl font-bold">Dashboard</h1>
      <Button
        variant="ghost"
        onClick={onSignOut}
        className="text-muted-foreground hover:text-destructive hover:bg-destructive/10"
      >
        <LogOut className="mr-2 h-4 w-4" />
        Cerrar Sesi√≥n
      </Button>
    </div>
  );
};


============================================================
FILE_PATH: src\features\gallery\components\GalleryModals.tsx
============================================================
import { FormModal } from "@/components/custom/Modals/FormModal";
import { ConfirmModal } from "@/components/custom/Modals/ConfirmModal";
import { LoadingModal } from "@/components/custom/Modals/LoadingModal";
import { DASHBOARD_SCHEMA, DASHBOARD_FIELDS } from "../types/gallery.types";

interface GalleryModalsProps {
  addFormId: string;
  editFormId: string;
  confirmId: string;
  loadingModalId: string;
  onConfirm: (data: { name: string }) => void;
  onConfirmEdit: (data: { name: string }) => void;
  onConfirmDelete: () => void;
}

export const GalleryModals = ({
  addFormId,
  editFormId,
  confirmId,
  loadingModalId,
  onConfirm,
  onConfirmEdit,
  onConfirmDelete,
}: GalleryModalsProps) => {
  return (
    <>
      <FormModal
        id={addFormId}
        title="Nuevo Dashboard"
        schema={DASHBOARD_SCHEMA}
        fields={DASHBOARD_FIELDS}
        confirmName="Dashboard"
        submitLabel="Crear"
        onSubmit={onConfirm}
      />
      <FormModal
        id={editFormId}
        title="Editar Dashboard"
        schema={DASHBOARD_SCHEMA}
        fields={DASHBOARD_FIELDS}
        confirmName="Dashboard"
        submitLabel="Guardar"
        onSubmit={onConfirmEdit}
      />
      <ConfirmModal
        id={confirmId}
        title="Confirmar Eliminaci√≥n"
        description="¬øEst√°s seguro de que quieres eliminar este dashboard? Esta acci√≥n no se puede deshacer."
        confirmName="Eliminar"
        onConfirm={onConfirmDelete}
      />
      <LoadingModal id={loadingModalId} />
    </>
  );
};


============================================================
FILE_PATH: src\features\gallery\components\GallerySearchBar.tsx
============================================================
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";

interface GallerySearchBarProps {
  query: string;
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onAdd: () => void;
}

export const GallerySearchBar = ({
  query,
  onChange,
  onAdd,
}: GallerySearchBarProps) => {
  return (
    <div className="w-full h-20 flex gap-4">
      <Input
        onChange={onChange}
        placeholder="Buscar dashboard"
        value={query}
        aria-label="Buscar dashboard"
        className="flex-1"
      />
      <Button variant="default" onClick={onAdd}>
        Nuevo Dashboard
      </Button>
    </div>
  );
};


============================================================
FILE_PATH: src\features\gallery\hooks\useDashboardGallery.tsx
============================================================
/* eslint-disable @typescript-eslint/no-explicit-any */
import { useModals } from "@/providers/ModalProvider";
import { useSearch } from "@/hooks/useSearch";
import { useUser } from "@/hooks/useUser";
/* import { fetchDashboards } from "@/lib/redux/features/dashboardSlice"; */
import { useRouter } from "next/navigation";

import { ChangeEvent, useEffect, useId } from "react";
import { useDashboardStore } from "@/features/dashboard/store/useDashboardStore";

export const useDashboardGallery = () => {
  const router = useRouter();
  const editFormId = useId();
  const confirmId = useId();
  const addFormId = useId();
  const loadingModalId = useId();
  const { openModal, closeModal, getModalData } = useModals();
  const { user, signOut } = useUser();

  const {
    dashboards,
    addDashboard,
    deleteDashboard,
    renameDashboard,
    isLoading,
    refresh,
  } = useDashboardStore();

  useEffect(() => {
    if (user) {
      refresh();
    }
  }, [user, refresh]);

  useEffect(() => {
    if (isLoading) {
      openModal(loadingModalId, {
        message: "Cargando galer√≠a...",
        subMessage: "Obteniendo tus dashboards desde la nube.",
      });
    } else {
      const timeout = setTimeout(() => {
        closeModal(loadingModalId);
      }, 300);
      return () => clearTimeout(timeout);
    }
  }, [isLoading, closeModal, openModal, loadingModalId]);

  const { query, setQuery, results } = useSearch(dashboards, (item, value) => {
    return item.name.toLowerCase().includes(value.toLowerCase());
  });

  const onChange = (e: ChangeEvent<HTMLInputElement>) =>
    setQuery(e.target.value);

  const onAdd = () => {
    openModal(addFormId);
  };

  const onConfirm = (data: Record<string, string>) => {
    closeModal(addFormId);
    setQuery("");
    if (!user) return;
    addDashboard(data["name"], user.id);
  };

  const onClick = (id: string) => {
    router.replace(`/dashboard/${id}`);
  };

  const onDelete = (id: string) => {
    openModal(confirmId, { id });
  };

  const onConfirmDelete = () => {
    const data = getModalData(confirmId);
    deleteDashboard(data.id);
  };

  const onEdit = (id: string) => {
    openModal(editFormId, { id });
  };

  const onConfirmEdit = ({ name }: { name: string }) => {
    const data = getModalData(editFormId);
    renameDashboard(data.id, name);
    closeModal(editFormId);
  };

  const onSignOut = async () => {
    router.replace("/login");
    await signOut();
  };

  return {
    results,
    query,
    onChange,
    onAdd,
    onConfirm,
    onClick,
    onDelete,
    onConfirmDelete,
    onEdit,
    onConfirmEdit,
    onSignOut,
    addFormId,
    editFormId,
    confirmId,
    loadingModalId,
  };
};


============================================================
FILE_PATH: src\features\gallery\types\gallery.types.ts
============================================================
import { z } from "zod";
import { FieldConfig } from "@/components/custom/DynamicForm";

export interface DashboardCardProps {
  name: string;
  onClick?: () => void;
  onEdit?: () => void;
  onDelete?: () => void;
}

export interface DashboardCardData {
  id: string;
  name: string;
}

export interface GalleryModals {
  addFormId: string;
  editFormId: string;
  confirmId: string;
  loadingModalId: string;
}

export interface GalleryHandlers {
  query: string;
  results: DashboardCardData[];
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onClick: (dashboardId: string) => void;
  onAdd: () => void;
  onDelete: (dashboardId: string) => void;
  onConfirmDelete: () => void;
  onConfirm: (data: { name: string }) => void;
  onEdit: (dashboardId: string) => void;
  onConfirmEdit: (data: { name: string }) => void;
  onSignOut: () => void;
}

export const DASHBOARD_SCHEMA = z.object({
  name: z.string().min(4, "El nombre debe tener al menos 4 caracteres"),
});

export const DASHBOARD_FIELDS: FieldConfig[] = [
  {
    name: "name",
    label: "Nombre",
    type: "text",
    placeholder: "Ingresa el nombre del dashboard",
  },
];


============================================================
FILE_PATH: src\features\page\index.ts
============================================================
export { usePageViewer } from "./hooks/usePageViewer";


============================================================
FILE_PATH: src\features\page\hooks\usePageViewer.ts
============================================================
/* eslint-disable react-hooks/refs */
import { useState, useEffect, useId, useRef, useCallback } from "react";
import { useParams, useRouter } from "next/navigation";
/* import { useAppDispatch, useAppSelector } from "@/lib/redux/hooks"; */
/* import { fetchPageContent } from "@/lib/redux/features/pageSlice"; */
import { runScript } from "@/lib/runScript/runScript";
import { Component } from "@/lib/ComponentBuilders/Component";
import { useScriptEditor } from "@/features/editor/hooks/useScriptEditor";
import { useModals } from "@/providers/ModalProvider";
import { usePageEditor } from "@/hooks/usePageEditor";
/* import { useDashboards } from "@/hooks/useDashboards"; */
import { useDBConnection } from "@/hooks/useDBConnection";
import { usePageStore } from "@/features/page/store/usePageStore";
/* import { usePageStore } from "../../../store/page/useStore"; */

export const usePageViewer = () => {
  // --- 1. HOOKS & ROUTING ---
  const loadingId = useId();
  const router = useRouter();
  const params = useParams();
  const pageId = params.pageId as string;
  const dashboardId = params.dashboardId as string;

  const { openModal } = useModals();

  const { fetchContent, page, saveCode } = usePageStore(pageId);

  const { setJsCode, setSqlCode, jsCode, sqlCode, isEditing, setIsEditing } =
    useScriptEditor();
  const { isConnected } = useDBConnection();

  const { isSaving } = usePageEditor(pageId);

  const [componentStruct, setComponentStruct] = useState<Component | null>(
    null
  );
  const [isRunningScript, setIsRunningScript] = useState(false);

  const scriptContext = useScriptActions();
  const scriptContextRef = useRef(scriptContext);
  scriptContextRef.current = scriptContext;
  useEffect(() => {
    if (!pageId && dashboardId) {
      router.replace(`/dashboard/${dashboardId}`);
    }
  }, [pageId, dashboardId, router]);

  useEffect(() => {
    if (pageId && !page?.isLoaded && isConnected) {
      fetchContent();
    }
  }, [pageId, isConnected]);

  useEffect(() => {
    let isMounted = true;
    if (!pageId || !page?.isLoaded || !isConnected) return;
    if (!page.jsScript || page.jsScript.trim() === "") {
      setComponentStruct(null);
      setIsRunningScript(false);
      return;
    }

    setIsRunningScript(true);
    runScript(page.jsScript, page.sqlScript || "", scriptContextRef.current)
      .then(({ result }) => {
        if (isMounted) {
          setComponentStruct(result);
        }
      })
      .catch((err) => {
        console.error("Error ejecutando script de p√°gina:", err);
        if (isMounted) setComponentStruct(null);
      })
      .finally(() => {
        if (isMounted) setIsRunningScript(false);
      });

    return () => {
      isMounted = false;
    };
  }, [pageId, page, isConnected]);

  const handleOnOpenEditor = useCallback(() => {
    if (page?.jsScript) setJsCode(page.jsScript);
    if (page?.sqlScript) setSqlCode(page.sqlScript || "");
    setIsEditing(true);
  }, [page, setJsCode, setSqlCode, setIsEditing]);

  const handleConfigure = useCallback(() => {
    openModal("213123123_editor_modal");
  }, [openModal]);

  const handleOnCloseEditor = useCallback(() => {
    setIsEditing(false);
  }, [setIsEditing]);

  const onSave = useCallback(() => {
    saveCode(jsCode, sqlCode);
    /*     savePageRemote(pageId, ); */
  }, [pageId, jsCode, sqlCode, saveCode]);

  const isLoading = !page || isRunningScript;

  return {
    componentStruct,
    page,
    isLoading,
    isEditing,
    setIsEditing,
    loadingId,
    handleConfigure,
    handleOnCloseEditor,
    handleOnOpenEditor,
    onSave,
    isSaving,
  };
};


============================================================
FILE_PATH: src\features\page\store\usePageStore.ts
============================================================
import { useMemo, useCallback } from "react";
import { useParams } from "next/navigation";
import { Page } from "@/types/types";
import { useStore } from "./useStore";

export const usePageStore = (id?: string) => {
  const params = useParams();

  // 1. Identificar el ID de la p√°gina (Prop > URL > undefined)
  const pageId = id || (params?.pageId as string);

  // 2. Selectores de Zustand
  const pagesMap = useStore((s) => s.pages);
  const status = useStore((s) => s.status);

  // 3. Acciones del Store
  const fetchPagesAction = useStore((s) => s.fetchPages);
  const fetchPageContentAction = useStore((s) => s.fetchPageContent);
  const updatePageLocalAction = useStore((s) => s.updatePageLocal);
  const savePageRemoteAction = useStore((s) => s.savePageRemote);
  const updatePageSettingsAction = useStore((s) => s.updatePageSettings);

  // 4. Datos Computados (Memoizados)
  const pages = useMemo(() => Object.values(pagesMap), [pagesMap]);

  const currentPage = useMemo(
    () => (pageId ? pagesMap[pageId] : undefined),
    [pagesMap, pageId]
  );

  // 5. Helpers para validaci√≥n
  const requirePageId = useCallback(() => {
    if (!pageId) {
      console.error("Operaci√≥n fallida: No hay una p√°gina seleccionada.");
      return false;
    }
    return true;
  }, [pageId]);

  return {
    // --- Estado ---
    status,
    isLoading: status === "loading" || status === "idle",
    pages, // Array de todas las p√°ginas cargadas
    page: currentPage, // Objeto de la p√°gina actual (o undefined)

    // --- Acciones de Carga ---

    // Cargar lista de p√°ginas de un dashboard
    fetchPages: async (dashboardId: string) => {
      await fetchPagesAction(dashboardId);
    },

    // Cargar contenido pesado (scripts) de la p√°gina actual
    fetchContent: async () => {
      if (requirePageId()) {
        await fetchPageContentAction(pageId);
      }
    },

    // --- Acciones de Edici√≥n (Editor de C√≥digo) ---

    // Actualizaci√≥n local (sin guardar en DB) - ideal para el evento onChange del editor
    updateLocal: (updates: Partial<Page>) => {
      if (requirePageId()) {
        updatePageLocalAction(pageId, updates);
      }
    },

    // Guardar c√≥digo (JS/SQL) en Supabase
    saveCode: async (js: string, sql: string) => {
      if (requirePageId()) {
        await savePageRemoteAction(pageId, js, sql);
      }
    },

    // --- Acciones de Configuraci√≥n (Settings) ---

    // Actualizar metadatos (Nombre, Icono, Privacidad)
    updateSettings: async (updates: Partial<Page>) => {
      if (requirePageId()) {
        await updatePageSettingsAction(pageId, updates);
      }
    },

    // Helper espec√≠fico para cambiar nombre (az√∫car sint√°ctico)
    renamePage: async (name: string) => {
      if (requirePageId()) {
        await updatePageSettingsAction(pageId, { name });
      }
    },
  };
};


============================================================
FILE_PATH: src\features\page\store\useStore.ts
============================================================
import { create } from "zustand";
import { systemSupabase } from "@/lib/supabase/client";
import { Page } from "@/types/types";

interface PageState {
  pages: Record<string, Page & { isLoaded?: boolean }>;
  status: "idle" | "loading" | "succeeded" | "failed";

  // Acciones
  fetchPages: (dashboardId: string) => Promise<void>;
  fetchPageContent: (pageId: string) => Promise<void>;
  updatePageLocal: (pageId: string, updates: Partial<Page>) => void;
  savePageRemote: (pageId: string, js: string, sql: string) => Promise<void>;
  updatePageSettings: (pageId: string, updates: Partial<Page>) => Promise<void>;
}

const DBDashboardToStore = (item) => {
  return {
    icon: item.icon,
    id: item.id,
    name: item.name,
    dashboardId: item.dashbaord_id,
    sqlScript: item.sql_script,
    jsScript: item.js_script,
    isPublic: item.is_public,
  };
};

export const useStore = create<PageState>((set, get) => ({
  pages: {},
  status: "idle",

  fetchPages: async (dashboardId) => {
    const { data, error } = await systemSupabase
      .from("pages")
      .select("*")
      .eq("dashboard_id", dashboardId);
    if (error) throw error;

    const pages: Record<string, Page & { isLoaded?: boolean }> = {};

    data.forEach((item) => {
      /*       const page: Page = {
        icon: item.icon,
        id: item.id,
        name: item.name,
        dashboardId: item.dashbaord_id,
        sqlScript: item.sql_script,
        jsScript: item.js_script,
        isPublic: item.is_public,
      }; */
      const page = DBDashboardToStore(item);
      pages[page.id] = { ...page, isLoaded: true };
    });

    set({ pages });
  },

  fetchPageContent: async (pageId) => {
    // Evitar refetch si ya est√° cargada (opcional)
    if (get().pages[pageId]?.jsScript) return;

    set({ status: "loading" });
    const { data, error } = await systemSupabase
      .from("pages")
      .select("*")
      .eq("id", pageId)
      .single();

    const page = DBDashboardToStore(data);

    if (!error && data) {
      set((state) => ({
        pages: {
          ...state.pages,
          [pageId]: { ...state.pages[pageId], ...page, isLoaded: true },
        },
        status: "succeeded",
      }));
    } else {
      set({ status: "failed" });
    }
  },

  updatePageLocal: (pageId, updates) => {
    set((state) => ({
      pages: {
        ...state.pages,
        [pageId]: { ...state.pages[pageId], ...updates },
      },
    }));
  },

  savePageRemote: async (pageId, jsScript, sqlScript) => {
    get().updatePageLocal(pageId, { jsScript, sqlScript });

    await systemSupabase
      .from("pages")
      .update({ js_script: jsScript, sql_script: sqlScript })
      .eq("id", pageId);
  },
  updatePageSettings: async (pageId, updates) => {
    set((state) => ({
      pages: {
        ...state.pages,
        [pageId]: { ...state.pages[pageId], ...updates },
      },
    }));

    // 2. Persistencia en Supabase
    const { error } = await systemSupabase
      .from("pages")
      .update(updates)
      .eq("id", pageId);

    if (error) {
      // Revertir si falla (opcional, pero recomendado)
      console.error("Error updating page:", error);
      // Aqu√≠ podr√≠as disparar un toast de error o revertir el estado
      throw error;
    }
  },
}));


============================================================
FILE_PATH: src\features\scriptConnection\lib\MockAdapter.ts
============================================================
// src/lib/db-adapters/MockAdapter.ts
import { DatabaseAdapter, QueryResult } from "./types";

export class MockAdapter implements DatabaseAdapter {
  id = "mock";
  name = "Mock Local DB";
  private connected = false;

  async connect(): Promise<void> {
    this.connected = true;
  }

  async disconnect(): Promise<void> {
    this.connected = false;
  }

  isConnected(): boolean {
    return this.connected;
  }

  async execute(query: string): Promise<QueryResult> {
    if (!this.connected) return { data: null, error: "Disconnected" };

    // Simulamos una respuesta basada en lo que escribas
    if (query.toLowerCase().includes("select")) {
      return {
        data: [
          { id: 1, name: "Mock User 1", role: "admin" },
          { id: 2, name: "Mock User 2", role: "user" },
        ],
        error: null,
      };
    }

    return { data: null, error: "Syntax Error: Mock DB solo soporta SELECT" };
  }
}


============================================================
FILE_PATH: src\features\scriptConnection\lib\SupabaseAdapter.ts
============================================================
import { createClient, SupabaseClient } from "@supabase/supabase-js";
import { DatabaseAdapter, QueryResult } from "./types";

export class SupabaseAdapter implements DatabaseAdapter {
  id = "supabase";
  name = "Supabase Production";
  private client: SupabaseClient | null = null;
  private connected = false;

  async connect(config: { url: string; key: string }): Promise<void> {
    if (!config?.url || !config?.key) {
      throw new Error("Supabase URL y Key son requeridos para conectar.");
    }

    try {
      // 1. Inicializamos el cliente con las credenciales proporcionadas din√°micamente
      this.client = createClient(config.url, config.key, {
        auth: {
          persistSession: false,
          detectSessionInUrl: false,
          autoRefreshToken: false,
        },
      });

      // 2. "Ping" de validaci√≥n: Intentamos una consulta simple para verificar credenciales
      // Nota: Esto asume que ya creaste la funci√≥n RPC 'exec_sql' en tu base de datos.
      const { error } = await this.client.rpc("exec_sql", {
        sql_query: "SELECT 1",
      });

      if (error) throw error;

      this.connected = true;
    } catch (err: any) {
      this.connected = false;
      this.client = null;
      throw new Error(`Fallo al conectar: ${err.message}`);
    }
  }

  async disconnect(): Promise<void> {
    // Supabase js no requiere desconexi√≥n expl√≠cita (es stateless via HTTP),
    // pero limpiamos la referencia.
    this.client = null;
    this.connected = false;
  }

  isConnected(): boolean {
    return this.connected && this.client !== null;
  }

  async execute(query: string): Promise<QueryResult> {
    if (!this.client || !this.connected) {
      return { data: null, error: "No hay conexi√≥n establecida con Supabase" };
    }

    try {
      // Llamamos a la funci√≥n RPC que permite ejecutar RAW SQL
      const { data, error } = await this.client.rpc("exec_sql", {
        sql_query: query,
      });

      if (error) throw error;

      // L√≥gica para interpretar la respuesta de nuestra funci√≥n RPC customizada:

      // Caso 1: Error controlado devuelto por el SQL (dentro del JSON)
      if (data && !Array.isArray(data) && data.error) {
        return { data: null, error: data.error };
      }

      // Caso 2: Mensaje de √©xito (INSERT/UPDATE/DELETE que devuelve objeto de status)
      if (data && !Array.isArray(data) && data.status === "success") {
        return {
          data: null,
          error: null,
          message: data.message || "Comando ejecutado exitosamente",
        };
      }

      // Caso 3: Array de datos (SELECT)
      return {
        data: Array.isArray(data) ? data : [], // Si es null (sin filas), devolvemos array vac√≠o
        error: null,
        message: undefined,
      };
    } catch (err: any) {
      return { data: null, error: err.message || "Error al ejecutar consulta" };
    }
  }
}


============================================================
FILE_PATH: src\features\scriptConnection\lib\types.ts
============================================================
// src/lib/db-adapters/types.ts

export interface QueryResult {
  data: any[] | null;
  error: string | null;
  message?: string; // Para mensajes de √©xito como "Table created"
}

// Interfaz que todos los adaptadores deben cumplir
export interface DatabaseAdapter {
  id: string; // 'supabase', 'local', 'mock'
  name: string; // Nombre legible

  // Conectar (puede recibir credenciales o config)
  connect(config?: any): Promise<void>;

  // Desconectar
  disconnect(): Promise<void>;

  // Ejecutar query
  execute(query: string): Promise<QueryResult>;

  // Verificar estado
  isConnected(): boolean;
}


============================================================
FILE_PATH: src\features\scriptConnection\store\useScriptConnectionStore.ts
============================================================
import { useStore } from "./useStore";

export const useScriptConnectionStore = () => {
  const isConnected = useStore((s) => s.isConnected);
  const isConnecting = useStore((s) => s.isConnecting);
  const error = useStore((s) => s.error);
  const config = useStore((s) => s.config);
  const activeAdapter = useStore((s) => s.activeAdapter);
  const connect = useStore((s) => s.connect);
  const disconnect = useStore((s) => s.disconnect);
  const setConfig = useStore((s) => s.setConfig);
  const setIsConnected = useStore((s) => s.setIsConnected);

  return {
    isConnected,
    setIsConnected,
    isConnecting,
    error,
    activeAdapter,
    connect,
    disconnect,
    setConfig,
    config,
  };
};


============================================================
FILE_PATH: src\features\scriptConnection\store\useStore.ts
============================================================
import { create } from "zustand";
import { SupabaseAdapter } from "../lib/SupabaseAdapter";
import { MockAdapter } from "../lib/MockAdapter";
import { DatabaseAdapter } from "../lib/types";

interface ConnectionConfig {
  url: string;
  key: string;
  type: string;
}
interface ConnectionState {
  isConnected: boolean;
  isConnecting: boolean;
  config: ConnectionConfig | null;
  error: string | null;
  setIsConnected: (value: boolean) => void;
  activeAdapter: DatabaseAdapter | null;
  connect: (config: ConnectionConfig) => Promise<void>;
  disconnect: () => Promise<void>;
  setConfig: (config: ConnectionConfig) => void;
  /*   execQuery: (query: string) => Promise<any>; */
}

const createAdapter = (type: string): DatabaseAdapter => {
  switch (type?.toLowerCase()) {
    case "supabase":
      return new SupabaseAdapter();
    case "mock":
      return new MockAdapter();
    default:
      throw new Error(`Tipo de base de datos no soportado: ${type}`);
  }
};

export const useStore = create<ConnectionState>((set, get) => ({
  isConnected: false,
  isConnecting: false,
  error: null,
  activeAdapter: null,
  config: null,
  setConfig: (config) => set({ config }),
  disconnect: async () => {
    const { activeAdapter } = get();
    if (activeAdapter) {
      await activeAdapter.disconnect();
    }
    set({ isConnected: false, activeAdapter: null });
  },
  setIsConnected: (value) => {
    set({ isConnected: value });
  },
  connect: async (config: ConnectionConfig) => {
    set({ isConnecting: true, error: null, isConnected: false });

    try {
      await get().disconnect();
      const adapter = createAdapter(config.type);
      await adapter.connect(config);
      set({
        isConnected: true,
        isConnecting: false,
        activeAdapter: adapter,
        config: config,
        error: null,
      });
    } catch (err: any) {
      const errorMessage = err.message || "Error desconocido al conectar";
      set({
        isConnected: false,
        isConnecting: false,
        error: errorMessage,
        activeAdapter: null,
      });
      throw err;
    }
  },
}));


============================================================
FILE_PATH: src\hooks\use-mobile.ts
============================================================
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}


============================================================
FILE_PATH: src\hooks\usePageEditor.ts
============================================================
// src/hooks/usePageEditor.ts
import { updatePageRemote } from "@/lib/redux/features/pageSlice";
import { useAppDispatch, useAppSelector } from "@/lib/redux/hooks";

export const usePageEditor = (pageId: string) => {
  // 1. Obtenemos el status para saber si est√° cargando
  const { byId, status } = useAppSelector((state) => state.pages);
  const dispatch = useAppDispatch();

  const page = pageId ? byId[pageId] : null;

  return {
    sqlCode: page?.sqlScript || "",
    jsCode: page?.jsScript || "",

    // 2. Exponemos la bandera de carga
    isSaving: status === "loading",

    // Setters individuales (por si los necesitas)
    setSql: (code: string) => {
      if (pageId) {
        dispatch(
          updatePageRemote({ id: pageId, updates: { sqlScript: code } })
        );
      }
    },
    setJs: (code: string) => {
      if (pageId) {
        dispatch(updatePageRemote({ id: pageId, updates: { jsScript: code } }));
      }
    },

    // 3. NUEVA FUNCI√ìN: Guardar todo junto (Mucho m√°s eficiente)
    savePage: (js: string, sql: string) => {
      if (pageId) {
        dispatch(
          updatePageRemote({
            id: pageId,
            updates: {
              jsScript: js,
              sqlScript: sql,
            },
          })
        );
      }
    },
  };
};


============================================================
FILE_PATH: src\hooks\usePages.ts
============================================================
import { IconName } from "@/components/custom/DynamicIcon";
import {
  addPageRemote,
  deletePageRemote,
  updatePageRemote,
} from "@/lib/redux/features/pageSlice";
import { useAppDispatch, useAppSelector } from "@/lib/redux/hooks";
import { Page } from "@/types/types";
import { useUser } from "@/hooks/useUser"; // <--- 1. Importamos el hook de usuario
export const usePages = (dashbaordId?: string) => {
  // 2. Obtenemos el usuario autenticado
  const { user } = useUser();

  const pagesMap = useAppSelector((state) => state.pages.byId);

  const dispatch = useAppDispatch();

  /*   const activeDashboardId = data ? data["dashboardId"] : null;
   */
  let pages: Page[] = [];
  if (dashbaordId) {
    pages = Object.values(pagesMap).filter(
      (page) => page.dashboardId === dashbaordId
    );
  }

  return {
    pages,
    dashbaordId,
    addPage: (name: string, icon: IconName) => {
      // 3. Verificamos que tengamos tanto el Dashboard activo como el Usuario
      if (dashbaordId && user) {
        dispatch(
          addPageRemote({
            dashboardId: dashbaordId,
            name,
            icon,
            userId: user.id, // <--- 4. Pasamos el ID del usuario aqu√≠
          })
        );
      } else {
        console.warn(
          "No se puede crear p√°gina: Falta usuario o dashboard activo"
        );
      }
    },

    renamePage: (id: string, name: string) => {
      dispatch(updatePageRemote({ id, updates: { name } }));
    },

    deletePage: (id: string) => {
      dispatch(deletePageRemote(id));
    },
  };
};


============================================================
FILE_PATH: src\hooks\useSearch.ts
============================================================
import { useMemo, useDeferredValue, useState } from "react";

export const useSearch = <T>(
  data: T[],
  filterFn: (item: T, query: string) => boolean
) => {
  const [query, setQuery] = useState("");
  const deferredQuery = useDeferredValue(query);

  const filteredData = useMemo(() => {
    if (!deferredQuery) return data;
    return data.filter((item) => filterFn(item, deferredQuery));
  }, [data, deferredQuery, filterFn]);

  const isSearching = query !== deferredQuery;

  return {
    results: filteredData,
    query,
    setQuery,
    isSearching,
  };
};


============================================================
FILE_PATH: src\hooks\useUser.tsx
============================================================
"use client";

import { useEffect, useState, createContext, useContext } from "react";
import { User } from "@supabase/supabase-js";
import { systemSupabase } from "@/lib/supabase/client";

// Definimos qu√© informaci√≥n tendr√° nuestro contexto
interface UserContextType {
  user: User | null;
  isLoading: boolean;
  signOut: () => Promise<void>;
}

const UserContext = createContext<UserContextType | undefined>(undefined);

export function UserProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // 1. Verificar sesi√≥n inicial
    const checkUser = async () => {
      try {
        const {
          data: { session },
        } = await systemSupabase.auth.getSession();
        setUser(session?.user ?? null);
      } catch (error) {
        console.error("Error cargando usuario:", error);
      } finally {
        setIsLoading(false);
      }
    };

    checkUser();

    // 2. Escuchar cambios en tiempo real (Login, Logout, Auto-refresh)
    const {
      data: { subscription },
    } = systemSupabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null);
      setIsLoading(false);
    });

    return () => {
      subscription.unsubscribe();
    };
  }, []);

  const signOut = async () => {
    await systemSupabase.auth.signOut();
    setUser(null);
    // Opcional: Redirigir o limpiar estado aqu√≠
  };

  const value = {
    user,
    isLoading,
    signOut,
  };

  return <UserContext.Provider value={value}>{children}</UserContext.Provider>;
}

// Este es el hook que usar√°s en tus componentes
export const useUser = () => {
  const context = useContext(UserContext);
  if (context === undefined) {
    throw new Error("useUser debe ser usado dentro de un UserProvider");
  }
  return context;
};


============================================================
FILE_PATH: src\lib\utils.ts
============================================================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


============================================================
FILE_PATH: src\lib\ComponentBuilders\Builders.ts
============================================================
import { Button, ButtonEventsType, ButtonType } from "./Button";
import { Layout, LayoutType } from "./Layout";
import { ConfirmModal, ConfirmModalType } from "./ConfirmModal";
import { ComponentType } from "./Component";
import { Gallery, GalleryEventsType, GalleryType } from "./Gallery";
import { Navigation, NavigationEventsType, NavigationType } from "./Navigation";
import { Table, TableEventsType, TableType } from "./Table";
import { CText, TextEventsType, TextType } from "./Text";
import { LoadingModal, LoadingModalType } from "./LoaddingModal";
import { FormModal, FormModalType } from "./FormModal";
import { Fragment, FragmentType } from "./Fragment";
import { Form, FormType } from "./Form";

export const ComponentsBuilders = {
  Button,
  ConfirmModal,
  Layout,
  Gallery,
  Navigation,
  Table,
  CText,
  LoadingModal,
  FormModal,
  Fragment,
  Form,
};

export const ComponentsTypes = [
  ComponentType,
  ButtonType,
  LayoutType,
  ConfirmModalType,
  GalleryType,
  NavigationType,
  TableType,
  TextType,
  LoadingModalType,
  FormModalType,
  FragmentType,
  FormType,
];

export const ComponentEventsTypes = [
  ButtonEventsType,
  GalleryEventsType,
  NavigationEventsType,
  TableEventsType,
  TextEventsType,
];


============================================================
FILE_PATH: src\lib\ComponentBuilders\Button.ts
============================================================
import {
  Component,
  ComponentEvent,
  DynamicValue,
  Context,
  IComponentData,
} from "./Component";

type ButtonConfig = {
  className?: string;
  style?: string;
  variant?: "outline" | "default";
  icon: string;
};

export type ButtonEvent = {
  setLabel: (value: string) => void;
  getLabel: () => void;
};
export interface ButtonMap {
  // Al usar esta sintaxis, forzamos a TS a creer que siempre devuelve un evento
  // y eliminamos el riesgo de "undefined" que rompe el intellisense
  [id: string]: ButtonEvent;
}

type Button = (data: {
  id: string;
  config?: ButtonConfig;
  onClick: ComponentEvent;
  context?: Context;
  label?: IComponentData<DynamicValue<string>>;
}) => Component;

export const Button: Button = ({ id, config, label, onClick, context }) => {
  return {
    id,
    type: "Button",
    context,
    data: { label },
    config: config ?? {},
    events: { onClick },
  };
};

export const ButtonType = `
type ButtonConfig = {
  className?: string;
  style?: string;
  variant?: "outline" | "default";
  icon: string;
};

interface ButtonProps {
  id: string;
  label?: IComponentData<DynamicValue<string>>;
  config?: ButtonConfig; // Aqu√≠ ocurre la magia
  onClick?: ComponentEvent;     // Opcional para facilitar pruebas
  context?: Context;
}

interface ButtonFactory {
  (data: ButtonProps): Component;
}

declare const Button: ButtonFactory;

`;

export const ButtonEventsType = `
type ButtonEvent = {
  setLabel: (value: string) => void;
  getLabel: () => string;
};
interface ButtonMap {
  // Al usar esta sintaxis, forzamos a TS a creer que siempre devuelve un evento
  // y eliminamos el riesgo de "undefined" que rompe el intellisense
  [id: string]: ButtonEvent; 
}
`;


============================================================
FILE_PATH: src\lib\ComponentBuilders\Component.ts
============================================================
import { ButtonMap } from "./Button";

export type Context = {
  comp: {
    btn: ButtonMap;
  };
};

export type ComponentEvent = (e: any, context: Context) => void;
export type Events = Record<string, ComponentEvent | undefined>;
export type DynamicResult<T> = T | Promise<T>;
export type DynamicFunction<T> = (context: Context) => DynamicResult<T>;
export type DynamicValue<T> = T | DynamicFunction<T>;

export type IComponentData<T> = T | { data: T; keepData: boolean };
export interface Component {
  type: string;
  id: string;
  config: Record<string, any>;
  data: Record<string, IComponentData<any>>;
  events: Events;
  context?: Context;
  subComponents?: Component[] | Component;
}

export const createContext = (): Context => {
  return {
    comp: {
      btn: {},
    },
  };
};

export const ComponentType = `
type Context = {
  comp: {
    btn: ButtonMap;
    nav: NavigationMap;
    gallery: GalleryMap;
    table:TableMap;
    text:TextMap;
  };
};


type ComponentEvent = (e: any, context: Context) => void;
type Events = Record<string, ComponentEvent>;

type DynamicResult<T> = T | Promise<T>;
type DynamicFunction<T> = (context: Context) => DynamicResult<T>;
type DynamicValue<T> = T | DynamicFunction<T>;
type IComponentData<T> = T | { data: T; keepData: boolean };

interface Component {
  type: string;
  id: string;
  config:Record<string, any>;
  data:Record<string, IComponentData<any>>
  events: Events;
  context?: Context;
  subComponents?: Component[] | Component;
}
`;


============================================================
FILE_PATH: src\lib\ComponentBuilders\ConfirmModal.ts
============================================================
import { Component, ComponentEvent, Context } from "./Component";

type ConfirmModalConfig = {
  title?: string;
  description?: string;
  className?: string;
};

type ConfirmModal = (data: {
  id: string;
  config: ConfirmModalConfig;
  onConfirm: ComponentEvent;
  onCancel: ComponentEvent;
  context?: Context;
}) => Component;

export const ConfirmModal: ConfirmModal = ({
  id,
  config,
  onConfirm,
  onCancel,
}) => {
  return {
    id,
    type: "ConfirmModal",
    config,
    events: { onConfirm, onCancel },
    subComponents: [],
    data: {},
  };
};

export const ConfirmModalType = `

type ConfirmModalConfig = {
  title?: string;
  description?: string;
  className?: string;
};

type ConfirmModal = (data: {
  id: string;
  config: ConfirmModalConfig;
  onConfirm: ComponentEvent;
  onCancel: ComponentEvent;
  context?:Context;
}) => Component;

declare const ConfirmModal:ConfirmModal;
`;


============================================================
FILE_PATH: src\lib\ComponentBuilders\Form.ts
============================================================
import { FieldConfig } from "@/components/custom/DynamicForm";
import {
  Component,
  ComponentEvent,
  Context,
  DynamicValue,
  IComponentData,
} from "./Component";

// 1. Configuraci√≥n
type FormModalConfig = {
  className?: string;
  classNameForm?: string;
  title?: string;
  description?: string;
  confirmName?: string;
  cancelName?: string;
};

// 3. Data (Esquema y Campos del formulario)
type FormDataDef = {
  schema?: any; // Zod schema o similar
  fields?: FieldConfig[]; // Definici√≥n de campos
  defaultValues: IComponentData<DynamicValue<any>>;
};

type FormData = {
  id: string;
  /* config?: FormModalConfig; */
  data?: IComponentData<FormDataDef>;
  onSubmit: ComponentEvent; // Evento que recibe los datos del form
  context?: Context;
};

type FormFactory = (data: FormData) => Component;

export const Form: FormFactory = ({
  id,
  /*   config, */
  data,
  onSubmit,
  context,
}) => {
  return {
    id,
    type: "FormModal",
    context,
    data: data || {},
    config: {},
    events: { onSubmit },
  };
};

// 4. Tipos para el Editor
export const FormType = `

// 3. Data (Esquema y Campos del formulario)
type FormDataDef = {
  schema?: any; // Zod schema o similar
  fields?: FieldConfig[]; // Definici√≥n de campos
  defaultValues: IComponentData<DynamicValue<any>>;
};

type FormProps = {
  id: string;
  /* config?: FormModalConfig; */
  data?: IComponentData<FormDataDef>;
  onSubmit: ComponentEvent; // Evento que recibe los datos del form
  context?: Context;
};

interface FormFactory {
  (data: FormProps): Component;
}

declare const FormModal: FormFactory;
`;


============================================================
FILE_PATH: src\lib\ComponentBuilders\FormModal.ts
============================================================
import { FieldConfig } from "@/components/custom/DynamicForm";
import {
  Component,
  ComponentEvent,
  Context,
  DynamicValue,
  IComponentData,
} from "./Component";

// 1. Configuraci√≥n
type FormModalConfig = {
  className?: string;
  classNameForm?: string;
  title?: string;
  description?: string;
  confirmName?: string;
  cancelName?: string;
};

// 3. Data (Esquema y Campos del formulario)
type FormModalDataDef = {
  schema?: any; // Zod schema o similar
  fields?: FieldConfig[]; // Definici√≥n de campos
  defaultValues: IComponentData<DynamicValue<any>>;
};

type FormModalData = {
  id: string;
  config?: FormModalConfig;
  data?: IComponentData<FormModalDataDef>;
  onSubmit: ComponentEvent; // Evento que recibe los datos del form
  context?: Context;
};

type FormModalFactory = (data: FormModalData) => Component;

export const FormModal: FormModalFactory = ({
  id,
  config,
  data,
  onSubmit,
  context,
}) => {
  return {
    id,
    type: "FormModal",
    context,
    data: data || {},
    config: config ?? {},
    events: { onSubmit },
  };
};

// 4. Tipos para el Editor
export const FormModalType = `
type FieldConfig = {
  name: string;
  label: string;
  type: "text" | "number" | "email" | "select" | "date" | "icon";
  placeholder?: string;
  options?: { label: string; value: string }[]; // Solo para selects
  className?: string; // Para controlar el ancho (col-span-1, etc.)
};
type FormModalConfig = {
  className?: string;
  classNameForm?: string;
  title?: string;
  description?: string;
  confirmName?: string;
  cancelName?: string;
};

type FormModalDataDef = {
  schema?: any;
  fields?: FieldConfig[];
  defaultValues: IComponentData<DynamicValue<any>>;
};

interface FormModalProps {
  id: string;
  config?: FormModalConfig;
  data?: IComponentData<FormModalDataDef>;
  onSubmit?: ComponentEvent;
  context?: Context;
}

interface FormModalFactory {
  (data: FormModalProps): Component;
}

declare const FormModal: FormModalFactory;
`;


============================================================
FILE_PATH: src\lib\ComponentBuilders\Fragment.ts
============================================================
import { v4 as uuid } from "uuid";
import { Component, Context } from "./Component";

// Definici√≥n de las props que recibe la funci√≥n constructora
type FragmentData = {
  id?: string; // Opcional, generamos uno si no viene
  children?: Component[] | Component; // Aceptamos uno o varios
  context?: Context;
};

type FragmentFactory = (data: FragmentData) => Component;

export const Fragment: FragmentFactory = ({ id, children, context }) => {
  return {
    id: id ?? uuid(), // ID √∫nico necesario para el key de React
    type: "Fragment",
    context,
    config: {}, // Sin config visual
    data: {}, // Sin data compleja por ahora
    events: {},
    subComponents: children, // Aqu√≠ guardamos los hijos
  };
};

// --- Definici√≥n para el Editor (Intellisense) ---
export const FragmentType = `
interface FragmentProps {
  id?: string;
  children?: Component[] | Component;
  context?: Context;
}

declare const Fragment: (data: FragmentProps) => Component;
`;


============================================================
FILE_PATH: src\lib\ComponentBuilders\Gallery.ts
============================================================
import {
  Component,
  ComponentEvent,
  DynamicValue,
  Context,
  IComponentData,
} from "./Component";

export type GalleryItem = {
  id: string;
  title: string;
  description?: string;
  imageUrl: string;
};

// --- Tipos Nuevos ---
type ContextMenuItemConfig = {
  label: string;
  icon?: "Trash" | "Edit" | "Copy" | "Eye" | "Settings"; // Iconos soportados
  variant?: "default" | "destructive";
  onClick: ComponentEvent; // La funci√≥n a ejecutar
};

type AddButtonConfig = {
  label: string;
  icon?: string;
  variant?: string;
  onClick: ComponentEvent;
};
// --------------------

type GalleryConfig = {
  className?: string;
  searchable?: boolean;
  cardSize?: string;
  height?: string;
  style?: Record<string, any>;
  // Config interna (se llena autom√°ticamente)
  addButton?: { label: string; icon?: string };
  contextMenu?: Array<{
    label: string;
    icon?: string;
    variant?: string;
    separator?: boolean;
  }>;
};

export type GalleryEvent = {
  setItems: (items: GalleryItem[]) => void;
  getItems: () => GalleryItem[];
  reload: () => void;
};

export interface GalleryMap {
  [id: string]: GalleryEvent;
}

type GalleryData = {
  id: string;
  config?: Omit<GalleryConfig, "addButton" | "contextMenu">; // Excluimos para pasarlos expl√≠citamente
  items?: IComponentData<DynamicValue<GalleryItem[]>>;
  context?: Context;

  // Eventos Principales
  onCardClick?: ComponentEvent;

  // Nuevas Propiedades
  addButton?: AddButtonConfig;
  contextMenu?: (ContextMenuItemConfig | { separator: true })[];
};

type GalleryFactory = (data: GalleryData) => Component;

export const Gallery: GalleryFactory = ({
  id,
  config,
  items,
  onCardClick,
  addButton,
  contextMenu,
  context,
}) => {
  // 1. Procesar eventos del men√∫ contextual
  // Convertimos el array de objetos con funciones a:
  // - config: array de datos planos (label, icon)
  // - events: mapa de funciones (onContextAction_0, onContextAction_1...)
  const contextEvents: Record<string, ComponentEvent> = {};
  const contextConfig = contextMenu?.map((item, index) => {
    if ("separator" in item) return { separator: true };

    // Guardamos la funci√≥n en el objeto de eventos con un nombre indexado
    contextEvents[`onContextAction_${index}`] = item.onClick;

    return {
      label: item.label,
      icon: item.icon,
      variant: item.variant,
    };
  });

  // 2. Procesar bot√≥n de agregar
  const addEvents: Record<string, ComponentEvent> = {};
  let addButtonConfig: any = undefined;

  if (addButton) {
    addEvents["onAddClick"] = addButton.onClick;
    addButtonConfig = {
      label: addButton.label,
      icon: addButton.icon,
      variant: addButton.variant,
    };
  }

  return {
    id,
    type: "Gallery",
    context,
    data: { items },
    config: {
      ...(config ?? { searchable: true }),
      addButton: addButtonConfig,
      contextMenu: contextConfig,
    },
    events: {
      onCardClick: onCardClick || (() => {}),
      ...contextEvents,
      ...addEvents,
    },
  };
};

// --- Definici√≥n para Intellisense (Editor) ---
export const GalleryType = `
type GalleryItem = {
  id: string;
  title: string;
  description?: string;
  imageUrl: string;

};

type ContextMenuItem = {
  label: string;
  icon?: "Trash" | "Edit" | "Copy" | "Eye" | "Settings";
  variant?: "default" | "destructive" | "outline";
  onClick?: (item: GalleryItem, ctx: Context) => void;
};

type AddButtonConfig = {
  label: string;
  icon?: string;
  variant?: "outline"| "default";
  onClick: (e: any, ctx: Context) => void;
};

interface GalleryProps {
  id: string;
  items?: IComponentData<DynamicValue<GalleryItem[]>>;
  
  // Configuraci√≥n UI b√°sica
  config?: {
    className?: string;
    searchable?: boolean;
    cardSize?: string;
    height?: string;
    style?: {
      gallery?:Record<string,any>;
      title?: Record<string, any>;
      description?: Record<string, any>;
      img?: Record<string, any>;
      card?: Record<string, any>;
    };
  };

  // Acciones
  onCardClick?: (item: GalleryItem, ctx: Context) => void;
  
  // Nuevas funcionalidades
  addButton?: AddButtonConfig;
  contextMenu?: (ContextMenuItem | { separator: true })[];
  
  context?: Context;
}

declare const Gallery: (data: GalleryProps) => Component;
`;

export const GalleryEventsType = `
type GalleryItem = {
  id: string;
  title: string;
  description?: string;
  imageUrl: string;
};

type GalleryEvent = {
  setItems: (items: GalleryItem[]) => void;
  getItems: () => GalleryItem[];
  reload:()=>void;
};

interface GalleryMap {
  [id: string]: GalleryEvent; 
}
`;


============================================================
FILE_PATH: src\lib\ComponentBuilders\Layout.ts
============================================================
import { Component, Context } from "./Component";

type LayoutConfig = {
  className?: string;
  style?: Record<string, any>;
};

type Layout = (
  data: { id: string; config: LayoutConfig; context?: Context },
  subComponents: Component[]
) => Component;

export const Layout: Layout = (
  { id, config, context },
  subComponents: Component[]
) => {
  return {
    id,
    type: "Layout",
    config,
    data: {},
    context,
    events: {},
    buildFuncs: {},
    subComponents,
  };
};

export const LayoutType = `
type LayoutConfig = {
  className?: string;
  style?: Record<string,any>;
};

type Layout = (
  data: { id: string; config: LayoutConfig, context?:Context },
  subComponents: Component[]
) => Component;

declare const Layout:Layout;
`;


============================================================
FILE_PATH: src\lib\ComponentBuilders\LoaddingModal.ts
============================================================
import { Component, ComponentEvent, Context } from "./Component";

// 1. Configuraci√≥n
type LoadingModalConfig = {
  className?: string;
  title?: string;
  description?: string;
  disableEscape?: boolean;
  disableOutside?: boolean;
};

interface LoadingModalProps {
  id: string;
  config?: LoadingModalConfig;
  onOpen?: ComponentEvent;
  onClose?: ComponentEvent;
  context?: Context;
}
type LoadingModalFactory = (data: LoadingModalProps) => Component;

// 3. Factory
export const LoadingModal: LoadingModalFactory = ({
  id,
  config,
  context,
  onOpen,
  onClose,
}) => {
  return {
    id,
    type: "LoadingModal", // Aseg√∫rate de registrar este string en tu mapa de componentes principal
    context,
    data: {},
    config: config ?? {},
    events: { onOpen, onClose },
  };
};

// 4. Tipos para el Editor
export const LoadingModalType = `


type LoadingModalConfig = {
  className?: string;
  title?:string;
  description?:string;
  disableEscape?:boolean;
  disableOutside?:boolean;
};

interface LoadingModalProps {
  id: string;
  config?: LoadingModalConfig;
  onOpen?:ComponentEvent;
  onClose?:ComponentEvent;
  context?: Context;
}

interface LoadingModalFactory {
  (data: LoadingModalProps): Component;
}

declare const LoadingModal: LoadingModalFactory;
`;


============================================================
FILE_PATH: src\lib\ComponentBuilders\Navigation.ts
============================================================
import { Component, ComponentEvent, Context } from "./Component";

export type NavigationRoute = {
  id: string;
  label: string;
  icon?: string;
  children?: Component[];
  subRoutes?: NavigationRoute[];
};

type NavigationConfig = {
  className?: string;
  homeLabel?: string;
  showTabs?: boolean;
  showBreadcrumb?: boolean; // Nuevo: Ocultar breadcrumb
};

export type NavigationEvent = {
  // Ahora acepta un objeto de datos opcional
  navigate: (routePath: string, data?: any) => void;
  getCurrentPath: () => string;
  getRouteData: () => any; // Nuevo: Obtener datos de la ruta actual
};

export interface NavigationMap {
  [id: string]: NavigationEvent;
}

type NavigationData = {
  id: string;
  config?: NavigationConfig;
  routes: NavigationRoute[];
  onNavigate: ComponentEvent;
  context?: Context;
};

type NavigationFactory = (data: NavigationData) => Component;

export const Navigation: NavigationFactory = ({
  id,
  config,
  routes,
  onNavigate,
  context,
}) => {
  return {
    id,
    type: "Navigation",
    context,
    data: { routes },
    // Por defecto breadcrumb visible
    config: config ?? {
      homeLabel: "Inicio",
      showTabs: true,
      showBreadcrumb: true,
    },
    events: { onNavigate },
  };
};

// Tipos para el Editor
export const NavigationType = `
type NavigationRoute = {
  id: string;
  label: string;
  icon?: string;
  children?: Component[];
  subRoutes?: NavigationRoute[];
};

type NavigationConfig = {
  className?: string;
  homeLabel?: string;
  showTabs?: boolean;
  showBreadcrumb?: boolean;
};

interface NavigationProps {
  id: string;
  routes: NavigationRoute[];
  config?: NavigationConfig;
  onNavigate?: ComponentEvent;
  context?: Context;
}

interface NavigationFactory {
  (data: NavigationProps): Component;
}

declare const Navigation: NavigationFactory;
`;
export const NavigationEventsType = `
type NavigationEvent = {
  navigate: (routePath: string, data?: any) => void;
  getCurrentPath: () => string;
  getRouteData: () => any;
};

interface NavigationMap {
  [id: string]: NavigationEvent; 
}
`;


============================================================
FILE_PATH: src\lib\ComponentBuilders\Table.ts
============================================================
import {
  Component,
  ComponentEvent,
  DynamicValue,
  Context,
  IComponentData,
} from "./Component";

export type TableColumn = {
  accessorKey: string;
  header: string;
  enableSorting?: boolean;
  width?: string;
};

type TableConfig = {
  className?: string;
  pageSize?: number;
  enableRowSelection?: boolean;
  enableExport?: boolean;
};

export type TableEvent = {
  setData: (data: any[]) => void;
  getData: () => any[];
  getSelectedRows: () => any[];
  reload: () => void; // NUEVO: M√©todo reload
};

type TableData = {
  id: string;
  config?: TableConfig;
  // CAMBIO: Ahora columns es din√°mico
  columns: IComponentData<DynamicValue<TableColumn[]>>;
  data?: IComponentData<DynamicValue<any[]>>;

  onRowClick: ComponentEvent;
  onEdit: ComponentEvent;
  onDelete: ComponentEvent;
  onBulkDelete: ComponentEvent;

  context?: Context;
};

type TableFactory = (data: TableData) => Component;

export const Table: TableFactory = ({
  id,
  config,
  columns,
  data,
  onRowClick,
  onEdit,
  onDelete,
  onBulkDelete,
  context,
}) => {
  return {
    id,
    type: "Table",
    context,
    // Pasamos tanto columns como items dentro de data para ser procesados
    data: { columns, items: data },
    config: config ?? {
      pageSize: 5,
      enableRowSelection: false,
      enableExport: true,
    },
    events: { onRowClick, onEdit, onDelete, onBulkDelete },
  };
};

// --- String Types para el Editor (Actualizados) ---
export const TableType = `
type TableColumn = {
  accessorKey: string;
  header: string;
  enableSorting?: boolean;
  width?: string;
};

type TableConfig = {
  className?: string;
  pageSize?: number;
  enableRowSelection?: boolean;
  enableExport?: boolean;
};

interface TableProps {
  id: string;
  // CAMBIO: Definici√≥n din√°mica para el editor
  columns: IComponentData<DynamicValue<TableColumn[]>>;
  data?: IComponentData<DynamicValue<any[]>>;
  config?: TableConfig;
  onRowClick?: ComponentEvent;
  onEdit?: ComponentEvent;
  onDelete?: ComponentEvent;
  onBulkDelete?: ComponentEvent;
  context?: Context;
}

interface TableFactory {
  (data: TableProps): Component;
}

declare const Table: TableFactory;
`;

export const TableEventsType = `
type TableEvent = {
  setData: (data: any[]) => void;
  getData: () => any[];
  getSelectedRows: () => any[];
  reload: () => void;
};

interface TableMap {
  [id: string]: TableEvent;
}
`;


============================================================
FILE_PATH: src\lib\ComponentBuilders\Text.ts
============================================================
import {
  Component,
  ComponentEvent,
  DynamicValue,
  Context,
  IComponentData,
} from "./Component";

// 1. Configuraci√≥n Visual
type TextConfig = {
  className?: string;
  variant?:
    | "h1"
    | "h2"
    | "h3"
    | "h4"
    | "p"
    | "blockquote"
    | "lead"
    | "large"
    | "small"
    | "muted";
  align?: "left" | "center" | "right" | "justify";
};

// 2. Eventos expuestos
export type TextEvent = {
  setText: (text: string) => void;
  getText: () => string;
};

export interface TextMap {
  [id: string]: TextEvent;
}

// 3. Estructura de datos
type TextData = {
  id: string;
  config?: TextConfig;
  content?: IComponentData<DynamicValue<string>>; // El contenido del texto
  onClick: ComponentEvent; // Opcional: hacer click en el texto
  context?: Context;
};

type TextFactory = (data: TextData) => Component;

// 4. Factory
export const CText: TextFactory = ({
  id,
  config,
  content,
  onClick,
  context,
}) => {
  return {
    id,
    type: "Text",
    context,
    data: { content },
    config: config ?? { variant: "p", align: "left" },
    events: { onClick },
  };
};

// 5. String Types para el Editor
export const TextType = `
type TextVariant = "h1" | "h2" | "h3" | "h4" | "p" | "blockquote" | "lead" | "large" | "small" | "muted";
type TextAlign = "left" | "center" | "right" | "justify";

type TextConfig = {
  className?: string;
  style?:Record<string,any>;
  variant?: TextVariant;
  align?: TextAlign;
};

interface TextProps {
  id: string;
  content?: IComponentData<DynamicValue<string>>; // El contenido del texto
  config?: TextConfig;
  onClick?: ComponentEvent;
  context?: Context;
}

interface TextFactory {
  (data: TextProps): Component;
}

declare const CText: TextFactory;
`;
export const TextEventsType = `
type TextEvent = {
  setText: (text: string) => void;
  getText: () => string;
};

interface TextMap {
  [id: string]: TextEvent;
}
`;


============================================================
FILE_PATH: src\lib\monaco\TypeBuilder.ts
============================================================
// lib/monaco/TypeBuilder.ts

import { parseSqlScript } from "../runScript/runScript";

export class TypeBuilder {
  private definitions: string[] = [];

  constructor() {}

  /** Agrega definiciones b√°sicas de JS (Console, Math, JSON b√°sico si noLib: true) */
  addCore(): this {
    this.definitions.push(`
      declare const console: {
        log(...args: any[]): void;
        warn(...args: any[]): void;
        error(...args: any[]): void;
      };
      declare const Math: any;
      declare const JSON: any;
    `);
    return this;
  }

  /** Agrega definiciones para un contexto de ejecuci√≥n espec√≠fico */
  addContext(contextVariables: Record<string, string>): this {
    const lines = Object.entries(contextVariables).map(
      ([key, type]) => `declare const ${key}: ${type};`
    );
    this.definitions.push(lines.join("\n"));
    return this;
  }

  /** Agrega las Queries SQL din√°micamente */
  addSqlQueries(sqlCode: string): this {
    // Aqu√≠ usar√≠as tu parseSqlScript
    // Simulaci√≥n para el ejemplo:
    // const queries = ["getItems", "updateUser"];
    const queries = Object.keys(parseSqlScript(sqlCode));

    const queryProps = queries.map((q) => `  "${q}": string;`).join("\n");

    this.definitions.push(`
       /** Consultas extra√≠das autom√°ticamente de tu SQL */
       declare const QUERIES: {
         ${queryProps}
       };
     `);
    return this;
  }

  /** Agrega definiciones personalizadas desde un string */
  addCustom(definition: string | string[]): this {
    if (typeof definition == "string") {
      this.definitions.push(definition);
    } else {
      this.definitions.push(...definition);
    }
    return this;
  }

  build(): string {
    return this.definitions.join("\n\n");
  }
}


============================================================
FILE_PATH: src\lib\redux\hooks.ts
============================================================
import { useDispatch, useSelector, useStore } from "react-redux";
import { AppDispatch, AppStore, RootState } from "./store";

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch = useDispatch.withTypes<AppDispatch>();
export const useAppSelector = useSelector.withTypes<RootState>();
export const useAppStore = useStore.withTypes<AppStore>();


============================================================
FILE_PATH: src\lib\redux\store.ts
============================================================
import { configureStore } from "@reduxjs/toolkit";
import dashboardSlice from "./features/dashboardSlice";
import pageSlice from "./features/pageSlice";
import scriptEditorSlice from "./features/ScriptEditorSlice";
import DBConnectionSlice from "./features/ConnectionSlice";

export const makeStore = () => {
  return configureStore({
    reducer: {
      dashboards: dashboardSlice,
      pages: pageSlice,
      scriptEditor: scriptEditorSlice,
      DBConnection: DBConnectionSlice,
    },
    middleware: (getDefaultMiddleware) =>
      getDefaultMiddleware({
        serializableCheck: {
          // Solo ignoramos la acci√≥n espec√≠fica de tu editor si devuelve datos complejos
          // Eliminamos FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER
          ignoredActions: ["scriptEditor/execute/fulfilled"],
        },
      }),
  });
};

// Exportar tipos inferidos
export type AppStore = ReturnType<typeof makeStore>;
export type RootState = ReturnType<AppStore["getState"]>;
export type AppDispatch = AppStore["dispatch"];


============================================================
FILE_PATH: src\lib\redux\features\ConnectionSlice.ts
============================================================
import { createSlice, PayloadAction } from "@reduxjs/toolkit";

interface ConnectionState {
  isConnected: boolean;
}

const initialState: ConnectionState = {
  isConnected: false,
};

export const DBConnectionSlice = createSlice({
  name: "DBconnection",
  initialState,
  reducers: {
    setIsConnected: (state, action: PayloadAction<boolean>) => {
      state.isConnected = action.payload;
    },
  },
});

export const { setIsConnected } = DBConnectionSlice.actions;
export default DBConnectionSlice.reducer;


============================================================
FILE_PATH: src\lib\redux\features\dashboardSlice.ts
============================================================
import { createSlice, createAsyncThunk, PayloadAction } from "@reduxjs/toolkit";
import { Dashboard } from "@/types/types";
import { systemSupabase } from "@/lib/supabase/client"; // Tu cliente supabase

interface DashboardState {
  byId: Record<string, Dashboard>;
  /*   activeDashboardId: string | null; */
  status: "idle" | "loading" | "succeeded" | "failed";
}

const initialState: DashboardState = {
  byId: {},
  /*   activeDashboardId: null, */
  status: "idle",
};

// --- THUNKS (Acciones As√≠ncronas) ---

// 1. Fetch Dashboards
export const fetchDashboards = createAsyncThunk(
  "dashboards/fetchDashboards",
  async () => {
    const { data, error } = await systemSupabase.from("dashboards").select("*");

    if (error) throw error;
    return data;
  }
);

// 2. Add Dashboard
export const addDashboardRemote = createAsyncThunk(
  "dashboards/addDashboard",
  async ({ name, userId }: { name: string; userId: string }) => {
    const { data, error } = await systemSupabase
      .from("dashboards")
      .insert({
        name,
        user_id: userId,
        config: {},
        config_script: "",
      })
      .select()
      .single();

    if (error) throw error;
    return data;
  }
);

// 3. Update Dashboard (Config o Nombre)
export const updateDashboardRemote = createAsyncThunk(
  "dashboards/updateDashboard",
  async (payload: { id: string; updates: Partial<Dashboard> }) => {
    // Mapeamos camelCase a snake_case para la BD
    const dbUpdates: any = {};
    if (payload.updates.name) dbUpdates.name = payload.updates.name;
    if (payload.updates.config) dbUpdates.config = payload.updates.config;
    if (payload.updates.configScript)
      dbUpdates.config_script = payload.updates.configScript;

    const { data, error } = await systemSupabase
      .from("dashboards")
      .update(dbUpdates)
      .eq("id", payload.id)
      .select()
      .single();

    if (error) throw error;
    return data; // Retorna el objeto actualizado de la DB
  }
);

// 4. Delete Dashboard
export const deleteDashboardRemote = createAsyncThunk(
  "dashboards/deleteDashboard",
  async (id: string) => {
    const { error } = await systemSupabase
      .from("dashboards")
      .delete()
      .eq("id", id);
    if (error) throw error;
    return id;
  }
);

export const dashboardSlice = createSlice({
  name: "dashboards",
  initialState,
  reducers: {
    /*     selectDashboard: (state, action: PayloadAction<{ id: string }>) => {
      state.activeDashboardId = action.payload.id;
    }, */
  },
  extraReducers: (builder) => {
    // --- Fetch Handlers ---
    builder.addCase(fetchDashboards.fulfilled, (state, action) => {
      state.status = "succeeded";
      // Convertir array de DB a Objeto byId y mapear campos
      const dashboardsMap: Record<string, Dashboard> = {};
      action.payload.forEach((dbDash: any) => {
        dashboardsMap[dbDash.id] = {
          id: dbDash.id,
          name: dbDash.name,
          config: dbDash.config,
          configScript: dbDash.config_script, // Snake a Camel
          pageIds: [], // Se llenar√° din√°micamente o se infiere
        };
      });
      state.byId = dashboardsMap;
    });

    // --- Add Handlers ---
    builder.addCase(addDashboardRemote.fulfilled, (state, action) => {
      const dbDash = action.payload;
      state.byId[dbDash.id] = {
        id: dbDash.id,
        name: dbDash.name,
        config: dbDash.config,
        configScript: dbDash.config_script,
        pageIds: [],
      };
      /*       // Opcional: Seleccionar el nuevo dashboard
      state.activeDashboardId = dbDash.id; */
    });

    // --- Update Handlers ---
    builder.addCase(updateDashboardRemote.fulfilled, (state, action) => {
      const dbDash = action.payload;
      if (state.byId[dbDash.id]) {
        state.byId[dbDash.id] = {
          ...state.byId[dbDash.id],
          name: dbDash.name,
          config: dbDash.config,
          configScript: dbDash.config_script,
        };
      }
    });

    // --- Delete Handlers ---
    builder.addCase(deleteDashboardRemote.fulfilled, (state, action) => {
      delete state.byId[action.payload];
      /*       if (state.activeDashboardId === action.payload) {
        state.activeDashboardId = null;
      } */
    });
  },
});

export const {} = dashboardSlice.actions;
export default dashboardSlice.reducer;


============================================================
FILE_PATH: src\lib\redux\features\pageSlice.ts
============================================================
import { createSlice, createAsyncThunk, PayloadAction } from "@reduxjs/toolkit";
import { Page } from "@/types/types";
import { systemSupabase } from "@/lib/supabase/client";
import { IconName } from "@/components/custom/DynamicIcon";

interface PageState {
  byId: Record<string, Page & { isLoaded?: boolean }>;
  status: "idle" | "loading" | "succeeded" | "failed";
}

const initialState: PageState = {
  byId: {},
  status: "idle",
};

// --- THUNKS ---

// 1. Fetch Pages (Trae todo)
export const fetchPages = createAsyncThunk("pages/fetchPages", async () => {
  const { data, error } = await systemSupabase.from("pages").select("*");
  if (error) throw error;
  return data;
});

// 2. Add Page
export const addPageRemote = createAsyncThunk(
  "pages/addPage",
  async ({
    dashboardId,
    name,
    icon,
    userId,
  }: {
    dashboardId: string;
    name: string;
    icon: IconName;
    userId: string;
  }) => {
    const { data, error } = await systemSupabase
      .from("pages")
      .insert({
        dashboard_id: dashboardId,
        user_id: userId,
        name,
        icon,
        js_script: "",
        sql_script: "",
      })
      .select()
      .single();

    if (error) throw error;
    return data;
  }
);

// 3. Update Page
export const updatePageRemote = createAsyncThunk(
  "pages/updatePage",
  async (payload: { id: string; updates: Partial<Page> }) => {
    const dbUpdates: any = {};
    if (payload.updates.name) dbUpdates.name = payload.updates.name;
    if (payload.updates.jsScript !== undefined)
      dbUpdates.js_script = payload.updates.jsScript;
    if (payload.updates.sqlScript !== undefined)
      dbUpdates.sql_script = payload.updates.sqlScript;
    if (payload.updates.isPublic !== undefined) {
      dbUpdates.is_public = payload.updates.isPublic;
    }

    const { data, error } = await systemSupabase
      .from("pages")
      .update(dbUpdates)
      .eq("id", payload.id)
      .select()
      .single();

    if (error) throw error;
    return data;
  }
);

// 4. Delete Page
export const deletePageRemote = createAsyncThunk(
  "pages/deletePage",
  async (id: string) => {
    const { error } = await systemSupabase.from("pages").delete().eq("id", id);
    if (error) throw error;
    return id;
  }
);

// 5. Fetch Page CONTENT (Espec√≠fico)
export const fetchPageContent = createAsyncThunk(
  "pages/fetchPageContent",
  async (pageId: string) => {
    const { data, error } = await systemSupabase
      .from("pages")
      .select("id, js_script, sql_script")
      .eq("id", pageId)
      .single();

    if (error) throw error;
    return data;
  }
);
export const fetchPageWithConfig = createAsyncThunk(
  "pages/fetchPageWithConfig",
  async (pageId: string) => {
    const { data, error } = await systemSupabase
      .rpc("get_public_page_details", { p_page_id: pageId })
      .maybeSingle(); // <--- CAMBIO IMPORTANTE: Usar maybeSingle

    if (error) throw error;

    // Si es privada/no existe, data ser√° null. Eso est√° bien, el hook lo manejar√°.
    return data;
  }
);

export const pageSlice = createSlice({
  name: "pages",
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    // ----------------------------------------------------------------
    // 1. FETCH PAGES (CORREGIDO: MERGE STRATEGY)
    // ----------------------------------------------------------------
    builder.addCase(fetchPages.pending, (state) => {
      state.status = "loading";
    });

    builder.addCase(fetchPages.fulfilled, (state, action) => {
      state.status = "succeeded";

      // Iteramos sobre los datos nuevos
      action.payload.forEach((dbPage: any) => {
        // Buscamos si ya existe una versi√≥n en memoria
        const existingPage = state.byId[dbPage.id];

        state.byId[dbPage.id] = {
          id: dbPage.id,
          dashboardId: dbPage.dashboard_id,
          name: dbPage.name,
          icon: dbPage.icon as IconName,
          isPublic: dbPage.is_public,

          // IMPORTANTE:
          // Si ya ten√≠amos scripts cargados y loaded=true, los mantenemos.
          // Si no, usamos lo que viene de la BD.
          jsScript: existingPage?.jsScript ?? dbPage.js_script ?? "",
          sqlScript: existingPage?.sqlScript ?? dbPage.sql_script ?? "",

          // Si fetchPages trae 'select("*")', t√©cnicamente ya est√° cargado.
          // Pero para estar seguros, si ya estaba loaded, lo dejamos true.
          isLoaded: existingPage?.isLoaded || true,
        };
      });
    });

    builder.addCase(fetchPages.rejected, (state, action) => {
      state.status = "failed";
      console.error("Error fetching pages:", action.error);
    });

    // ----------------------------------------------------------------
    // 2. FETCH PAGE CONTENT (CORREGIDO: SAFETY CHECK)
    // ----------------------------------------------------------------
    builder.addCase(fetchPageContent.fulfilled, (state, action) => {
      const { id, js_script, sql_script } = action.payload;

      // Si la p√°gina ya existe en la lista, actualizamos sus scripts y la marcamos loaded
      if (state.byId[id]) {
        state.byId[id].jsScript = js_script;
        state.byId[id].sqlScript = sql_script;
        state.byId[id].isLoaded = true; // <--- ESTA ES LA CLAVE
      }
      // Si por alguna raz√≥n extra√±a llega el contenido antes que la lista (Deep Linking),
      // podr√≠amos crear un entry parcial, pero es raro en tu flujo actual.
    });

    // ----------------------------------------------------------------
    // OTRAS ACCIONES
    // ----------------------------------------------------------------
    builder.addCase(addPageRemote.fulfilled, (state, action) => {
      const dbPage = action.payload;
      state.byId[dbPage.id] = {
        id: dbPage.id,
        dashboardId: dbPage.dashboard_id,
        name: dbPage.name,
        icon: dbPage.icon as IconName,
        jsScript: dbPage.js_script,
        sqlScript: dbPage.sql_script,
        isPublic: dbPage.is_public,
        isLoaded: true, // Una p√°gina nueva creada ya tiene sus datos (vac√≠os) listos
      };
    });

    builder.addCase(updatePageRemote.fulfilled, (state, action) => {
      const dbPage = action.payload;
      if (state.byId[dbPage.id]) {
        state.byId[dbPage.id] = {
          ...state.byId[dbPage.id],
          name: dbPage.name,
          jsScript: dbPage.js_script,
          sqlScript: dbPage.sql_script,
          isPublic: dbPage.is_public,
        };
      }
    });

    builder.addCase(deletePageRemote.fulfilled, (state, action) => {
      delete state.byId[action.payload];
    });

    // Limpieza al borrar dashboard
    builder.addCase(
      "dashboards/deleteDashboard/fulfilled",
      (state, action: any) => {
        const dashboardId = action.payload;
        Object.keys(state.byId).forEach((pageId) => {
          if (state.byId[pageId].dashboardId === dashboardId) {
            delete state.byId[pageId];
          }
        });
      }
    );
  },
});

export const {} = pageSlice.actions;
export default pageSlice.reducer;


============================================================
FILE_PATH: src\lib\redux\features\ScriptEditorSlice.ts
============================================================
import { createSlice, PayloadAction } from "@reduxjs/toolkit";

export interface LogEntry {
  message: string;
  data?: any;
}

interface ScriptState {
  sqlCode: string;
  jsCode: string;
  logs: LogEntry[];
  isEditing: boolean;
}

const initialState: ScriptState = {
  sqlCode: "",
  jsCode: "",
  logs: [],
  isEditing: false,
};

export const ScriptEditor = createSlice({
  name: "scriptEditor",
  initialState,
  reducers: {
    setJsCode: (state, action: PayloadAction<string>) => {
      state.jsCode = action.payload;
    },
    setSqlCode: (state, action: PayloadAction<string>) => {
      state.sqlCode = action.payload;
    },
    clearConsole: (state) => {
      state.logs = [];
    },
    setIsEditing: (state, action: PayloadAction<boolean>) => {
      state.isEditing = action.payload;
    },
    addExecutionLogs: (
      state,
      action: PayloadAction<{ logs: LogEntry[]; result?: any }>
    ) => {
      const { logs, result } = action.payload;
      // 1. Logs internos del script
      const newLogs = logs.map((l: any) => ({ step: "JS", ...l }));
      state.logs.push(...newLogs);

      // 2. Log del return final (Sanitizado)
      if (result !== undefined) {
        state.logs.push({
          message: "Script finalizado. Return:",
          data: result, // Asumimos que ya viene sanitizado desde el componente
        });
      }
    },
  },
});

export const {
  setJsCode,
  setSqlCode,
  clearConsole,
  addExecutionLogs,
  setIsEditing,
} = ScriptEditor.actions;
export default ScriptEditor.reducer;


============================================================
FILE_PATH: src\lib\supabase\client.ts
============================================================
import { createBrowserClient } from "@supabase/ssr";

// NO uses createClient de '@supabase/supabase-js' directamente si usas Next.js App Router
export const systemSupabase = createBrowserClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);


============================================================
FILE_PATH: src\providers\DatabaseProvider.tsx
============================================================
// src/context/DatabaseContext.tsx
"use client";

import React, { createContext, useContext, useState, ReactNode } from "react";
import {
  DatabaseAdapter,
  QueryResult,
} from "@/features/scriptConnection/lib/types";
import { SupabaseAdapter } from "@/features/scriptConnection/lib/SupabaseAdapter";
import { MockAdapter } from "@/features/scriptConnection/lib/MockAdapter";

// Registro de adaptadores disponibles
const ADAPTERS: Record<string, () => DatabaseAdapter> = {
  supabase: () => new SupabaseAdapter(),
  mock: () => new MockAdapter(),
  // sqlite: () => new SqlJsAdapter(), // Aqu√≠ ir√≠a el de SQL.js si lo integras
};

interface DatabaseContextType {
  adapter: DatabaseAdapter | null;
  isLoading: boolean;
  activeAdapterId: string;
  connectTo: (adapterId: string) => Promise<void>;
  executeQuery: (query: string) => Promise<QueryResult>;
}

const DatabaseContext = createContext<DatabaseContextType | undefined>(
  undefined
);

export const DatabaseProvider = ({ children }: { children: ReactNode }) => {
  const [adapter, setAdapter] = useState<DatabaseAdapter | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [activeAdapterId, setActiveAdapterId] = useState<string>("");

  const connectTo = async (adapterId: string) => {
    setIsLoading(true);
    try {
      // 1. Desconectar el anterior si existe
      if (adapter) {
        await adapter.disconnect();
      }

      // 2. Instanciar el nuevo
      const createAdapter = ADAPTERS[adapterId];
      if (!createAdapter)
        throw new Error(`Adaptador ${adapterId} no encontrado`);

      const newAdapter = createAdapter();

      // 3. Conectar
      await newAdapter.connect();

      // 4. Actualizar estado
      setAdapter(newAdapter);
      setActiveAdapterId(adapterId);
    } catch (error) {
      console.error("Error al cambiar de base de datos:", error);
      alert("Error conectando a la base de datos");
    } finally {
      setIsLoading(false);
    }
  };

  const executeQuery = async (query: string): Promise<QueryResult> => {
    if (!adapter) {
      return { data: null, error: "No hay base de datos seleccionada" };
    }
    return await adapter.execute(query);
  };

  return (
    <DatabaseContext.Provider
      value={{ adapter, isLoading, activeAdapterId, connectTo, executeQuery }}
    >
      {children}
    </DatabaseContext.Provider>
  );
};

// Hook personalizado para usar el contexto
export const useDatabase = () => {
  const context = useContext(DatabaseContext);
  if (!context)
    throw new Error("useDatabase debe usarse dentro de DatabaseProvider");
  return context;
};


============================================================
FILE_PATH: src\providers\ModalProvider.tsx
============================================================
"use client";

import React, {
  createContext,
  useContext,
  useReducer,
  ReactNode,
  useMemo,
  useRef,
} from "react";

// 1. EL ESTADO DE REACT SOLO MANEJA VISIBILIDAD Y REGISTRO (UI)
interface ModalState {
  registeredModals: Set<string>;
  openModals: string[];
  // Ya no guardamos la data aqu√≠ para evitar problemas de asincron√≠a
}

type ModalAction =
  | { type: "REGISTER"; id: string }
  | { type: "UNREGISTER"; id: string }
  | { type: "OPEN"; id: string } // OPEN ya no necesita payload en el reducer
  | { type: "CLOSE"; id: string }
  | { type: "CLOSE_ALL" };

const initialState: ModalState = {
  registeredModals: new Set(),
  openModals: [],
};

const modalReducer = (state: ModalState, action: ModalAction): ModalState => {
  switch (action.type) {
    case "REGISTER": {
      const newRegistry = new Set(state.registeredModals);
      newRegistry.add(action.id);
      return { ...state, registeredModals: newRegistry };
    }
    case "UNREGISTER": {
      const newRegistry = new Set(state.registeredModals);
      newRegistry.delete(action.id);
      return {
        ...state,
        registeredModals: newRegistry,
        openModals: state.openModals.filter((mid) => mid !== action.id),
      };
    }
    case "OPEN": {
      if (!state.registeredModals.has(action.id)) {
        console.warn(`Intento de abrir modal no registrado: ${action.id}`);
        return state;
      }
      // Solo actualizamos si no estaba abierto ya, para evitar re-renders innecesarios
      if (state.openModals.includes(action.id)) {
        return state;
      }
      return {
        ...state,
        openModals: [...state.openModals, action.id],
      };
    }
    case "CLOSE": {
      return {
        ...state,
        openModals: state.openModals.filter((mid) => mid !== action.id),
      };
    }
    case "CLOSE_ALL":
      return { ...state, openModals: [] };
    default:
      return state;
  }
};

interface ModalContextType {
  isModalOpen: (id: string) => boolean;
  openModal: <T = any>(id: string, data?: T) => void;
  closeModal: (id: string) => void;
  closeAllModals: () => void;
  registerModal: (id: string) => void;
  unregisterModal: (id: string) => void;
  getModalData: <T = any>(id: string) => T | undefined;
}

const ModalContext = createContext<ModalContextType | undefined>(undefined);

export const ModalProvider = ({ children }: { children: ReactNode }) => {
  const [state, dispatch] = useReducer(modalReducer, initialState);

  // 2. EL REF SE ENCARGA EXCLUSIVAMENTE DE LOS DATOS
  // Esto permite acceso s√≠ncrono inmediato (Write -> Read en la misma ejecuci√≥n)
  const modalDataRef = useRef<Record<string, any>>({});

  const value = useMemo(
    () => ({
      isModalOpen: (id: string) => state.openModals.includes(id),

      openModal: <T = any,>(id: string, data?: T) => {
        // A. Guardamos la data en el Ref (S√≠ncrono e Inmediato)
        if (data !== undefined) {
          modalDataRef.current[id] = data;
        }

        // B. Avisamos a React para que muestre el modal (As√≠ncrono)
        dispatch({ type: "OPEN", id });
      },

      closeModal: (id: string) => {
        // Opcional: ¬øQuieres limpiar la data al cerrar?
        // Si no, la dejas ah√≠ para persistencia.
        // delete modalDataRef.current[id];
        dispatch({ type: "CLOSE", id });
      },

      closeAllModals: () => {
        dispatch({ type: "CLOSE_ALL" });
      },

      registerModal: (id: string) => dispatch({ type: "REGISTER", id }),

      unregisterModal: (id: string) => {
        // Limpieza de memoria al destruir el modal
        delete modalDataRef.current[id];
        dispatch({ type: "UNREGISTER", id });
      },

      // LECTURA S√çNCRONA DIRECTA
      getModalData: <T = any,>(id: string) => {
        return modalDataRef.current[id] as T;
      },
    }),
    [state.openModals, state.registeredModals] // Dependencias solo de UI
  );

  return (
    <ModalContext.Provider value={value}>{children}</ModalContext.Provider>
  );
};

export const useModals = () => {
  const context = useContext(ModalContext);
  if (!context)
    throw new Error("useModals debe usarse dentro de ModalProvider");
  return context;
};


============================================================
FILE_PATH: src\providers\Providers.tsx
============================================================
import { ReactNode } from "react";
import StoreProvider from "./StoreProvider";
import { ThemeProvider } from "./ThemeProvider";
import { ModalProvider } from "./ModalProvider";
import { DatabaseProvider } from "./DatabaseProvider";
import { UserProvider } from "@/hooks/useUser";

export const Providers = ({ children }: { children?: ReactNode }) => {
  return (
    <UserProvider>
      <DatabaseProvider>
        <ModalProvider>
          <StoreProvider>
            <ThemeProvider
              attribute="class"
              defaultTheme="system"
              enableSystem
              disableTransitionOnChange
            >
              {children}
            </ThemeProvider>
          </StoreProvider>
        </ModalProvider>
      </DatabaseProvider>
    </UserProvider>
  );
};


============================================================
FILE_PATH: src\providers\StoreProvider.tsx
============================================================
/* eslint-disable react-hooks/refs */
"use client";
import { useRef } from "react";
import { Provider } from "react-redux";
import { makeStore, AppStore } from "@/lib/redux/store";

export default function StoreProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  // Usamos useRef para mantener la instancia del store a trav√©s de re-renders
  // sin disparar nuevos renderizados cuando se crea.
  const storeRef = useRef<AppStore>(undefined);

  if (!storeRef.current) {
    // Crea la instancia del store la primera vez que se renderiza este componente
    storeRef.current = makeStore();
  }

  return <Provider store={storeRef.current}>{children}</Provider>;
}


============================================================
FILE_PATH: src\providers\ThemeProvider.tsx
============================================================
"use client";

import * as React from "react";
import { ThemeProvider as NextThemesProvider } from "next-themes";

export function ThemeProvider({
  children,
  ...props
}: React.ComponentProps<typeof NextThemesProvider>) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}


============================================================
FILE_PATH: src\types\types.ts
============================================================
import { IconName } from "@/components/custom/DynamicIcon";

export interface Page {
  icon: IconName;
  name: string;
  id: string;
  dashboardId: string;
  sqlScript: string;
  jsScript: string;
  isPublic: boolean;
}

export interface Dashboard {
  id: string;
  name: string;
  pageIds: string[];
  config: Record<string, any>;
  configScript: string;
}


============================================================
FILE_PATH: src\utils\sqlHelper.ts
============================================================
// utils/sqlHelpers.ts
export const interpolateQuery = (
  query: string,
  variables: Record<string, any>
) => {
  return query.replace(/\{\{(\w+)\}\}/g, (_, key) => {
    return variables[key] !== undefined ? `'${variables[key]}'` : "NULL";
  });
};

